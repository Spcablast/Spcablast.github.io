{"meta":{"title":"YP Blog","subtitle":"咸的博客","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-11-18T00:47:46.650Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://spcablast.club/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-13T12:48:45.850Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"about/index.html","permalink":"http://spcablast.club/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-11-13T12:49:26.061Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://spcablast.club/categories/index.html","excerpt":"","text":""},{"title":"reading","date":"2021-11-18T00:51:00.817Z","updated":"2021-11-18T00:51:00.817Z","comments":true,"path":"books/书单.html","permalink":"http://spcablast.club/books/%E4%B9%A6%E5%8D%95.html","excerpt":"","text":"《艺术创造学》 余秋雨 《论道德和自由》叔本华 《六祖坛经》 论充足根据律的四重根 叔本华 裸猿三部曲 生命是什么 薛定谔 《上瘾》 机器学习 周志华 鲁迅全集（太长） 作为意志和表象的世界 叔本华 荣格 红书，认识人性 弗洛伊德 阿德勒 《自卑与超越》 韦启昌译叔本华 心理学之旅 论语 道德形而上学奠基句读 邓晓芒 etc.虽然作者著书的时间不同于当代，但是他们想表达的内容确实在人的范围里，这是他们根据自己的智慧得出来的结论或者经验或者是过程的记录，是他们自己的感受。是，前人的智慧。可以从中学到他们的思考方式，甚至有些东西能直接拿来用 藏书馆：《自私的基因》 《人为什么活着》王小波 《西方哲学史》罗素 《代码之美》 《非暴力沟通》 《浮生六记》 九把刀 古龙 《把时间当朋友》 《相约星期二》 《数学原理》罗素 《源氏物语》《活着本来单纯》《丰子恺文集》 《社会性动物》 《理解人性》阿德勒 《怪诞心理学》 《陈丹青音乐笔记》 《艺术创造学》 《道德情操论》 《逃避自由》 《怪诞行为学》 《直觉泵和其他思考工具》 《生命是什么》薛定谔 《叔本华思想随笔》 《深入理解计算机系统》 《菊与刀》 《皮肤的秘密》 《偶像的黄昏》 《作为意志和表象的世界》 《纯粹理性批判》 《宪法》 《行政法》 《民法》 《中医基础理论》 《自然哲学之数学原理》 《杨戬-人生长恨水长东》 《精神现象学》我觉得一点没看 《叔本华美学随笔》 《茶花女》 《逻辑学上/下》我怎么一点印象没有 《北京折叠》 《康德哲学选讲-邓晓芒》 《象与骑象人》 《中国-传统与变革》 《当下的力量》 《韩瑜文集》 《现代操作系统》 《Linux内核完全注释》 《偶像的黄昏》 《大学，中庸》 《偶像的黄昏》 《中国文化的深层结构》 《态度改变与社会影响》 《自卑与超越》 《裸猿》 《侠客行》 金庸 《大问题 简明哲学导论》 《丧家狗》 《春秋大义》 《1984》 《悟空传》 《动物农场》 《哥伦比亚的倒影》 《变形记》 《洛丽塔》 《周易参同契》 《我所有的朋友都死了？》 《子不语》 《各自的朝圣路》 《资本论》必没看完 《梦的解析》 《雪中悍刀行》 《木心诗选》 《你应该熟读的中国古诗》 《尼采诗集》 《遇见最美的宋词》 《人间失格》 《瓦尔登湖》 《牛虻》没看 《一个陌生女人的来信》 《闲情偶寄》 《杀死一只知更鸟》 《罗生门》 《我与地坛》 《芥川龙之介作品选集》没印象 《人生哲思录》 《荣格自传》 《无人生还》 《人间草木》 《小王子》 《王尔德诗选》 《诗境浅说》 《忏悔录》 《论人生不平等的起源和基础》 《月亮和六便士》 《简爱》 《苦儿流浪记》 《文学回忆录》《木心谈木心》 《苏东坡传》 《感觉的自然史》 下次继续列"},{"title":"","date":"2021-12-24T04:25:08.031Z","updated":"2020-11-11T09:08:54.000Z","comments":true,"path":"dist/APlayer.min.js","permalink":"http://spcablast.club/dist/APlayer.min.js","excerpt":"","text":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"APlayer\",[],t):\"object\"==typeof exports?exports.APlayer=t():e.APlayer=t()}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=41)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=/mobile/i.test(window.navigator.userAgent),a={secondToTime:function(e){var t=Math.floor(e/3600),n=Math.floor((e-3600*t)/60),i=Math.floor(e-3600*t-60*n);return(t>0?[t,n,i]:[n,i]).map(function(e){return e=0;t--){var n=Math.floor(Math.random()*(t+1)),i=e[n];e[n]=e[t],e[t]=i}return e}([].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);ti?t:e+(t-e)*((a=n/i)n?\"function\"==typeof i&&i(t):l(u)}()},n=function(e){if(!e.defaultPrevented){e.preventDefault(),location.hash!==this.hash&&window.history.pushState(null,null,this.hash);var n=document.getElementById(this.hash.substring(1));if(!n)return;t(n,500,function(e){location.replace(\"#\"+e.id)})}};return document.addEventListener(\"DOMContentLoaded\",function(){for(var e,t=document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'),i=t.length;e=t[--i];)e.addEventListener(\"click\",n,!1)}),t}})?i.call(t,n,t,e):i)||(e.exports=a)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;n1),n=0===this.audios.length;this.player.template.listOl.innerHTML+=(0,a.default)({theme:this.player.options.theme,audio:e,index:this.audios.length+1}),this.audios=this.audios.concat(e),t&&this.audios.length>1&&this.player.container.classList.add(\"aplayer-withlist\"),this.player.randomOrder=r.default.randomOrder(this.audios.length),this.player.template.listCurs=this.player.container.querySelectorAll(\".aplayer-list-cur\"),this.player.template.listCurs[this.audios.length-1].style.backgroundColor=e.theme||this.player.options.theme,n&&(\"random\"===this.player.options.order?this.switch(this.player.randomOrder[0]):this.switch(0))}},{key:\"remove\",value:function(e){if(this.player.events.trigger(\"listremove\",{index:e}),this.audios[e])if(this.audios.length>1){var t=this.player.container.querySelectorAll(\".aplayer-list li\");t[e].remove(),this.audios.splice(e,1),this.player.lrc&&this.player.lrc.remove(e),e===this.index&&(this.audios[e]?this.switch(e):this.switch(e-1)),this.index>e&&this.index--;for(var n=e;n"},{"title":"","date":"2021-12-24T04:25:08.028Z","updated":"2020-11-11T09:08:54.000Z","comments":true,"path":"dist/APlayer.min.css","permalink":"http://spcablast.club/dist/APlayer.min.css","excerpt":"","text":".aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;transition:all .3s ease;max-width:400px}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffff\",endColorstr=\"#00ffffff\",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:\" \"}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#00ffffff\",endColorstr=\"#ccffffff\",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;transition:all .5s ease-out;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;transition:all .5s ease;will-change:height;display:none;overflow:hidden}.aplayer .aplayer-list.aplayer-list-hide{max-height:0!important}.aplayer .aplayer-list ol{list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list ol::-webkit-scrollbar{width:5px}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list ol li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list ol li:first-child{border-top:none}.aplayer .aplayer-list ol li:hover{background:#efefef}.aplayer .aplayer-list ol li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list ol li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}} /*# sourceMappingURL=APlayer.min.css.map*/"},{"title":"友情链接","date":"2021-11-13T13:26:44.960Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-24T08:25:31.071Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://spcablast.club/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-13T12:49:53.171Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://spcablast.club/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-12-24T04:26:43.395Z","updated":"2021-12-24T04:26:43.395Z","comments":true,"path":"dist/music.js","permalink":"http://spcablast.club/dist/music.js","excerpt":"","text":"const ap = new APlayer({ container: document.getElementById('aplayer'), fixed: true, autoplay: false, audio: [ { name: \"你一定要幸福\", artist: '简弘亦', url: 'http://www.ytmp3.cn/down/51689.mp3', cover: 'http://img.ytmp3.cn/image/52.jpg', }, { name: '一百万个可能(Live)', artist: '摩登兄弟', url: 'http://www.ytmp3.cn/down/52772.mp3', cover: 'http://img.ytmp3.cn/image/53.jpg', }, { name: 'The Rose', artist: 'Westlife', url: 'http://www.ytmp3.cn/down/56694.mp3', cover: 'http://img.ytmp3.cn/image/51.jpg', }, { name: 'In The Eyes', artist: '江映东', url: 'http://www.ytmp3.cn/down/53053.mp3', cover: 'http://img.ytmp3.cn/image/10.jpg', } ] });"},{"title":"书单","date":"2021-11-15T05:02:33.109Z","updated":"2021-11-15T05:02:33.109Z","comments":true,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"}],"posts":[{"title":"Dailycode","slug":"20220115","date":"2022-01-14T16:00:00.000Z","updated":"2022-01-15T09:56:56.965Z","comments":true,"path":"2022/01/15/20220115/","link":"","permalink":"http://spcablast.club/2022/01/15/20220115/","excerpt":"","text":"查找和最小的 K 对数字给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。 请找到和最小的 k 个数对 (u1,v1), (u2,v2) … (uk,vk) 。 示例 1: 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool flag = true; vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; //啊，我看着意思就是先看两边谁更小，取出来，加另一边的，再看取出的那一列加另一边的下一个大还是现在这个加下一个大，重复 vector&lt;vector&lt;int&gt;&gt; ans; int n = nums1.size(), m = nums2.size(); if(m &lt; n)&#123; swap(nums1, nums2); swap(m, n); flag = false; &#125; //定义比较规则,返回是a序列的和是否大于b序列的和 auto cmp = [&amp;](const auto&amp; a, const auto&amp; b)&#123; return nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;; priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; min(n,k); ++i)&#123; q.push(&#123;i,0&#125;); &#125; while(ans.size() &lt; k &amp;&amp; q.size())&#123; auto [a,b] = q.top(); q.pop(); flag ? ans.push_back(&#123;nums1[a], nums2[b]&#125;) : ans.push_back(&#123;nums2[b], nums1[a]&#125;); if(b + 1 &lt; m)&#123; q.push(&#123;a,b+1&#125;); &#125; &#125; return ans; &#125;&#125;; 希望我下次看到这道题还能会374. 猜数字大小猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num1：我选出的数字比你猜的数字大 pick &gt; num0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num返回我选出的数字。 示例 1： 输入：n = 10, pick = 6输出：6 123456789101112131415161718192021222324252627/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */class Solution &#123;public: int guessNumber(int n) &#123; int ans; int left = 0, right = n-1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2;//防溢出专用方法 if(guess(mid) == -1)&#123; right = mid -1; &#125; else if(guess(mid) == 1)&#123; left = mid +1; &#125; else return mid; &#125; return left; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"归并排序","slug":"归并排序","permalink":"http://spcablast.club/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"author":"YP"},{"title":"Dailycode","slug":"20220113","date":"2022-01-12T16:00:00.000Z","updated":"2022-01-13T12:03:53.997Z","comments":true,"path":"2022/01/13/20220113/","link":"","permalink":"http://spcablast.club/2022/01/13/20220113/","excerpt":"","text":"Fizz Buzz给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。answer[i] == “Fizz” 如果 i 是 3 的倍数。answer[i] == “Buzz” 如果 i 是 5 的倍数。answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 输入：n = 3输出：[“1”,”2”,”Fizz”] 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; ans; for(int i = 1; i &lt;= n; ++i)&#123; string temp; if (i % 3 == 0) &#123; temp+= \"Fizz\"; &#125; if (i % 5 == 0) &#123; temp += \"Buzz\"; &#125; if (temp.size() == 0) &#123; temp += to_string(i); &#125; ans.emplace_back(temp); &#125; return ans; &#125;&#125;; 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。示例 2： 输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //看起来好难啊，这咋做 //正整数集合，分成两个和相等的子集，那么这个和肯定是1/2个整个集合， //找一个数组里面是否有一些数加起来会等于一个值 //该怎么找呢？暴力？先一个，再两个，必超时 //我看懂了，并大受震撼，居然是用动态规划做，先排除一些不可能的情况，比如总和为奇数，只有一个数，其中最大的数大于一半， int n = nums.size(); if (n &lt; 2) &#123; return false; &#125; int sum = accumulate(nums.begin(), nums.end(), 0); int maxNum = *max_element(nums.begin(), nums.end()); if (sum &amp; 1) &#123; return false; &#125; int target = sum / 2; if (maxNum &gt; target) &#123; return false; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(target + 1, 0));//n行，一半和的大小列，添加一个数，列减去这个数，列为零说明刚好能加到 for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = true; &#125; dp[0][nums[0]] = true; for (int i = 1; i &lt; n; i++) &#123; int num = nums[i]; for (int j = 1; j &lt;= target; j++) &#123; if (j &gt;= num) &#123; dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]; &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n - 1][target]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220111","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-13T11:47:46.369Z","comments":true,"path":"2022/01/11/20220111/","link":"","permalink":"http://spcablast.club/2022/01/11/20220111/","excerpt":"","text":"有效的回旋镖回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例 1： 输入：[[1,1],[2,3],[3,2]]输出：true 1234567class Solution &#123;public: //x1-x2/y1-y2 = x1-x3/y1-y3 bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; return (points[0][0]-points[1][0])*(points[2][1]-points[1][1]) != (points[2][0]-points[1][0])*(points[0][1]-points[1][1]); &#125;&#125;; 把二叉搜索树转换为累加树给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。注意：该题目与 538: https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ 相同 示例 1： 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]示例 2： 输入：root = [0,null,1]输出：[1,null,1] 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int sum = 0; TreeNode* bstToGst(TreeNode* root) &#123; //这意思就是要在每个节点所有的右子树里边找比节点大的数都加起来呗 if (root != nullptr) &#123; bstToGst(root-&gt;right); sum += root-&gt;val; root-&gt;val = sum; bstToGst(root-&gt;left); &#125; return root; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20220110","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-10T12:46:43.764Z","comments":true,"path":"2022/01/10/20220110/","link":"","permalink":"http://spcablast.club/2022/01/10/20220110/","excerpt":"","text":"最小高度树树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。 示例 1： 输入：n = 4, edges = [[1,0],[1,2],[1,3]]输出：[1]解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; //这岂不是列出来每个节点的邻接点数量，从最多的开始，把他当头，然后重复 //每次删除所有的叶子节点？最后剩下的就是答案？ if (n == 1) return &#123;0&#125;; vector&lt;int&gt; res; // 每个节点的度数 vector&lt;int&gt; degree(n); // 建立无向邻接图 vector&lt;vector&lt;int&gt;&gt; map(n); for (int i = 0; i &lt; edges.size(); i++) &#123; int v1 = edges[i][0]; int v2 = edges[i][1]; degree[v1]++; degree[v2]++; map[v1].push_back(v2); map[v2].push_back(v1); &#125; // 把度为1的节点入队 queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) &#123; if (degree[i] == 1) q.push(i); &#125; // BFS while (!q.empty()) &#123; // 清理当前层的节点 res.clear(); int size = q.size(); while (size--) &#123; int cur = q.front(); q.pop(); res.push_back(cur); // 减小对应度数 degree[cur]--; for (auto i : map[cur]) &#123; degree[i]--; if (degree[i] == 1) &#123; q.push(i); &#125; &#125; &#125; &#125; return res; //作者：carpe-diem-ew //[链接](https://leetcode-cn.com/problems/minimum-height-trees/solution/bfs-liang-duan-shao-xiang-qiu-zhong-dian-5mol/) //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; 剑指 Offer II 088. 爬楼梯的最少成本数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。 请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 12345678910111213class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //动态规划，起始点是-1，从-1支付0点走一步或两步，之后支付对应楼梯成本 vector&lt;int&gt; dp(cost.size()+1); dp[0] = 0; dp[1] = 0; for(int i = 2; i&lt;=cost.size();++i)&#123; dp[i] = min(cost[i-2] + dp[i-2],cost[i-1] + dp[i-1]); &#125; return dp[cost.size()]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"图","slug":"图","permalink":"http://spcablast.club/tags/%E5%9B%BE/"}],"author":"YP"},{"title":"Dailycode","slug":"20220107","date":"2022-01-06T16:00:00.000Z","updated":"2022-01-07T14:29:42.683Z","comments":true,"path":"2022/01/07/20220107/","link":"","permalink":"http://spcablast.club/2022/01/07/20220107/","excerpt":"","text":"最大网络秩n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。 给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。 1234567891011121314151617181920212223242526class Solution &#123;public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; //这是个无向图， //城市对的网络秩是两个点的边的数量，如果两个点互连，减一 //那这问题就转成在图里找两个点，他们的边最多，存一下，比一比 //暴力就来一个二维矩阵，n*n, //不暴力就来一个hash——map，没用， //来一个啥呢 int ans = 0; vector&lt;vector&lt;int&gt;&gt; adj(n);//邻接表存图 for (auto road : roads) adj[road[0]].emplace_back(road[1]), adj[road[1]].emplace_back(road[0]); for (int i = 0; i &lt; n; ++i) &#123; vector&lt;bool&gt; v(n);//存当前点连着哪些点 for (int j : adj[i]) &#123;//节点i和他连着的j ans = max(ans, (int)adj[i].size() + (int)adj[j].size() - 1); v[j] = true; &#125; for (int j = i + 1; j &lt; n; ++j)//节点i和剩下的节点j if (!v[j]) ans = max(ans, (int)adj[i].size() + (int)adj[j].size()); &#125; return ans; &#125;&#125;; 删除某些元素后的数组均值给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。 与 标准答案 误差在 10-5 的结果都被视为正确结果。 示例 1： 输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]输出：2.00000解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 12345678910111213class Solution &#123;public: double trimMean(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(),arr.end()); int start = arr.size()/20; int n = arr.size(); double ans = 0; for(int i = start; i &lt; n - start; ++i)&#123; ans +=arr [i]; &#125; return ans / (n - n / 10); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"图","slug":"图","permalink":"http://spcablast.club/tags/%E5%9B%BE/"},{"name":"多","slug":"多","permalink":"http://spcablast.club/tags/%E5%A4%9A/"}],"author":"YP"},{"title":"Dailycode","slug":"20220106","date":"2022-01-05T16:00:00.000Z","updated":"2022-01-06T12:35:11.909Z","comments":true,"path":"2022/01/06/20220106/","link":"","permalink":"http://spcablast.club/2022/01/06/20220106/","excerpt":"","text":"简化路径给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。 请注意，返回的 规范路径 必须遵循下述格式： 始终以斜杠 ‘/‘ 开头。两个目录名之间必须只有一个斜杠 ‘/‘ 。最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。返回简化后得到的 规范路径 。 示例 1： 输入：path = “/home/“输出：”/home”解释：注意，最后一个目录名后面没有斜杠。 1234567891011121314151617181920class Solution(object): def simplifyPath(self, path): \"\"\" :type path: str :rtype: str \"\"\" #用栈嘛，把规则写一写 #首先/入栈 #如果/后面有.. ./ ../ / 就去掉， # ... 还得留下， #如果最后一位是 / 也去掉 names = path.split(\"/\") stack = list() for name in names: if name == \"..\": if stack: stack.pop() elif name and name != \".\": stack.append(name) return \"/\" + \"/\".join(stack) 3 的幂给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x 示例 1： 输入：n = 27输出：true 12345678910111213141516class Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n == 0 : return False if n == 1 : return True while n!=1: if n%3 == 0: n/=3 else: return False return True 今日吐槽：好家伙，用python连if都不会写，哈哈哈","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"vector","slug":"vector","permalink":"http://spcablast.club/tags/vector/"}],"author":"YP"},{"title":"Dailycode","slug":"20220105","date":"2022-01-04T16:00:00.000Z","updated":"2022-01-05T12:50:42.687Z","comments":true,"path":"2022/01/05/20220105/","link":"","permalink":"http://spcablast.club/2022/01/05/20220105/","excerpt":"","text":"替换所有的问号给你一个仅包含小写英文字母和 ‘?’ 字符的字符串 s，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 ‘?’ 字符。 题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例 1： 输入：s = “?zs”输出：”azs”解释：该示例共有 25 种解决方案，从 “azs” 到 “yzs” 都是符合题目要求的。只有 “z” 是无效的修改，因为字符串 “zzs” 中有连续重复的两个 ‘z’ 。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string modifyString(string s) &#123; //补上什么呢，用一个数组，去掉左右，然后 int ans[26]; for(int i = 0;i&lt;26;++i)&#123; ans[i] = i; &#125; for(int i = 0;i&lt;s.size();++i)&#123; if(s[i] == '?')&#123; for(int j = 0; j &lt; 26; ++j)&#123; if(i == 0)&#123;//tou if(s[1] - 'a' == ans[j]) continue; else &#123; s[i] = 'a' + ans[j]; break; &#125; &#125; else if(i == s.size() -1)&#123;//wei if(s[s.size()-2] - 'a' == ans[j]) continue; else &#123; s[i] = 'a' + ans[j]; break; &#125; &#125; else&#123; if(s[i-1] - 'a' == ans[j] || s[i+1] - 'a' == ans[j]) continue; else s[i] = 'a' + ans[j]; &#125; &#125; &#125; &#125; return s; &#125;&#125;; 数的平方等于两数乘积的方法数给你两个整数数组 nums1 和 nums2 ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）： 类型 1：三元组 (i, j, k) ，如果 nums1[i]2 == nums2[j] * nums2[k] 其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; k &lt; nums2.length类型 2：三元组 (i, j, k) ，如果 nums2[i]2 == nums1[j] * nums1[k] 其中 0 &lt;= i &lt; nums2.length 且 0 &lt;= j &lt; k &lt; nums1.length 示例 1： 输入：nums1 = [7,4], nums2 = [5,2,8,9]输出：1解释：类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: // int getTriplets(const unordered_map&lt;int, int&gt;&amp; map1, const unordered_map&lt;int, int&gt;&amp; map2) &#123; // int triplets = 0; // for (const auto&amp; [num1, count1]: map1) &#123; // long long square = (long long)num1 * num1; // for (const auto&amp; [num2, count2]: map2) &#123; // if (square % num2 == 0 &amp;&amp; square / num2 &lt;= INT_MAX) &#123; // int num3 = square / num2; // if (num2 == num3) &#123; // int curTriplets = count1 * count2 * (count2 - 1) / 2; // triplets += curTriplets; // &#125; else if (num2 &lt; num3 &amp;&amp; map2.count(num3)) &#123; // int count3 = map2.at(num3); // int curTriplets = count1 * count2 * count3; // triplets += curTriplets; // &#125; // &#125; // &#125; // &#125; // return triplets; // &#125; int getTriplets(const unordered_map&lt;int,int&gt;&amp; map1, const unordered_map&lt;int, int&gt;&amp; map2)&#123; int ans = 0; for(const auto&amp; [num1, cnt1] : map1)&#123; long long sqrt1 = (long long)num1*num1;//少加了一个longlong溢出了 for(const auto&amp; [num2, cnt2] : map2)&#123; if(sqrt1 % num2 == 0 &amp;&amp; sqrt1 / num2 &lt;= INT_MAX)&#123; int num3 = sqrt1 / num2; if(num2 == num3)&#123; int temp = cnt1 * cnt2 * (cnt2 -1 ) /2;//排列组合 ans += temp; &#125; else if(num2 &lt; num3 &amp;&amp; map2.count(num3))&#123;//防止算两遍 int _num_num3 = map2.at(num3); int temp1 = cnt1 * cnt2 * _num_num3; ans += temp1; &#125; &#125; &#125; &#125; return ans; &#125; int numTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int, int&gt; map1, map2; for (int num: nums1) &#123; ++map1[num]; &#125; for (int num: nums2) &#123; ++map2[num]; &#125; return getTriplets(map1, map2) + getTriplets(map2, map1); &#125;&#125;; 今日吐槽：晚上睡少了，晚睡早起，等死吧，中午从11点半睡到1点，爽~开组会都不困，下午精神也很好，晚睡不如早睡，早早下班，该歇了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220104","date":"2022-01-03T16:00:00.000Z","updated":"2022-01-04T14:19:52.445Z","comments":true,"path":"2022/01/04/20220104/","link":"","permalink":"http://spcablast.club/2022/01/04/20220104/","excerpt":"","text":"组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]示例 2： 输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 201 &lt;= k &lt;= n 1234567891011121314151617181920212223242526272829class Solution &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; void dfs(int start, int n, int k)&#123; //保存并返回条件 if(temp.size() == k) &#123; ans.push_back(temp); return; &#125; //返回条件 if(n - start + 1 + temp.size() &lt; k)&#123; return; &#125; //选start temp.push_back(start); dfs(start+1, n, k); //不选start temp.pop_back(); dfs(start + 1, n, k); &#125;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; //这，这不数学题吗，排列组合？C n k? //得找一个方案把所有结果列出来 //问题就在于怎么用代码复现取数的操作 dfs(1,n,k); return ans; &#125;&#125;; 相同的树给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3]输出：true 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public://靠，写完一看，忘了return true的条件，过了48/60的测试用例。。。。。。。。 bool dfs(TreeNode* p, TreeNode* q)&#123; if(p == nullptr &amp;&amp; q == nullptr) return true; else if(p == nullptr || q == nullptr) return false; else if(p-&gt;val != q-&gt;val) return false; else return dfs(p-&gt;left,q-&gt;left) &amp;&amp; dfs(p-&gt;right , q-&gt;right); &#125; bool isSameTree(TreeNode* p, TreeNode* q) &#123; bool ans = true; ans = dfs(p, q); return ans; &#125;&#125;; 今日吐槽：放假三天睡了个舒服，感觉和放假前几周完全不一样，正经人谁晚睡早起啊，当然是晚睡晚起啦，早睡早起也还行。就这个点，回去谁睡觉啊，虽然困了，那肯定也至少要11点以后了，除非9点跑路，九点下班就能11点前睡觉","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220103","date":"2022-01-02T16:00:00.000Z","updated":"2022-01-03T14:11:25.705Z","comments":true,"path":"2022/01/03/20220103/","link":"","permalink":"http://spcablast.club/2022/01/03/20220103/","excerpt":"","text":"一周中的第几天给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}。 示例 1： 输入：day = 31, month = 8, year = 2019输出：”Saturday” 12345678910111213class Solution &#123;public: string dayOfTheWeek(int day, int month, int year) &#123; vector&lt;string&gt; weeks&#123;\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;; vector&lt;int&gt; months&#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int days = 365*(year - 1970) + (year - 1969)/4;//四年一闰 for(int i = 0; i &lt; month - 1; ++i)&#123; days += months[i]; &#125; days += day; return weeks[(days + 3)%7]; &#125;&#125;; 删除一次得到子数组最大和给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。 注意，删除一个元素后，子数组 不能为空。 请看示例： 示例 1： 输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。 //不仅不会，而且不李姐 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int maximumSum(vector&lt;int&gt;&amp; arr) &#123; //靠，动态规划？ //得取一个连续子数组出来，去掉一个，和最大 //重点是去掉一个这个等于什么操作呢？ //数组和，那肯定是里面负数越少和越大 int n=arr.size(); bool flag=false;//表示数组里有无正数 int maxNum=INT_MIN;//存最大数 for(int i=0;i&lt;n;i++)&#123; if(arr[i]&gt;0)&#123; flag=true; break; &#125; maxNum=max(maxNum,arr[i]); &#125; if(flag==false)return maxNum; vector&lt;int&gt;pre(n+2),nex(n+2); int add=0; for(int i=1;i&lt;=n;i++)&#123;//记录从0到i的和的最大值 add+=arr[i-1]; if(add&lt;arr[i-1])add=arr[i-1]; pre[i]=add&gt;0?add:0; &#125; add=0; for(int i=n;i&gt;=1;i--)&#123;//记录从n到0的和的最大值 add+=arr[i-1]; if(add&lt;arr[i-1])add=arr[i-1]; nex[i]=add&gt;0?add:0; &#125; int ans=INT_MIN; for(int i=1;i&lt;=n;i++)&#123; ans=max(max(ans,pre[i-1] + nex[i+1] + arr[i-1]), pre[i-1] + nex[i+1]);//去掉i和不去掉i比较 &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220102","date":"2022-01-01T16:00:00.000Z","updated":"2022-01-02T12:06:24.339Z","comments":true,"path":"2022/01/02/20220102/","link":"","permalink":"http://spcablast.club/2022/01/02/20220102/","excerpt":"","text":"消除游戏列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法： 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。给你整数 n ，返回 arr 最后剩下的数字。 示例 1： 输入：n = 9输出：6解释：arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]arr = [2, 4, 6, 8]arr = [2, 6]arr = [6] 123456789101112131415161718class Solution &#123;public: int lastRemaining(int n) &#123; int num=n;//记录剩下的数字数目 int l=1;//记录最小值 int r=n;//记录最大值 int d=0;//记录循环次数 int lift=1;//记录公差 while(num&gt;2)&#123; d++; if(num%2==1||num%2==0&amp;&amp;d%2==1)&#123;l+=lift;&#125;//从右到左 if(num%2==1||num%2==0&amp;&amp;d%2==0)&#123;r-=lift;&#125;//从左到右 num/=2; lift*=2; &#125; return num==2&amp;&amp;d%2==0?r:l; &#125;&#125;; 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢： 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 示例 1： 输入：s = “abc”, t = “ahbgdc”输出：true 12345678910111213141516class Solution &#123;public: bool isSubsequence(string s, string t) &#123; //那当然是一次循环建立一个hash表，数组都行，存哪些字母有，有几个啦 //不能改位置啊，打扰了 int n = s.length(), m = t.length(); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (s[i] == t[j]) &#123; i++; &#125; j++; &#125; return i == n; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220101","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-02T12:06:11.152Z","comments":true,"path":"2022/01/01/20220101/","link":"","permalink":"http://spcablast.club/2022/01/01/20220101/","excerpt":"","text":"将一维数组转变成二维数组给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和 n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。 original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。 示例 2： 输入：original = [1,2,3], m = 1, n = 3输出：[[1,2,3]]解释：构造出的二维数组应该包含 1 行 3 列。将 original 中所有三个元素放入第一行中，构成要求的二维数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-1d-array-into-2d-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; construct2DArray(vector&lt;int&gt;&amp; original, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(m*n != original.size()) return ans; for(int i = 0; i&lt; m;++i)&#123; vector&lt;int&gt; temp; for(int j = 0; j&lt; n;j++)&#123; temp.push_back(original[i*n + j]); &#125; ans.push_back(temp); &#125; return ans; &#125;&#125;; 连接后等于目标字符串的字符串对给你一个 数字 字符串数组 nums 和一个 数字 字符串 target ，请你返回 nums[i] + nums[j] （两个字符串连接）结果等于 target 的下标 (i, j) （需满足 i != j）的数目。 示例 1： 输入：nums = [“777”,”7”,”77”,”77”], target = “7777”输出：4解释：符合要求的下标对包括： (0, 1)：”777” + “7” (1, 0)：”7” + “777” (2, 3)：”77” + “77” (3, 2)：”77” + “77” //有人在整活，但我不说是谁，7就完事儿了 12345678910111213141516171819202122232425262728class Solution &#123;public: int numOfPairs(vector&lt;string&gt;&amp; nums, string target) &#123; //这个乍一看，直接暴力， //仔细一想，还是想暴力 //hhh //想到个好主意，先把nums里面放到hash表里，避免有重复的 int result = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; stringstream ss; if (nums[i].size() &gt;= target.size()) &#123; continue; &#125; for (int j = 0; j &lt; nums.size(); j++) &#123; if (nums[j].size() + nums[i].size() != target.size() || j == i) &#123; continue; &#125; ss &lt;&lt; nums[i]; ss &lt;&lt; nums[j]; if (ss.str() == target) &#123; result++; &#125; ss.str(\"\"); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211231","date":"2021-12-30T16:00:00.000Z","updated":"2021-12-31T11:29:44.599Z","comments":true,"path":"2021/12/31/20211231/","link":"","permalink":"http://spcablast.club/2021/12/31/20211231/","excerpt":"","text":"完美数对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。 给定一个 整数 n， 如果是完美数，返回 true，否则返回 false 示例 1： 输入：num = 28输出：true解释：28 = 1 + 2 + 4 + 7 + 141, 2, 4, 7, 和 14 是 28 的所有正因子。示例 2： 输入：num = 6输出：true 1234567891011121314151617class Solution &#123;public: bool checkPerfectNumber(int num) &#123; //怎么求一个数的因数的和嘞，遍历也太离谱了 //1是一定有，从2遍历到num/2，3到num/3 , 根号num，到根号num if(num == 1) return false; int sum = 1; for(int i = 2; i * i &lt;=num; ++i)&#123; if(num % i == 0)&#123; sum+=i; sum+=num/i; &#125; &#125; if(sum == num) return true; return false; &#125;&#125;; 出现次数最多的子树元素和给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。 你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。 示例 1：输入: 5 / 2 -3返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。 123456789101112131415161718192021222324252627282930313233&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: unordered_map&lt;int,int&gt; sum; vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;&#x2F;&#x2F;后序遍历 vector&lt;int&gt;ans; dfs(root); int maxCnt&#x3D;0; for(auto mPair:sum)&#123; maxCnt&#x3D;max(maxCnt,mPair.second);&#x2F;&#x2F;目前次数最多的 &#125; for(auto mPair:sum)&#123; if(mPair.second&#x3D;&#x3D;maxCnt)ans.push_back(mPair.first); &#125; return ans; &#125; int dfs(TreeNode*root)&#123; if(!root) return 0; int add&#x3D;root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right); sum[add]++; return add; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20211229","date":"2021-12-28T16:00:00.000Z","updated":"2021-12-29T13:31:08.232Z","comments":true,"path":"2021/12/29/20211229/","link":"","permalink":"http://spcablast.club/2021/12/29/20211229/","excerpt":"","text":"最短无序连续子数组给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 请你找出符合题意的 最短 子数组，并输出它的长度。 示例 1： 输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。示例 2： 输入：nums = [1,2,3,4]输出：0示例 3： 输入：nums = [1]输出：0 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; //顺序遍历，如果出现第一个不是升序的，说明，记录下前边的最大值，如果出现的第一个不是升序的，就需要在前边找到他应该在的位置，也就是哪个数小于他， //这样前面又有序了，也获得了第一个插入的位置，就是答案的开始（后边可能会更新，但是没关系更新了就用新的）， //然后继续往后看，有小的就往前插，每次记录这个小的的位置，这就是答案的结尾 //欸，我觉得这样就行了 //欸，是不是不用插入，记住位置就行了 int left = -1, right = -1, _max = INT_MIN, _min = INT_MAX; for(int i = 0; i &lt; nums.size(); ++i)&#123; //保存升序的序列的最大值 if(nums[i] &lt; _max)&#123; right = i; &#125; else &#123; _max = nums[i];//记住前边最大的数 &#125; if(nums[nums.size()-i-1] &gt; _min)&#123; left = nums.size()-i-1; &#125; else&#123; _min = nums[nums.size() - i -1]; &#125; &#125; //前边的最大值大于目前值，说明目前值得往前移动，这就是右边界 //后边的最小值小于当前值，说明当前值要往后移，这就是左边界 return left == -1?0:right - left + 1; &#125;&#125;; 删除最外层的括号有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。 12345678910111213141516class Solution &#123;public: string removeOuterParentheses(string s) &#123; int L=1;int R=0;//CV大法好 string ans; for(int i=1;i&lt;s.size();i++)&#123; if(s[i]=='(')L++;//永远都是（打头， else R++; if(R!=L)ans.push_back(s[i]);//左右括号 else &#123; i++;L=1;R=0; &#125; &#125; return ans; &#125;&#125;; 整花活，整个向量按其中某一维排序整半天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211228","date":"2021-12-27T16:00:00.000Z","updated":"2021-12-28T12:02:09.264Z","comments":true,"path":"2021/12/28/20211228/","link":"","permalink":"http://spcablast.club/2021/12/28/20211228/","excerpt":"","text":"实现 Trie (前缀树)Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 输入[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”][[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]输出[null, null, true, false, true, null, true] 解释Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // 返回 Truetrie.search(“app”); // 返回 Falsetrie.startsWith(“app”); // 返回 Truetrie.insert(“app”);trie.search(“app”); // 返回 True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Trie &#123;public://淦呐，用什么来区分没一个单词呢，这里的重点还是能快速查找吧，甚至能根据前缀查找//首选肯定是hashmap，但是用什么来当map的值呢？单词咋转//我想到一个离谱的实现，26叉树，每个再26叉，太浪费空间了//每个单词算出来一个int类型的数？那怎么表示前缀呢直接a代表1，然后就吧字符串变成了，不对，还是没前缀//真用树啊，这我是没想到的，好像还挺省空间的，重复的长度的字母都在一个节点上，省不少，就是每个节点得来个指针vector&lt;Trie*&gt; children;bool isEnd; Trie() :children(26), isEnd(false)&#123;&#125; Trie* searchPrefix(string prefix) &#123; Trie * node = this; int ch = 0; for(char c : prefix)&#123; ch = c - 'a'; if(node-&gt;children[ch] == nullptr)&#123;//找到一半断了，说明没找着 return nullptr; &#125; node = node-&gt;children[ch]; &#125; return node; &#125; void insert(string word) &#123; Trie* node = this; int ch = 0; for(char c : word)&#123;//根节点的子节点没这字母就创一个，最后到头了isEnd置true ch = c - 'a'; if(node-&gt;children[ch] == nullptr)&#123; node-&gt;children[ch] = new Trie(); &#125; node = node-&gt;children[ch]; &#125; node-&gt;isEnd = true; &#125; bool search(string word) &#123; Trie* node = this-&gt;searchPrefix(word); return node != nullptr &amp;&amp; node-&gt;isEnd; &#125; bool startsWith(string prefix) &#123; return this-&gt;searchPrefix(prefix) != nullptr; &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */ 有一个问题，c++在return a &amp;&amp; b的时候，如果a是false，就不会管b有没有语法错误，比如 return node != nullptr &amp;&amp; node-&gt;isEnd; 我node为空的时候是不能用node-&gt;isEnd的，顺序调换一下运行时就会报错 存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1]输出: true 123456789101112131415161718192021222324class Solution &#123;public: // bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; // //暴力的话直接二重循环，有一个就返回false // //不暴力的话， // unordered_map&lt;int, int&gt; mymap; // for(int num : nums)&#123; // mymap[num]++; // if(mymap[num]&gt;=2) return true; // &#125; // return false; // &#125; //还可以哈希表 bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; s; for (int x: nums) &#123; if (s.find(x) != s.end()) &#123; return true; &#125; s.insert(x); &#125; return false; &#125;&#125;; 果然，简单题的评论区可以获得简单的快乐，都是人才","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"树 - 算法题","slug":"树-算法题","permalink":"http://spcablast.club/tags/%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211227","date":"2021-12-26T16:00:00.000Z","updated":"2021-12-27T12:15:41.995Z","comments":true,"path":"2021/12/27/20211227/","link":"","permalink":"http://spcablast.club/2021/12/27/20211227/","excerpt":"","text":"###825. 适龄的朋友在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。 如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求： age[y] &lt;= 0.5 * age[x] + 7age[y] &gt; age[x]age[y] &gt; 100 &amp;&amp; age[x] &lt; 100否则，x 将会向 y 发送一条好友请求。 注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。 返回在该社交媒体网站上产生的好友请求总数。 示例 1： 输入：ages = [16,16]输出：2解释：2 人互发好友请求。示例 2： 输入：ages = [16,17,18]输出：2解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int numFriendRequests(vector&lt;int&gt;&amp; ages) &#123; //那么这题的主要问题就在怎么解决a给b发了，b怎么知道该不给a发，让我我肯定用个hashmap，存谁给谁发了，下次有就查一查里面有没有 //再看题目要求 //他不会给比自己年纪大的人发，他自己小于100岁，对方大于100，一样 //他不会给小于自己年龄一半加7的人发， // x/2 + 7&lt; y &lt; x int ans = 0; sort(ages.begin(),ages.end());//升序排列，排列之后就有,前边的必然不会给后边的发，除非值相同 // for(int i = 0; i&lt; ages.size(); ++i)&#123;//j会不会向i发 // for(int j = 0; j &lt;= i; ++j)&#123;//超时了，我丢 // if(ages[j] &lt;= 14) continue; // if(ages[i] &lt; (ages[j] - 7)*2 &amp;&amp; i!=j)&#123; // ans++; // &#125; // if(ages[i] == ages[j] &amp;&amp; i!=j)&#123; // ans++; // &#125; // &#125; // &#125; int left = 0, right = 0,n = ages.size(); for (int age: ages) &#123;//获取这个age会发请求的人的区间 if (age &lt; 15) &#123; continue; &#125; while (ages[left] &lt;= 0.5 * age + 7) &#123; ++left; &#125; while (right + 1 &lt; n &amp;&amp; ages[right + 1] &lt;= age) &#123; ++right; &#125; ans += right - left; &#125; return ans; &#125;&#125;; 较大分组的位置在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 示例 1： 输入：s = “abbxxxxzzy”输出：[[3,6]]解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。示例 2： 输入：s = “abc”输出：[]解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) &#123; //直接，双指针 vector&lt;vector&lt;int&gt;&gt; ans; int left = 0, right = 1; if(s.size() &lt; 3) return ans; for(int i = 0; i&lt; s.size(); ++i)&#123; vector&lt;int&gt; temp = &#123;left,right&#125;; int _len = 1; while(s[left] == s[right])&#123; right++; _len++; &#125; if(_len &gt;= 3)&#123; temp[1] = right-1; ans.push_back(temp); if(right+2 &lt; s.size())&#123; left = right; right = right+1; &#125; else return ans; &#125; else&#123; if(right+1&lt;s.size())&#123; left = right; right = right+1; &#125; else return ans; &#125; &#125; return ans; &#125;&#125;; 今日吐槽：累了，下机，歇了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211226","date":"2021-12-25T16:00:00.000Z","updated":"2021-12-27T12:19:35.910Z","comments":true,"path":"2021/12/26/20211226/","link":"","permalink":"http://spcablast.club/2021/12/26/20211226/","excerpt":"","text":"活字印刷你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。 注意：本题中，每个活字字模只能使用一次。 示例 1： 输入：”AAB”输出：8解释：可能的序列为 “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”。示例 2： 输入：”AAABBC”输出：188 12345678910111213141516171819202122class Solution &#123;//排列组合题，去掉相同的组合，public: int res; void dfs(map&lt;char, int&gt;&amp; hash) &#123;//这个dfs是绝了，这个字母取一个，然后生成一个新的hashmap，重复操作 for (auto&amp; data : hash) &#123; if (data.second &gt; 0) &#123; data.second--;//用完之后数量减一 res++; dfs(hash); data.second++;//相当于溜完他开头的，溜下一个开头的 &#125; &#125; &#125; int numTilePossibilities(string tiles) &#123;//用hashmap记录各种字母的数量，怎么达到去重，还得看dfs map&lt;char, int&gt; hash; for (char c : tiles) &#123; hash[c]++; &#125; dfs(hash); return res; &#125;&#125;; Bigram 分词给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 “first second third” 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。 示例 1： 输入：text = “alice is a good girl she is a good student”, first = “a”, second = “good”输出：[“girl”,”student”]示例 2： 输入：text = “we will we will rock you”, first = “we”, second = “will”输出：[“we”,”rock”] 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findOcurrences(string text, string first, string second) &#123; vector&lt;string&gt; textlist; int s = 0, e = 0, len = text.length(); while (true) &#123;//存到vector里，判断有没有连续的first和second，有就答案加加 while (s &lt; len &amp;&amp; text[s] == ' ') &#123;//直接双指针 s++; &#125; if (s &gt;= len) &#123; break; &#125; e = s + 1; while (e &lt; len &amp;&amp; text[e] != ' ') &#123; e++; &#125; textlist.push_back(text.substr(s, e - s)); s = e + 1; &#125; vector&lt;string&gt; ans; for (int i = 2; i &lt; textlist.size(); i++) &#123; if (textlist[i - 2] == first &amp;&amp; textlist[i - 1] == second) &#123; ans.push_back(textlist[i]); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"有一个功能他加着加着就把站炸了","slug":"node版本管理","date":"2021-12-24T16:00:00.000Z","updated":"2021-12-27T07:56:24.436Z","comments":true,"path":"2021/12/25/node版本管理/","link":"","permalink":"http://spcablast.club/2021/12/25/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"hexo 版本和nodejs版本得对应，hexo更新到最新了，欸，又嫌弃node版本太低，node版本更新了，行了，发布的时候github觉得node版本太高 于是就需要一个nodejs的版本管理器，nvm下载地址安装的时候需要装在路径名没中文，没空格的地方，你看那个Program Files,这不就一个空格嘛。 在node的官网下载对应版本，比如node-v16.4.2-win-x64.zip,解压丢到D:\\nvm下边就行了,文件夹改名为v16.4.2； 用管理员权限开命令提示符，敲进去nvm use 16.4.2就ok了 nvm use 报错：exit status 1 + 乱码，两种可能 nvm安装路径有中文或者空格 打开cmd没有使用管理员权限 管理了node的版本发现里边没装hexo，当然没装了，这都新下的nodejs，还好之前下的文件夹还在，开始重头再来，都重头再来了，下次换电脑更方便 来自从头建站npm install -g hexo-cli安装hexo 装完了hexo再装aplaer npm install hexo-tag-aplayer –save","categories":[{"name":"nvm","slug":"nvm","permalink":"http://spcablast.club/categories/nvm/"}],"tags":[{"name":"nodejs版本管理","slug":"nodejs版本管理","permalink":"http://spcablast.club/tags/nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211225","date":"2021-12-24T16:00:00.000Z","updated":"2021-12-26T01:04:07.171Z","comments":true,"path":"2021/12/25/20211225/","link":"","permalink":"http://spcablast.club/2021/12/25/20211225/","excerpt":"","text":"奇偶树如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ： 二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool isEvenOddTree(TreeNode* root) &#123; //层序遍历呗，奇数层偶数层分别不同的规则，判断一下就行 queue&lt;TreeNode*&gt; qu; int level = 0; qu.push(root); while(!qu.empty())&#123; //弹出根节点，压栈两个子节点 int prev = level % 2 == 0 ? INT_MIN : INT_MAX; int size = qu.size(); for(int i = 0; i&lt; size;++i)&#123; TreeNode * temp = qu.front(); qu.pop(); if(level % 2 == 0)&#123;//偶数层 if(temp-&gt;val % 2 == 0 || temp-&gt;val &lt;= prev)&#123; return false; &#125; &#125; if(level % 2 == 1)&#123;//奇数层 if(temp-&gt;val % 2 == 1 || temp-&gt;val &gt;= prev)&#123; return false; &#125; &#125; prev = temp-&gt;val; if (temp-&gt;left != nullptr) &#123; qu.push(temp-&gt;left); &#125; if (temp-&gt;right != nullptr) &#123; qu.push(temp-&gt;right); &#125; &#125; level++; &#125; return true; &#125;&#125;; 括号的最大嵌套深度如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）： 字符串是一个空字符串 “”，或者是一个不为 “(“ 或 “)” 的单字符。字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)： depth(“”) = 0depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 “(“ 或者 “)”depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串depth(“(“ + A + “)”) = 1 + depth(A)，其中 A 是一个 有效括号字符串例如：””、”()()”、”()(()())” 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 “)(“ 、”(()” 都不是 有效括号字符串 。 给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。 示例 1： 输入：s = “(1+(2*3)+((8)/4))+1”输出：3解释：数字 8 在嵌套的 3 层括号中。 123456789101112131415161718class Solution &#123;public: int maxDepth(string s) &#123; //上栈,甚至不用 int depth = 0; int _max = 0; for(char c : s)&#123; if( c =='(')&#123; depth ++ ; _max = depth &gt; _max?depth:_max; &#125; if(c == ')')&#123; depth --; &#125; &#125; return _max; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20211224","date":"2021-12-23T16:00:00.000Z","updated":"2021-12-25T01:48:40.568Z","comments":true,"path":"2021/12/24/20211224/","link":"","permalink":"http://spcablast.club/2021/12/24/20211224/","excerpt":"","text":"搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0输出：4 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; //本来是升序排列，但是突然尾巴接头了，所以会突然有一个降序，所以直接判断目标和首尾的大小 //如果target &gt; head //往前二分 // //如果target &lt; tail //往后二分 //否则找不到 if(!nums.size()) return -1; if(nums.size() == 1) return nums[0] == target? 0 : -1; int left = 0, right = nums.size() - 1; int mid; while(left &lt;= right)&#123; mid = (left + right)/2; if(nums[mid] == target) return mid; if (nums[0] &lt;= nums[mid]) &#123; if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;//前半部分有序 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else if( nums[0] &gt; nums[mid] )&#123;// if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() -1]) &#123;// left = mid +1; &#125; else&#123; right = mid -1; &#125; &#125; &#125; return -1;//找不到 &#125;&#125;; ###476. 数字的补数对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。 例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。给你一个整数 num ，输出它的补数。 示例 1： 输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 数字的补数对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。 例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。给你一个整数 num ，输出它的补数。 示例 1： 输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 1234567891011121314151617181920class Solution &#123;public://位运算的题，这题可以整很多天了 int findComplement(int num) &#123;//前头补1，直接取反 uint t = 1u &lt;&lt; 31; while (! (t &amp; num)) &#123; num |= t; t &gt;&gt;= 1; &#125; return ~num; // long a = 1; // while(true)&#123; // if(num &gt;= a)&#123; // a &lt;&lt;= 1; // 等价于 a *= 2; // &#125;else&#123; // return a - num - 1; // &#125; // &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"二分","slug":"二分","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%88%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211223","date":"2021-12-22T16:00:00.000Z","updated":"2021-12-27T12:19:56.449Z","comments":true,"path":"2021/12/23/20211223/","link":"","permalink":"http://spcablast.club/2021/12/23/20211223/","excerpt":"","text":"###589. N 叉树的前序遍历给定一个 N 叉树，返回其节点值的 前序遍历 。 N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 进阶： 递归法很简单，你可以使用迭代法完成此题吗?//简简单单一个dfs 1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt;ans; void DFS(Node* root)&#123; if(root)&#123; ans.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; DFS(root-&gt;children[i]); &#125; &#125; &#125; vector&lt;int&gt; preorder(Node* root) &#123; DFS(root); return ans; &#125;&#125;; ###576. 出界的路径数给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。 12345678910111213141516171819202122232425262728class Solution &#123;public: static constexpr int MOD = 1'000'000'007; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) &#123; vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int outCounts = 0; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n))); dp[0][startRow][startColumn] = 1; for (int i = 0; i &lt; maxMove; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; int count = dp[i][j][k]; if (count &gt; 0) &#123; for (auto &amp;direction : directions) &#123; int j1 = j + direction[0], k1 = k + direction[1]; if (j1 &gt;= 0 &amp;&amp; j1 &lt; m &amp;&amp; k1 &gt;= 0 &amp;&amp; k1 &lt; n) &#123; dp[i + 1][j1][k1] = (dp[i + 1][j1][k1] + count) % MOD; &#125; else &#123; outCounts = (outCounts + count) % MOD; &#125; &#125; &#125; &#125; &#125; &#125; return outCounts; &#125;&#125;; 今日吐槽：在实验室的电脑写了题，家里的电脑登陆力扣并没有通过的代码，说明存本地了；早早下班，昨天11点40睡上午虽然没反应，下午2点多到3点直接困倒在桌上，下班早可以运动运动 修改_partial 下边的 articl.ejs可以修改文章页面内容 var ap = new APlayer({ element: document.getElementById(\"aplayer-YjQQTYEz\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-yMfLTCPJ\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"测试曲目\", author: \"lol\", url: \"test.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); {方法二，直接使用网易云音乐：% meting “972904675” “netease” “playlist”“autoplay “ “mutex:false” 先打断施法”listmaxheight:340px” “preload:none” “theme:#ad7a86”%} me打断施法，使用网易云的单曲也行ting “31654455” “ne打断tease” “song” “preload:auto” 这个行 ![tes t](/im age/av atar.jpg) hexo如何使用本地资源，以及放置路径 参考博客参考博客","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"音频添加","slug":"音频添加","permalink":"http://spcablast.club/tags/%E9%9F%B3%E9%A2%91%E6%B7%BB%E5%8A%A0/"}],"author":"YP"},{"title":"Dailycode","slug":"20211222","date":"2021-12-21T16:00:00.000Z","updated":"2021-12-27T12:20:10.007Z","comments":true,"path":"2021/12/22/20211222/","link":"","permalink":"http://spcablast.club/2021/12/22/20211222/","excerpt":"","text":"###687. 最长同值路径给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5输出: 2 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int ans; int dfs(TreeNode* root)&#123;//直接dfs，左子树最长的和右子树哪个长，取长的，返回//靠，这题也挺难 if(!root)return 0; int l = dfs(root-&gt;left), r = dfs(root-&gt;right); int lp = (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) ? l : 0; int rp = (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == root-&gt;val) ? r : 0; ans = max(ans, lp + rp); return max(lp, rp) + 1; &#125; int longestUnivaluePath(TreeNode* root) &#123; ans = 0; dfs(root); return ans; &#125;&#125;; ###349. 两个数组的交集给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); vector&lt;int&gt; ans; int i = 0, j = 0; while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())&#123; if(nums1[i] &lt; nums2[j])&#123;//1&lt;2,外层走 i++; &#125; else if(nums1[i] == nums2[j])&#123;//1==2，一起走 if (!ans.size() || nums2[j] != ans.back()) &#123; ans.push_back(nums2[j]); &#125; i++; j++; &#125; else&#123;//1&gt;2,j自己走 j++;//continue; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20211221","date":"2021-12-20T16:00:00.000Z","updated":"2021-12-27T12:20:24.944Z","comments":true,"path":"2021/12/21/20211221/","link":"","permalink":"http://spcablast.club/2021/12/21/20211221/","excerpt":"","text":"一年中的第几天给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。 示例 1： 输入：date = “2019-01-09”输出：9 123456789101112131415161718192021222324252627class Solution &#123;public: int dayOfYear(string date) &#123; vector&lt;int&gt; dateofyear; int ans = 0; string temp = \"\"; for(int i = 0; i &lt; date.size(); ++i)&#123; if(date[i] != '-')&#123; temp.push_back(date[i]); &#125; else&#123; dateofyear.push_back(atoi(temp.c_str())); temp = \"\"; &#125; &#125; dateofyear.push_back(atoi(temp.c_str())); int month[12] = &#123;31, 28 ,31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; //好了，年月日已经有了，接下来就是判断闰月了 if((dateofyear[0] % 400 == 0) || (dateofyear[0] % 4 == 0 &amp;&amp; dateofyear[0] % 100 !=0))&#123;//闰月再判断是否2月 month[1]++; &#125; for(int i = 0; i &lt; dateofyear[1] - 1; ++i)&#123; ans+=month[i]; &#125; return ans + dateofyear[2]; &#125;&#125;; 掷骰子的N种方法这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。 我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。 如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。 示例 1： 输入：d = 1, f = 6, target = 3输出：1 12345678910111213141516171819202122232425262728class Solution &#123;public: int numRollsToTarget(int n, int k, int target) &#123; //我靠，就是给你一个数，看d个0到f的数有几种组合加起来会等于这个数 //动 态 规 划 //dp[i][j] 扔i个骰子和为j和dp[i-1][j]的关系？没啥关系，和dp[i-1][j-1]有关系吧 // int dp[n+1][target+1]; memset(dp, 0, sizeof(dp)); int base = 1000000007; for (int i = 1; i &lt;= min(k, target); ++i) &#123; dp[1][i] = 1; &#125; for (int i = 2; i &lt;= n; ++i) &#123; // 最小是i（骰子最小是1） for (int j = i; j &lt;= min(n*k, target); ++j) &#123; for (int l = 1; l &lt;= k &amp;&amp; j - l &gt;= 0; ++l) &#123; dp[i][j] = (dp[i][j] + dp[i-1][j-l]) % base; &#125; &#125; &#125; return dp[n][target]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211220","date":"2021-12-19T16:00:00.000Z","updated":"2021-12-20T12:47:21.811Z","comments":true,"path":"2021/12/20/20211220/","link":"","permalink":"http://spcablast.club/2021/12/20/20211220/","excerpt":"","text":"###475. 供暖器冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 在加热器的加热半径范围内的每个房屋都可以获得供暖。 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1: 输入: houses = [1,2,3], heaters = [2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123; //找两个热水器间隔最远是多少是不是就行了， //如果只有一个热水器，那就长度 // int left = 0, right = 0; // for(int i = 0; i &lt; heaters.size(); ++i)&#123; // right = max(heaters[i] - left, right); // left = heaters[i]; // &#125; // right = max(right, (houses[houses.size()-1] - heaters[heaters.size() -1]));//最后一个房子位置减去最后一个热水器位置 // right -= 1; // return right%2 == 0?right/2:(right+1)/2; //如果能用一个houses这么大的映射，存下每一个house里的离得最近的热水器的距离，最后去这些距离里面最大的，那这不就是要的半径的两倍嘛。 int _max = INT_MIN, _min = 0, j = 0; sort(houses.begin(), houses.end()); sort(heaters.begin(), heaters.end()); for(int i = 0; i &lt; houses.size(); ++i)&#123; _min = abs(heaters[j] - houses[i]); //if(_min &gt; 0) return j; for(;j &lt;heaters.size() - 1; ++j)&#123; if(abs(heaters[j+1] - houses[i]) &lt; _min)&#123; _min = min(abs(heaters[j+1] - houses[i]), _min);//得到每个房子到热水器最近距离 &#125; else break; &#125; _max = max(_max, _min); //在最近距离里取最大 &#125; return _max; // sort(houses.begin(), houses.end()); // sort(heaters.begin(), heaters.end()); // int ans = 0; // for (int i = 0, j = 0; i &lt; houses.size(); i++) &#123; // int curDistance = abs(houses[i] - heaters[j]); // while (j &lt; heaters.size() - 1 &amp;&amp; abs(houses[i] - heaters[j]) &gt;= abs(houses[i] - heaters[j + 1])) &#123; // j++; // curDistance = min(curDistance, abs(houses[i] - heaters[j])); // &#125; // ans = max(ans, curDistance); // &#125; // return ans; &#125;&#125;; ###594. 最长和谐子序列和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 示例 1： 输入：nums = [1,3,2,2,5,2,3,7]输出：5解释：最长的和谐子序列是 [3,2,2,2,3] 12345678910111213141516class Solution &#123;public: int findLHS(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; cnt; int ans = 0; for (int num : nums) &#123; cnt[num]++; &#125; for (auto [key, val] : cnt) &#123; if (cnt.count(key + 1)) &#123;//如果有比这个数大1的 ans = max(ans, val + cnt[key + 1]); &#125; &#125; return res; &#125;&#125;; 今日吐槽：我今天早点睡明天会充满power吧，会吧？","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211219","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-19T12:38:45.367Z","comments":true,"path":"2021/12/19/20211219/","link":"","permalink":"http://spcablast.club/2021/12/19/20211219/","excerpt":"","text":"###9. 回文数给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(int x) &#123; //如果直接转字符串，取反，转整数，是不是直接就有了 if(x&lt;0) return false; if(x ==0 )return true; vector&lt;int&gt; list; while(x&gt;0)&#123; list.push_back(x%10); x/=10; &#125; int left = 0, right = list.size() -1; while(left&lt;=right)&#123; if(list[left] != list[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125;; ###1814. 统计一个数组中好对子的数目给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ： 0 &lt;= i &lt; j &lt; nums.lengthnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。 示例 1： 输入：nums = [42,11,1,97]输出：2解释：两个坐标对为： (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int rev(int num)&#123; int ans = 0; while(num)&#123; ans = ans*10 + num%10; num /= 10; &#125; return ans; &#125; // int countNicePairs(vector&lt;int&gt;&amp; nums) &#123; // //那不就是num[i] - revnum[i] = num[j] - revnum[j] // //新建一个数组，把所有的存起来， // //只需要写一个rev函数 // long ans = 0; // for(int i = 0; i &lt; nums.size(); ++i)&#123; // nums[i] -= rev(nums[i]); // &#125; // for(int i = 0;i&lt;nums.size();++i)&#123; // for(int j = i+1;j&lt;nums.size();++j)&#123; // if(nums[j] == nums[i])&#123; // ans++; // ans = ans%(1000000007); // &#125; // &#125; // &#125; // return ans; // &#125; //超时了，超时了就用哈希表呗 int countNicePairs(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; mp; int ans = 0; for(int i=0; i&lt;nums.size(); i++)&#123; int re = rev(nums[i]); ans = (ans + mp[nums[i] - re]) % 1000000007; mp[nums[i] - re]++; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211218","date":"2021-12-17T16:00:00.000Z","updated":"2021-12-18T02:10:33.509Z","comments":true,"path":"2021/12/18/20211218/","link":"","permalink":"http://spcablast.club/2021/12/18/20211218/","excerpt":"","text":"###419. 甲板上的战舰给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。 战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。 1234567891011121314151617181920212223242526class Solution &#123;public: int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; //这题是检查有几行或者几列有超过2个X的嘛 //o，不是，是一个战舰至少在同一行或同一列占2格，数有多少个战舰 //那我只要统计每一行和每一列的，左边没有X，上边没有X的X的个数，就是答案 //硬算的话，只需要把一个X后边的或者下边的X干掉，就不会干扰到下一个的计算 int row = board.size(); int col = board[0].size(); int ans = 0; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (board[i][j] == 'X') &#123; if (i &gt; 0 &amp;&amp; board[i - 1][j] == 'X') &#123; continue; &#125; if (j &gt; 0 &amp;&amp; board[i][j - 1] == 'X') &#123; continue; &#125; ans++; &#125; &#125; &#125; return ans; &#125;&#125;; ###434. 字符串中的单词数统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: “Hello, my name is John”输出: 5解释: 这里的单词是指连续的不是空格的字符，所以 “Hello,” 算作 1 个单词。 12345678910111213class Solution &#123;public: int countSegments(string s) &#123; if(!s.size()) return 0; int ans = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if ((i == 0 || s[i - 1] == ' ') &amp;&amp; s[i] != ' ') &#123; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211216","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-27T12:20:54.952Z","comments":true,"path":"2021/12/16/20211216/","link":"","permalink":"http://spcablast.club/2021/12/16/20211216/","excerpt":"","text":"###94. 二叉树的中序遍历给定一个二叉树的根节点 root ，返回它的 中序 遍历。 //让我想起了以前上课的时候 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void lfd(TreeNode* root)&#123; if(!root) return; lfd(root-&gt;left); ans.push_back(root-&gt;val); lfd(root-&gt;right); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //中序遍历 //左，中，右 lfd(root); return ans; &#125;private: vector&lt;int&gt; ans;&#125;; ###95. 不同的二叉搜索树 II给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 示例 1： 输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public://不会，这递归可太妙了//首先挨个遍历，//每一个进行一个什么操作，每一个根节点进行一个递归，进行一个对他所有子节点作为根节点的递归//好像乱了，就是把每个值都当作一个根节点，把所有左子树，右子树列出来，拼成一个树，存到答案里 vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123; if (start &gt; end) &#123; return &#123; nullptr &#125;; &#125; vector&lt;TreeNode*&gt; allTrees; // 枚举可行根节点 for (int i = start; i &lt;= end; i++) &#123; // 获得所有可行的左子树集合 vector&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - 1); // 获得所有可行的右子树集合 vector&lt;TreeNode*&gt; rightTrees = generateTrees(i + 1, end); // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上 for (auto&amp; left : leftTrees) &#123; for (auto&amp; right : rightTrees) &#123; TreeNode* currTree = new TreeNode(i); currTree-&gt;left = left; currTree-&gt;right = right; allTrees.emplace_back(currTree); &#125; &#125; &#125; return allTrees; &#125; vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (!n) &#123; return &#123;&#125;; &#125; return generateTrees(1, n); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211215","date":"2021-12-14T16:00:00.000Z","updated":"2021-12-27T12:21:08.426Z","comments":true,"path":"2021/12/15/20211215/","link":"","permalink":"http://spcablast.club/2021/12/15/20211215/","excerpt":"","text":"###851. 喧闹和富有有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 “person x “。 给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。 示例 1： 输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]输出：[5,5,2,5,4,5,6,7]解释：answer[0] = 5，person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，但是目前还不清楚他是否比 person 0 更有钱。answer[7] = 7，在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），最安静（有较低安静值 quiet[x]）的人是 person 7。其他的答案也可以用类似的推理来解释。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;int&gt; loudAndRich(vector&lt;vector&lt;int&gt;&gt;&amp; richer, vector&lt;int&gt;&amp; quiet) &#123; //这题的意思是给你一个人x，返回比他有钱的所有人中quiet值最小的人的号 //这看起来像图的题啊，每个人挂一个链表，后边接所有比他有钱的人，就解决了，但是是不是浪费空间 //欸，那我给按所有人的有钱等级排个序，就有了，排了， //哦~我懂了，我需要一个map，没过一个pair，就把比这个人有钱的quiet值和存了的比一下 //奥，不需要pair，只需要一个n位的数组，每经过一个pair就更新比这个人有钱的人的quiet // int n = richer.size(); // vector&lt;int&gt; ans(n,INT_MAX); // for(int i = 0; i &lt; n; ++i)&#123; // int num = quiet[richer[i][1]]; // if(ans[richer[i][0]] &gt; num)&#123; // ans[richer[i][0]] = num; // &#125; // &#125; // return ans; //阅读理解失败，有钱是连环的，还是得用链表或者图 int n = quiet.size(); vector&lt;vector&lt;int&gt;&gt; g(n); for (auto &amp;r : richer) &#123; g[r[1]].emplace_back(r[0]);//整了个类似链表的vector，也行，用一行存所有比这个人有钱的人 &#125; vector&lt;int&gt; ans(n, -1); function&lt;void(int)&gt; dfs = [&amp;](int x) &#123;//啊（二声），写的什么东西 if (ans[x] != -1) &#123; return; &#125; ans[x] = x; for (int y : g[x]) &#123;//从第一个比这个人有钱的开始 dfs(y);//找其他比，比他有钱的人有钱的 if (quiet[ans[y]] &lt; quiet[ans[x]]) &#123; ans[x] = ans[y]; &#125; &#125; &#125;; for (int i = 0; i &lt; n; ++i) &#123; dfs(i); &#125; return ans; &#125;&#125;; ###563. 二叉树的坡度给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度就是其所有节点的坡度之和。 示例 1： 输入：root = [1,2,3]输出：1解释：节点 2 的坡度：|0-0| = 0（没有子节点）节点 3 的坡度：|0-0| = 0（没有子节点）节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）坡度总和：0 + 0 + 1 = 1示例 2： 输入：root = [4,2,9,3,5,null,7]输出：15解释：节点 3 的坡度：|0-0| = 0（没有子节点）节点 5 的坡度：|0-0| = 0（没有子节点）节点 7 的坡度：|0-0| = 0（没有子节点）节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 1234567891011121314151617181920212223242526272829&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: &#x2F;&#x2F;说实话，就是计算两棵树的节点和再减一下，再递归一下 int ans &#x3D; 0; int findTilt(TreeNode* root) &#123; dfs(root); return ans; &#125; int dfs(TreeNode* node) &#123; if (node &#x3D;&#x3D; nullptr) &#123; return 0; &#125; int sumLeft &#x3D; dfs(node-&gt;left);&#x2F;&#x2F;左子树的和 int sumRight &#x3D; dfs(node-&gt;right);&#x2F;&#x2F;右子数的和 ans +&#x3D; abs(sumLeft - sumRight);&#x2F;&#x2F;每个节点的坡度累加 return sumLeft + sumRight + node-&gt;val;&#x2F;&#x2F;返回整棵树的节点和 &#125; &#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211214","date":"2021-12-13T16:00:00.000Z","updated":"2021-12-27T12:21:17.659Z","comments":true,"path":"2021/12/14/20211214/","link":"","permalink":"http://spcablast.club/2021/12/14/20211214/","excerpt":"","text":"###931. 下降路径最小和给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。 下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。 示例 1： 输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]输出：13解释：下面是两条和最小的下降路径，用加粗+斜体标注：[[2,1,3], [[2,1,3], [6,5,4], [6,5,4], [7,8,9]] [7,8,9]] 1234567891011121314151617181920212223class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; //下降路径，第一行挑最小，但是第一行每个都作为起点 //best = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1]) int N = matrix.size(); for (int r = N-2; r &gt;= 0; --r) &#123;//从倒数第二行开始 for (int c = 0; c &lt; N; ++c) &#123; int best = matrix[r+1][c]; if (c &gt; 0) best = min(best, matrix[r+1][c-1]); if (c+1 &lt; N) best = min(best, matrix[r+1][c+1]); matrix[r][c] += best; &#125; &#125; int ans = INT_MAX; for (int x: matrix[0]) ans = min(ans, x); return ans; &#125;&#125;; ###933. 最近的请求次数写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：[“RecentCounter”, “ping”, “ping”, “ping”, “ping”][[], [1], [100], [3001], [3002]]输出：[null, 1, 2, 3, 3] 解释：RecentCounter recentCounter = new RecentCounter();recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2recentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3recentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3 12345678910111213141516class RecentCounter &#123;private: queue&lt;int&gt; q;//队列存time，是不是可以直接用数组，数组不如vector，vector不如队列，public: RecentCounter() &#123;&#125; int ping(int t) &#123; q.push(t); while (t - q.front() &gt; 3000) q.pop(); //若时间太早，则循环出队 return q.size(); //最后返回队列长度，即最近3000ms的请求次数 &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211213","date":"2021-12-12T16:00:00.000Z","updated":"2021-12-27T12:21:27.008Z","comments":true,"path":"2021/12/13/20211213/","link":"","permalink":"http://spcablast.club/2021/12/13/20211213/","excerpt":"","text":"###807. 保持城市天际线给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。 城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。 我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。 在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //这题的意思就是填格子吧，每个格子可以补充到行列最大值里小的那个 //所以需要获取每行和每列的最大值 //遍历两遍行了，第一遍存行加列减一个最大值， //第二遍累加/我只要算每一行每一列的总和，存起来，就不用累加了//没用，别存了 if(grid.size()==0) return 0; int col = 0, row = 0, ans = 0; vector&lt;int&gt; rowmax(grid.size(),0); vector&lt;int&gt; colmax(grid[0].size(),0); row = grid.size(); col = grid[0].size(); for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; rowmax[i] = grid[i][j]&gt;rowmax[i]?grid[i][j]:rowmax[i]; &#125; &#125; for(int i = 0; i&lt;col; ++i)&#123; for(int j = 0; j&lt;row; ++j)&#123; colmax[i] = grid[j][i]&gt;colmax[i]?grid[j][i]:colmax[i]; &#125; &#125; for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; int maxnum = min(rowmax[i], colmax[j]); if(maxnum - grid[i][j] &gt;=0)&#123; ans +=maxnum - grid[i][j]; &#125; &#125; &#125; return ans; &#125;&#125;; ###剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。例如:给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果： [ [3], [9,20], [15,7]] 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; //层次遍历，返回条件是啥嘞 vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; points;//队列存每层根节点 points.push(root); while(points.size())&#123; int col=points.size();//当前层有几个节点 vector&lt;int&gt; ans1;//存当前层数据 for(int i=0;i&lt;col;i++)&#123;//根据数量从队列里取相应的节点 TreeNode *temp=points.front(); points.pop(); ans1.push_back(temp-&gt;val); if(temp-&gt;left) points.push(temp-&gt;left); if(temp-&gt;right) points.push(temp-&gt;right); &#125; ans.push_back(ans1); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"二叉树 - 算法题","slug":"二叉树-算法题","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211212","date":"2021-12-11T16:00:00.000Z","updated":"2021-12-12T12:08:37.754Z","comments":true,"path":"2021/12/12/20211212/","link":"","permalink":"http://spcablast.club/2021/12/12/20211212/","excerpt":"","text":"转换成小写字母给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。 示例 1： 输入：s = “Hello”输出：”hello” 123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(int i&#x3D;0;i&lt;s.size();++i)&#123; s[i] &#x3D; tolower(s[i]); &#125; return s; &#125;&#125;; ###421. 数组中两个数的最大异或值给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。 进阶：你可以在 O(n) 的时间解决这个问题吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; //找异或值最大的俩，就是要1最多，两个数异或等于1，就是同位相等，就着最大值怎么样，拿着最大值和其他的数来 //所以要不要转成2进制 //首先看谁的1111111111，前面的1位置远，然后 //动态规划行吗，存当前最大的值 //1个的时候是自己，2个的时候也是，三个的时候分别用两个数和第三个数异或，然后挑大的，这样又只剩下两个数了，再第四位，好像行 // int left = 0,right = 0, ans=0; // if(nums.size() == 0) return 0; // if(nums.size() == 1) return nums[0]; // if(nums.size() == 2) return nums[0]^nums[1]; // for(int i = 0;i&lt;nums.size();++i)&#123; // if((left ^ nums[i]) &gt; ans)&#123; // right = nums[i]; // ans = left ^ right; // &#125; // else if((right ^ nums[i]) &gt; ans)&#123; // left = nums[i]; // ans = left ^ right; // &#125; // ans = left ^ right; // &#125; // return ans; //那我只能说，康康题解，这题怎么可能On的，啊，翻译翻译，什么叫On int x = 0; for (int k = HIGH_BIT; k &gt;= 0; --k) &#123; unordered_set&lt;int&gt; seen; // 将所有的 pre^k(a_j) 放入哈希表中 for (int num: nums) &#123; // 如果只想保留从最高位开始到第 k 个二进制位为止的部分 // 只需将其右移 k 位 seen.insert(num &gt;&gt; k); &#125; // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分 // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1 int x_next = x * 2 + 1; bool found = false; // 枚举 i for (int num: nums) &#123; if (seen.count(x_next ^ (num &gt;&gt; k))) &#123; found = true; break; &#125; &#125; if (found) &#123; x = x_next; &#125; else &#123; // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0 // 即为 x = x*2 x = x_next - 1; &#125; &#125; return x; &#125;private: // 最高位的二进制位编号为 30 static constexpr int HIGH_BIT = 30;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110_","date":"2021-12-09T16:00:00.000Z","updated":"2021-12-10T12:17:52.091Z","comments":true,"path":"2021/12/10/20211110_/","link":"","permalink":"http://spcablast.club/2021/12/10/20211110_/","excerpt":"","text":"###24. 两两交换链表中的节点给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ // 1 2 3 4 5 6 7 // 2 1 3 4 5 6 7 // 2 1 4 3 6 5 7class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head) return head; if(!head-&gt;next) return head; int cnt = 0; ListNode* pre = head; ListNode* cur = head-&gt;next; ListNode* ini = new ListNode(0); ListNode* temp = ini; temp-&gt;next = head; while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;next)&#123;//从头开始，只需要把第一个指到第二个的next，第二个指到第一个就行了，然后两个指针都向前两步， pre = temp-&gt;next; cur = temp-&gt;next-&gt;next; temp-&gt;next = cur; pre-&gt;next = cur-&gt;next; cur-&gt;next = pre; temp = pre; &#125; return ini-&gt;next; &#125;&#125;; ###剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：2 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: //1 //1 2 //1 2 +1 //1 2 // int fib(int n)&#123; // if(n == 0) return 1; // else if(n == 1) return 1; // else // return (fib(n-1) + fib(n-2))%1000000007; // &#125; // int numWays(int n) &#123;//跳3级台阶，等于1级和2级台阶的数量加起来 // if(n == 0) return 1; // if(n ==1) return 1; // return (fib(n))%1000000007; // &#125; int numWays(int n) &#123;//递归44就超时了，迭代1000000000也超时了 if (n &lt;= 1) &#123; return 1; &#125; int a = 1; int b = 2; for (int i = 2; i &lt; n; i++) &#123; int temp = (a + b); a = b; b = temp; b %= 1000000007; &#125; return b; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211209","date":"2021-12-08T16:00:00.000Z","updated":"2021-12-09T13:36:18.523Z","comments":true,"path":"2021/12/09/20211209/","link":"","permalink":"http://spcablast.club/2021/12/09/20211209/","excerpt":"","text":"###766. 托普利茨矩阵给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 12345678910111213141516171819class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size() == 1) return true; if(matrix[0].size() ==1 )return true; //if(matrix.size() == 2) return matrix[0][0] == matrix[1][1]; //用一行存第一行 //和下一行比 //更新第一行 for(int i = 1; i&lt;=matrix.size() -1; ++i)&#123; for(int j = 0; j&lt; matrix[0].size() -1; j++)&#123; if(!(matrix[i-1][j] == matrix[i][j+1]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; ###150. 逆波兰表达式求值根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [“2”,”1”,”+”,”3”,”*”]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: // int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; // //数字入栈，符号运算，弹出结果 // stack&lt;int&gt; stac; // for(int i =0;i&lt;tokens.size();++i)&#123; // string&amp; get = tokens[i]; // //判断数字还是符号 // if(get[0] -'+' != 0 &amp;&amp; get[0]-'-'!=0 &amp;&amp;get[0]-'*'!=0&amp;&amp;get[0]-'/'!=0)&#123; // stac.push(atoi(get[i].c_str())); // &#125; // else&#123; // int num1 = stac.top(); // stac.pop(); // int num2 = stac.top(); // stac.pop(); // switch(get[0])&#123; // case '+': // stac.push(num2 + num1); // break; // case '-': // stac.push(num2 - num1); // break; // case '*': // stac.push(num2 * num1); // break; // case '/': // stac.push(num2 / num1); // break; // &#125; // &#125; // &#125; // return stac.top(); // &#125; int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; stk; int n = tokens.size(); for (int i = 0; i &lt; n; i++) &#123; string&amp; token = tokens[i]; if (isNumber(token)) &#123; stk.push(atoi(token.c_str())); &#125; else &#123; int num2 = stk.top(); stk.pop(); int num1 = stk.top(); stk.pop(); switch (token[0]) &#123; case '+': stk.push(num1 + num2); break; case '-': stk.push(num1 - num2); break; case '*': stk.push(num1 * num2); break; case '/': stk.push(num1 / num2); break; &#125; &#125; &#125; return stk.top(); &#125; bool isNumber(string&amp; token) &#123; return !(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\"); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211208","date":"2021-12-07T16:00:00.000Z","updated":"2021-12-08T12:17:49.975Z","comments":true,"path":"2021/12/08/20211208/","link":"","permalink":"http://spcablast.club/2021/12/08/20211208/","excerpt":"","text":"###35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 123456789101112131415161718class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() -1, ans = nums.size(); while(left &lt;= right)&#123; if(target == nums[(left+right)/2] )&#123; return (left+right)/2; &#125; else if(target &lt; nums[(left+right)/2])&#123; ans = (left+right)/2; right = (left+right)/2-1; &#125; else if(target &gt; nums[(left+right)/2]) left = (left+right)/2+1; &#125; return ans; &#125;&#125;; ###1509. 三次操作后最大值与最小值的最小差给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。 请你返回三次操作后， nums 中最大值与最小值的差的最小值。 示例 1： 输入：nums = [5,3,2,4]输出：0解释：将数组 [5,3,2,4] 变成 [2,2,2,2].最大值与最小值的差为 2-2 = 0 。 123456789101112131415161718class Solution &#123;public: int minDifference(vector&lt;int&gt;&amp; nums) &#123; //找最大和第二大的， //找最小和第二小的， //最大的减，嘴小的加，看哪个合适 //结果就是，找最大的四个数，最小的四个数，一共能删除三个数，删除3个最大，第四大减去最小，删除2个最大，一个最小 if(nums.size() &lt;= 4)&#123; return 0; &#125; int ret = INT_MAX; sort(nums.begin(),nums.end()); for(int i = 0; i&lt;4; ++i)&#123; ret = min(ret, (nums[nums.size()-i -1] - nums[3-i])); &#125; return ret; &#125; &#125;; 今日吐槽：“时间”这个名词是时间的外显嘛，本没有时间，只有事物状态的变化，是嘛，将事物状态变化的速度来一个量化的单位，就是时间了。衡量单位出现的作用是什么呢？","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211207","date":"2021-12-06T16:00:00.000Z","updated":"2021-12-07T12:17:12.578Z","comments":true,"path":"2021/12/07/20211207/","link":"","permalink":"http://spcablast.club/2021/12/07/20211207/","excerpt":"","text":"###1844. 将所有数字用字符替换给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。 定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。 比方说，shift(‘a’, 5) = ‘f’ 和 shift(‘x’, 0) = ‘x’ 。对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。 请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 ‘z’ 。 1234567891011class Solution &#123;public: string replaceDigits(string s) &#123; for(int i = 0; i&lt; s.size();++i)&#123; if(i%2==1)&#123; s[i] = (s[i-1] - 'a' + (s[i] - '0'))%32 + 'a'; &#125; &#125; return s; &#125;&#125;; ###剑指 Offer II 026. 重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; //除了用一个指针指到末尾去，然后一边取一个存到新的里边 //奥，还可以从末尾拿一个过来，插到每一个的后边，直到取完，这样就省了新空间 //坏了，每次都得从头过去取吗，不从头过去取难道用一个空间存，、 //是不是可以截断成两个，然后倒插，怎么倒插呢 为了省时间还可以截断成log2 n个部分，存这么点节点，遍历的时间就省了 vector&lt;ListNode *&gt; list; while(head-&gt;next)&#123; list.push_back(head); head = head-&gt;next; &#125; list.push_back(head); int left = 0, right = list.size() - 1; while(left &lt; right)&#123; list[left]-&gt;next = list[right]; left++; if(left == right) break; list[right]-&gt;next = list[left]; right--; &#125; list[left]-&gt;next = nullptr; &#125;&#125;; 今日吐槽：刚刚坐在实验室突然感觉力气逐渐消失，还特别累，逐渐变困，感觉哪里不对，一想，原来是考完试回来忘了吃晚饭，大家注意吃饭","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211105","date":"2021-12-04T16:00:00.000Z","updated":"2021-12-05T12:08:35.984Z","comments":true,"path":"2021/12/05/20211105/","link":"","permalink":"http://spcablast.club/2021/12/05/20211105/","excerpt":"","text":"###139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。 示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 123456789101112131415161718192021class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; //判断首字母有几个匹配的，一个一个比较，没有一个相等就说明可以返回false了 auto wordDictSet = unordered_set &lt;string&gt; (); for (auto word: wordDict) &#123;//把字典里的都存起来 wordDictSet.insert(word); &#125; auto dp = vector &lt;bool&gt; (s.size() + 1);//每一位存0位到当前位是否是能拆 dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123;//如果从j开始，到i结束这段能在字典里找到，且到j这段也能拆，那么就说明到i这段能拆 if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; ###627. 变更性别SQL架构Salary 表： +————-+———-+| Column Name | Type |+————-+———-+| id | int || name | varchar || sex | ENUM || salary | int |+————-+———-+id 是这个表的主键。sex 这一列的值是 ENUM 类型，只能从 (‘m’, ‘f’) 中取。本表包含公司雇员的信息。 请你编写一个 SQL 查询来交换所有的 ‘f’ 和 ‘m’ （即，将所有 ‘f’ 变为 ‘m’ ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。 注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。 12345678// Write your MySQL query statement belowUPDATE salarySET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END;//还有数据库的题，神秘，这是什么操作，如果是m设置成f，否则设置成m","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"SQL - 算法题","slug":"SQL-算法题","permalink":"http://spcablast.club/tags/SQL-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211204","date":"2021-12-03T16:00:00.000Z","updated":"2021-12-04T01:31:29.021Z","comments":true,"path":"2021/12/04/20211204/","link":"","permalink":"http://spcablast.club/2021/12/04/20211204/","excerpt":"","text":"###121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //我只需要将当前值减去过去最小的，比一比，就行了 int cur = 0, min = INT_MAX, max = INT_MIN, index = 0; cur = prices[0]; for(int i = 0; i &lt; prices.size(); ++i)&#123; cur = prices[i]; if(min &gt; prices[i])&#123; min = prices[i]; &#125; if(max &lt; cur - min)&#123; max = cur - min; index = i; &#125; &#125; return max&gt;0?max:0; &#125;&#125;; ###413. 等差数列划分如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4]输出：3解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。示例 2： 输入：nums = [1]输出：0 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; //神秘，我需要判断出来当前是不是等差，如果是，在哪儿停止，下一个开始又计数 //一通操作算出来了有几个 if(nums.size()&lt;3)&#123; return 0; &#125; int pre = INT_MIN, ppre, cur,cnt = 0, t = 0; pre = nums[1] - nums[0]; cur = nums[2] - nums[1]; bool last = false; for(int i =2; i&lt; nums.size();++i)&#123; cur = nums[i] - nums[i-1]; if(pre != cur)&#123;//说明上一个和这一个不相等,不在一个等差数列 t = 0; last = false; &#125; else &#123; t++; last = true; &#125; if((!last) &amp;&amp; (pre == cur))&#123;//如果上一个pre不等于cur但是这一个pre等于cur，说明进入一个等差数列 //cnt++; &#125; pre = cur; cnt += t;//先找到有几个等差数列，再算每个等差数列里面有几个等差数列，好优化 &#125; return cnt; &#125;&#125;; 今日吐槽：早睡早起身体好，食堂的辣白菜可太好吃了，今天又是不想营业的一天，该干活了。动态规划，不对劲，这题不对劲","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211202","date":"2021-12-01T16:00:00.000Z","updated":"2021-12-02T11:53:11.813Z","comments":true,"path":"2021/12/02/20211202/","link":"","permalink":"http://spcablast.club/2021/12/02/20211202/","excerpt":"","text":"###152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 1234567891011121314151617181920212223class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; // //这题是不是跟昨天的一样 // int maxMul = INT_MIN, pre = 1, cur = 0; // for(int num : nums)&#123; // cur = pre*num; // maxMul = max(maxMul,cur); // if(cur = 0) pre = 1; // else pre = cur; // &#125; // return maxMul; //事实告诉我不是，因为还能-2*-2 = 4，小加小等于大 int maxF = nums[0], minF = nums[0], ans = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; int mx = maxF, mn = minF; maxF = max(mx * nums[i], max(nums[i], mn * nums[i])); minF = min(mn * nums[i], min(nums[i], mx * nums[i])); ans = max(maxF, ans); &#125; return ans; &#125;&#125;; ###278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 12345678910111213141516171819// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; long left = 1, right = n; while(left&lt;right)&#123; if(isBadVersion((left+right)/2))&#123; right = (left+right)/2; &#125; else&#123; left = (left+right)/2;//可以加一，因为这个位置已经判断过了 &#125; if(right==left+1) break; &#125; if(isBadVersion(left)) return left; return right; &#125;&#125;; 这波啊，这波是用空间换时间，直接来两个long int，不用跟他讲什么江湖道义，大家并肩子一起上，挺丑的，没有官方题解美观 今日吐槽：昨晚10点半就睡了，今天充满了power，虽然动态规划还是不太会，但是会写框架了呀，问题不大，在学了在学了还深度学习，学个der，令人头秃","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211201","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:23:56.226Z","comments":true,"path":"2021/12/01/20211201/","link":"","permalink":"http://spcablast.club/2021/12/01/20211201/","excerpt":"","text":"###53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2： 输入：nums = [1]输出：1示例 3： 输入：nums = [5,4,-1,7,8]输出：23 12345678910111213141516171819class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; //我知道了，把每一个位置的最大和存在一个数组里，遍历的时候把最大存在max里，最后返回 //优化一下就是把当前最大和上一个最大比较，大的更新，再下一步 //好像不对 //假如只有一个数，返回自身dp[0] = nums[1] //两个数，返回加来大还是本身大dp[1] = max(dp[0],num[1] + dp[0])，如果是dp[0]说明断了，且新来的这个数一定是负数，那么就得更新一下计数方式，下次计算从下一位开始 //三个数,if(更新)dp[2] = max(dp[1],num[2] + dp[1]) 或者 dp[2] = num[2] //也不对，用负数把数组分割一下，有道理，一个区域后边的负数比这个区域的正数负的少，就可以用 //变复杂了 int pre = 0, maxAns = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); maxAns = max(maxAns, pre); &#125; return maxAns; &#125;&#125;; 字典序排数给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]示例 2： 输入：n = 2输出：[1,2] 提示： 1 &lt;= n &lt;= 5 * 104 12345678910111213141516171819class Solution &#123;public: void dfs(int n, vector&lt;int&gt; &amp; ans, int num)&#123; if(num&gt;n) return; ans.push_back(num); for(int j = 0;j &lt;= 9;j++)&#123; dfs(n, ans, num*10+j); &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; //时间复杂度On，空间复杂度O1，啊这，字典序是什么序的 //1 10 11 ... 19 110 111...119 vector&lt;int&gt; ans; for(int i = 1; i&lt;10; i++)&#123; dfs(n, ans, i); &#125; return ans; &#125;&#125;; 今日吐槽：dfs，不会，动态规划还没学会呢，又给我dfs，但是dfs看起来没有动态规划难的亚子，爬，一递归就乱了，得整整递归","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"《黑羊》","slug":"黑羊-卡尔维诺","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:54:55.372Z","comments":true,"path":"2021/12/01/黑羊-卡尔维诺/","link":"","permalink":"http://spcablast.club/2021/12/01/%E9%BB%91%E7%BE%8A-%E5%8D%A1%E5%B0%94%E7%BB%B4%E8%AF%BA/","excerpt":"","text":"黑羊 卡尔维诺 从前有个国家，里面人人是贼。一到傍晚，他们手持万能钥匙和遮光灯笼出门，走到邻居家里行窃。破晓时分，他们提着偷来的东西回到家里，总能发现自己家也失窃了。 他们就这样幸福地居住在一起。没有不幸的人，因为每个人都从别人那里偷东西，别人又再从别人那里偷，依次下去，直到最后一个人去第一个窃贼家行窃。该国贸易也就不可避免地是买方和卖方的双向欺骗。政府是个向臣民行窃的犯罪机构，而臣民也仅对欺骗政府感兴趣。所以日子倒也平稳，没有富人和穷人。 有一天－－到底是怎么回事没人知道－－总之是有个诚实人到了该地定居。到晚上，他没有携袋提灯地出门，却呆在家里抽烟读小说。贼来了，见灯亮着，就没进去。 这样持续了有一段时间。后来他们感到有必要向他挑明一下，纵使他想什么都不做地过日子，可他没理由妨碍别人做事。他天天晚上呆在家里，这就意味着有一户人家第二天没了口粮。 诚实人感到他无力反抗这样的逻辑。从此他也像他们一样，晚上出门，次日早晨回家，但他不行窃。他是诚实的。对此，你是无能为力的。他走到远处的桥上，看河水打桥下流过。每次回家，他都会发现家里失窃了。 不到一星期，诚实人就发现自己已经一文不名了；他家徒四壁，没任何东西可吃。但这不能算不了什么，因为那是他自己的错；不，问题是他的行为使其他人很不安。因为他让别人偷走了他的一切却不从别人那儿偷任何东西；这样总有人在黎明回家时，发现家里没被动过－－那本该是由诚实人进去行窃的。不久以后，那些没有被偷过的人家发现他们比人家就富了，就不想再行窃了。更糟的是，那些跑到诚实人家里去行窃的人，总发现里面空空如也，因此他们就变穷了。 同时，富起来的那些人和诚实人一样，养成了晚上去桥上的习惯，他们也看河水打桥下流过。这样，事态就更混乱了，因为这意味着更多的人在变富，也有更多的人在变穷。 现在，那些富人发现，如果他们天天去桥上，他们很快也会变穷的。他们就想：“我们雇那些穷的去替我们行窃吧。”他们签下合同，敲定了工资和如何分成。自然，他们依然是贼，依然互相欺骗。但形势表明，富人是越来越富，穷人是越来越穷。 有些人富裕得已经根本无须亲自行窃或雇人行窃就可保持富有。但一旦他们停止行窃的话，他们就会变穷，因为穷人会偷他们。因此他们又雇了穷人中的最穷者来帮助他们看守财富，以免遭穷人行窃，这就意味着要建立警察局和监狱。 因此，在那诚实人出现后没几年，人们就不再谈什么偷盗或被偷盗了，而只说穷人和富人；但他们个个都还是贼。唯一诚实的只有开头的那个人，但他不久便死了，饿死的。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"http://spcablast.club/tags/%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4/"}],"author":"YP"},{"title":"Dailycode","slug":"20211130","date":"2021-11-29T16:00:00.000Z","updated":"2021-11-30T13:34:56.239Z","comments":true,"path":"2021/11/30/20211130/","link":"","permalink":"http://spcablast.club/2021/11/30/20211130/","excerpt":"","text":"删除并获得点数给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2]输出：6解释：删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int rob(vector&lt;int&gt; nums)&#123; int n = nums.size(); int first = nums[0], secend = max(first, nums[1]); for(int i = 2; i &lt; n; i++ )&#123; int temp = secend; secend = max(first + nums[i], secend); first = temp; &#125; return secend; &#125;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; //找最大，是最大大，还是最大减一 //一个返回自己 //两个返回最大，除非比他小一的乘起来比他大 //那这样就可以开一个哈希表，数字乘以出现次数，是这个数的值，a + c and b //取每个数，来个最大值 //假如取了第一个数，那么当前最大值存一下 //取第二个数，当前最大值存一下，是等于dp[0] + dp[1]还是dp[1]判断一下 //取第三个数，dp[0] + if dp[1] + dp[2] //取第四个数，dp[1] + if dp[2] + dp[3] //好，写 //先排序，再哈希，再dp if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int n = nums.size(), maxNum = 0; for(int i = 0;i &lt; n;++i)&#123; if(nums[i] &gt; maxNum)&#123; maxNum = nums[i]; &#125; &#125; vector&lt;int&gt; numNew(maxNum + 1); for(int num : nums)&#123; numNew[num] += num; &#125; return rob(numNew); &#125;&#125;; 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 示例 1： 输入：s = “()”输出：true 123456789101112131415161718192021222324class Solution &#123;public: bool isValid(string s) &#123; if(s.size() % 2 == 1) return false; //不成对，false stack&lt;char&gt; st; unordered_map&lt;char, char&gt; pairs = &#123; &#123;')','('&#125;, &#123;']','['&#125;, &#123;'&#125;','&#123;'&#125; &#125;; for(char ch : s)&#123; if(pairs.count(ch))&#123; if(st.empty() || st.top() != pairs[ch])&#123;//读到一个右括号，看是不是空，栈顶是不是对应的左括号 return false; &#125; st.pop();//没问题退栈 &#125; else&#123; st.push(ch);//否则压栈 &#125; &#125; return st.empty(); &#125;&#125;; 今日吐槽：歇了一天今天不困了，但是还需要中午补一点，该补一补了 感觉","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211129","date":"2021-11-28T16:00:00.000Z","updated":"2021-11-29T12:32:36.335Z","comments":true,"path":"2021/11/29/20211129/","link":"","permalink":"http://spcablast.club/2021/11/29/20211129/","excerpt":"","text":"剑指 Offer 62. 圆圈中最后剩下的数字0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3输出: 3示例 2： 输入: n = 10, m = 17输出: 2 12345678910111213class Solution &#123;public: int lastRemaining(int n, int m) &#123; //0 1 2 3 4 5 6 7 8 9 //每次往前计数，计到m，cnt--,再数m个，直到cnt==1，评论说这个方法超时了，呵，肤浅，超时，那就不用呗 //f，当前位置，m，每次向前移动位置，i是递归的初始状态 int f = 0; for (int i = 2; i != n + 1; ++i) &#123; f = (m + f) % i; &#125; return f; &#125;&#125;; 跳跃游戏 VII给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处： i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且s[j] == ‘0’.如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。 示例 1： 输入：s = “011010”, minJump = 2, maxJump = 3输出：true解释：第一步，从下标 0 移动到下标 3 。第二步，从下标 3 移动到下标 5 。 1234567891011121314151617181920212223242526class Solution &#123;public: bool canReach(string s, int minJump, int maxJump) &#123; //问题就在于 //每次前进minJump到maxJump距离，在其中找到几个下标为0的位置， //是否可以作为动态规划来解决，从终点往前，数i到j个格子，查里面有没有0，有就存起来 //问题在于我老想着优化的方法，只判断某些点可达不可达，而动态规划每个点都算了可达不可达存起来了 //每次走i步，和每次走j步，有一个区间，如果这个区间有0，说明能到对应的i int n = s.size(); vector&lt;int&gt; f(n), pre(n); f[0] = 1; // 由于我们从 i=minJump 开始动态规划，因此需要将 [0,minJump) 这部分的前缀和预处理出来 for (int i = 0; i &lt; minJump; ++i) &#123; pre[i] = 1; &#125; for (int i = minJump; i &lt; n; ++i) &#123; int left = i - maxJump, right = i - minJump; if (s[i] == '0') &#123; int total = pre[right] - (left &lt;= 0 ? 0 : pre[left - 1]); f[i] = (total != 0); &#125; pre[i] = pre[i - 1] + f[i]; &#125; return f[n - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211128","date":"2021-11-27T16:00:00.000Z","updated":"2021-11-28T14:17:17.108Z","comments":true,"path":"2021/11/28/20211128/","link":"","permalink":"http://spcablast.club/2021/11/28/20211128/","excerpt":"","text":"打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2： 输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// class Solution &#123;// public:// int rob(vector&lt;int&gt;&amp; nums) &#123;// //我应该从哪儿开始偷啊啊，gan// //真就能随便从一个位置开始吗// if(nums.size() == 0) return 0;// if(nums.size() == 1) return nums[0];// if(nums.size() == 2) return max(nums[0],nums[1]);// int ans0 = 0, ans1 = 0;// vector&lt;int&gt; dp[nums.size() + 1],dp2[nums.size() + 1];// //dp[i] = max(dp[i-2] + nums[i], dp[i-1] )// //分两种情况，从0开始和从1开始// dp[0] = nums[0], dp[1] = max(nums[0],nums[1]);// dp2[0] = nums[1], dp2[1] = max(nums[1],nums[2]);// for(int i = 2; i&lt;nums.size() -1; ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// for(int i = 3; i&lt;nums.size(); ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// return max(dp[nums.size()],dp2[nums.size()]);// &#125;// &#125;;class Solution &#123;public: int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int first = nums[start], second = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) &#123; int temp = second; second = max(first + nums[i], second); first = temp; &#125; return second; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 1) &#123; return nums[0]; &#125; else if (length == 2) &#123; return max(nums[0], nums[1]); &#125; return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); &#125;&#125;; 构造矩形作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 你设计的矩形页面必须等于给定的目标面积。 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。 长度 L 和宽度 W 之间的差距应当尽可能小。你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 输入: 4输出: [2, 2]解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 123456789101112class Solution &#123;public: vector&lt;int&gt; constructRectangle(int area) &#123; int w = 0,h = 0; w= sqrt(area); h = w; while(area % w)&#123; w--; &#125; return &#123;area / w, w&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211127","date":"2021-11-26T16:00:00.000Z","updated":"2021-11-27T15:35:32.455Z","comments":true,"path":"2021/11/27/20211127/","link":"","permalink":"http://spcablast.club/2021/11/27/20211127/","excerpt":"","text":"最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public:int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid)&#123; //好，我现在看什么都想动态规划，gan //假设我在最后一个格子了，那么比较到达左边需要的总数小还是上边的总数小 //感觉就像穷举，没错，就是了 if (!grid.size()) return 0; if (!grid[0].size()) return 0; int col = grid.size(), row = grid[0].size(); vector&lt;int&gt; dp(col * row); dp[0] = grid[0][0]; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; if (i * col + j != 0) &#123; //跳过0，0 if (i == 0) &#123; //第0列 if(j&gt;0) dp[i * row + j] = grid[0][j] + dp[i * row + j -1]; &#125; else if (j == 0) &#123; //第0列 dp[i * row + j] = grid[i][0] + dp[(i-1)*row]; &#125; else &#123; dp[i * row + j] = min(dp[(i - 1) * row + j] + grid[i][j], dp[i * row + j - 1] + grid[i][j]); &#125; &#125; &#125; &#125; return dp[col * row - 1]; &#125; ###7. 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; if(x == 0) return 0; int ans = 0,temp = 0; while(x!=0)&#123; temp = x%10; if( ans &lt;= INT_MAX/10 &amp;&amp; ans &gt;= INT_MIN/10) ans = ans*10 + temp; else return 0; x/=10; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211126","date":"2021-11-25T16:00:00.000Z","updated":"2021-11-26T13:56:01.063Z","comments":true,"path":"2021/11/26/20211126/","link":"","permalink":"http://spcablast.club/2021/11/26/20211126/","excerpt":"","text":"###746. 使用最小花费爬楼梯数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2： 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //用动态规划的思想来分析 //首先，如果只有一个台阶，那我就用这个， //如果有两个台阶，选小的那个 //如果有三个台阶，是否到达第三个台阶，判断从2跳过3大还是1到3大 //默认我已经站在某个台阶了，我只要判断是跳一步还是跳两步 // if(cost.size() == 0) return 0; // if(cost.size() == 1) return cost[0]; // int i = 1, r = 0, g = cost[0], b = cost[1], ans = 0, step = -1;//r是-1，g是中间， // while(i &lt; cost.size())&#123; // if(ans + cost[i-1] &gt; ans + cost[i])&#123;//0+cost[0] &gt; 0+cost[1] // i += 2; // ans += cost[i]; // &#125; // else // &#123; // i++; // ans += cost[i-1]; // &#125; // &#125; // return ans; //那我又倒了，再来一遍 int n = cost.size(); vector&lt;int&gt; dp(n + 1);//多了前置一位和后置一位 dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt; n+1;i++)&#123; dp[i] = min(cost[i-1] + dp[i-1], cost[i-2] + dp[i-2]); &#125; return dp[n]; &#125;&#125;; ###722. 删除注释给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 这表示每行源码由\\n分隔。 在 C++ 中有两种注释风格，行内注释和块注释。 字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。 字符串/* 表示一个块注释，它表示直到/的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串//并没有结束块注释，因为注释的结尾与开头相重叠。 第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。 同样，如果字符串/*出现在行或块注释中也会被忽略。 如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。 样例中没有控制字符，单引号或双引号字符。比如，source = “string s = “/* Not a comment. */“;” 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。） 我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。 最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。 从源代码中删除注释后，需要以相同的格式返回源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Solution &#123;public: // vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; // vector&lt;string&gt; ans, empty; // bool del = false; // string current = \"\"; // for(int i = 0; i&lt; source.size();i++)&#123; // //先判断有没有// // if(source[i].size()&gt;=2)&#123;//获得一个 // char former = source[i][0], cur = source[i][1]; // current.push_back(former);//先压一个 // for(int j = 1;j&lt;source[i].size();++j)&#123; // cur = source[i][j]; // former = source[i][j-1]; // if(former == '/'&amp;&amp;cur == '*')&#123;//标志位置1,后边不要 // current.pop_back();//吐出/ // del = true; // &#125; // else if(former == '*' &amp;&amp; cur == '/')&#123;//标志位置0，开始要 // current.pop_back();//吐出/ // del = false; // j++; // &#125; // else if(former == '/' &amp;&amp; cur =='/')&#123;//后边都不要 // break; // &#125; // else &#123; // current.push_back(cur); // if(del)&#123; // current.pop_back(); // &#125; // &#125; // //如果到头了，没有*/那就continue // //if((j == source[i].size()) &amp;&amp; del)&#123; // // continue; // //&#125; // &#125; // if(current.size() &amp;&amp; !del)&#123;//这行正常，或者这行string+ // ，或这行有*/ // ans.push_back(current);//这一行完了， // string().swap(current); // &#125; // &#125; // else&#123; // ans.push_back(source[i]); // //string().swap(current); // &#125; // &#125; // return ans; // &#125; vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; bool isComment = false; vector&lt;string&gt; res; string curr = \"\"; for (string s : source) &#123; // cout &lt;&lt; s &lt;&lt; endl; int i = 0; if (!isComment) &#123; curr = \"\"; &#125; int n = s.size(); while (i &lt; n) &#123; if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '*') &#123; isComment = true; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '*' &amp;&amp; s[i+1] == '/') &#123; isComment = false; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '/') &#123; break; &#125; else if (!isComment) &#123; curr += s[i]; // cout &lt;&lt; curr&lt;&lt; \" \" &lt;&lt; endl; &#125; ++i; &#125; if (!isComment &amp;&amp; !curr.empty()) &#123; res.push_back(curr); &#125; &#125; return res; &#125;&#125;; 吐槽：！他思路和我一样，代码也和我一样，我就过不去，啊我好菜啊","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211125","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-27T01:27:14.223Z","comments":true,"path":"2021/11/25/20211125/","link":"","permalink":"http://spcablast.club/2021/11/25/20211125/","excerpt":"","text":"###509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1给你 n ，请计算 F(n) 。 12345678910111213141516171819202122232425262728293031class Solution &#123;public://今日吐槽：因为是中午，所以有力气吐槽//人是有限的，精神呀，还是体力呀，精神又包括注意力，记忆力，操控自己做哪件事不做哪件事也需要消耗精神力，体力，只要没睡觉，都在消耗体力//那么既然人是有限的，而一天要完成的活动是有量的，假使这个人的能量恰好或者很难完成所有的活动//这样很容易就能得到一个结论，//先在精神力和体力都充足的时候把一定要完成的事情做完了，在能量消耗过多的时候通过特定的行为恢复一部分能量，比如睡了，吃点//如果还是不能完成所有的活动，那么就一定会放弃一些事情，或者粗略的完成一些事情，否则就到第二天了//以及，我以为的只是我现在以为的 int fib(int n) &#123;//怎么用动态规划的思想做这道题嘞//因为斐波那契数列第三个后，每一个数都是由前两个加起来的到的，所以存在递推关系//关键词：// 边界条件：F(0) = 0, F(1) = 1;这是这个问题的起始点，所有的数都由这两个开始// F(n) = F(n-1) + F(n-2)直到 n == 2// 现在是22点13分，继续// 根据以上的推论，递推公式有了，边界条件有了，就可以写代码了，好了 int i = 2; if(n &lt; 2) return n; //用三个变量存所需的所有变量 long long p = 0, q = 1, r = 2; while(i&lt;=n)&#123; r = p + q; p = q; q = r; i++; &#125; return r; //好了，哪里用了动态规划的思想呢，r = p + q, &#125;&#125;; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int ans = 0; bool arrive(int step)&#123; if(step &lt; 0 ) return false; if(step == 0) &#123; ans += 1; return true; &#125; else if(arrive(step - 1) &amp;&amp; arrive(step - 2)); return true; &#125; int climbStairs(int n) &#123; //我天下无敌了，好了，大概吧 //走一步，或两步一次，到顶 //那就可以从顶开始减，减一或者减二，直到为0. //那边界条件就是n = 0 //每次执行的操作是减一或者减二，可以来个递归，最后n &lt; 0 返回无法到达，n == 0返回可以到达 //int ans = 0; //arrive(n); //return ans; //那我还是太菜了呀，每次从顶上下来是减一或者减二，说明dp[i] = dp[i-1] + dp[i-2],我站在这个台阶，从前一个台阶上来一种，或者是从前2个台阶上来的第二种，有两个状态可以到达我这个状态，每一个状态都有两个状态可以转移过来，就得到了递推公式，那我上面的递归也没问题吧，为什么超时了呢 int p = 0, q = 0, r = 1; for (int i = 1; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r; &#125;&#125;; 今日吐槽：又是无力吐槽的一天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211124","date":"2021-11-23T16:00:00.000Z","updated":"2021-12-27T12:22:23.893Z","comments":true,"path":"2021/11/24/20211124/","link":"","permalink":"http://spcablast.club/2021/11/24/20211124/","excerpt":"","text":"祖父节点值为偶数的节点和给你一棵二叉树，请你返回满足以下条件的所有节点的值之和： 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）如果不存在祖父节点值为偶数的节点，那么返回 0 。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;//笑死，祖父节点，难道要判断一个节点有几个孙子节点，那就可以直接深度嘛，我只要遍历到倒数第二层就完事儿了//o，要孙子节点的值加起来啊，我还以为是加爷爷节点的值int ans = 0;public: void dfs(int gp_val, int p_val, TreeNode* node) &#123; if (!node) &#123; return; &#125; if (gp_val % 2 == 0) &#123; ans += node-&gt;val; &#125; dfs(p_val, node-&gt;val, node-&gt;left); dfs(p_val, node-&gt;val, node-&gt;right); &#125; int sumEvenGrandparent(TreeNode* root) &#123; dfs(1, 1, root); return ans; &#125;&#125;; 二进制表示中质数个计算置位给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 12345678910111213class Solution &#123;public: int countPrimeSetBits(int left, int right) &#123; int a[20] = &#123;0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1&#125;; int res = 0; for (int i = left; i &lt;= right; ++i) &#123; res += a[__builtin_popcount(i)];//还有算整数转二进制数的1的个数的函数，怪了 &#125; return res; &#125;&#125;;//[作者](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/cchao-100de-jian-dan-jie-fa-by-ffreturn-pj11/)","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作 - 算法题","slug":"vector操作-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211123","date":"2021-11-22T16:00:00.000Z","updated":"2021-12-27T12:22:31.988Z","comments":true,"path":"2021/11/23/20211123/","link":"","permalink":"http://spcablast.club/2021/11/23/20211123/","excerpt":"","text":"###1389. 按既定顺序创建目标数组给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。重复上一步，直到在 nums 和 index 中都没有要读取的元素。请你返回目标数组。 题目保证数字插入位置总是存在。 1234567891011class Solution &#123;public: vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) &#123; //这题目可太绕了，在新数组index[i]的值的序号处，插入nums[i] vector &lt;int&gt; r; for (unsigned i = 0; i &lt; nums.size(); ++i) &#123; r.insert(r.begin() + index[i], nums[i]); &#125; return r; &#125;&#125;; ###面试题 05.02. 二进制数转字符串二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 示例1: 输入：0.625 输出：”0.101”示例2: 输入：0.1 输出：”ERROR” 提示：0.1无法被二进制准确表示提示： 32位包括输出中的”0.”这两位。 12345678910111213141516171819class Solution &#123;public: string printBin(double num) &#123; //从2的-1次方开始减，减到2的-32次方，如果中间都大于这个2的多少次放，说明那一次能减，如果有一次减到了0，说明能表示，如果不能，error //那这样就可以从2的-1次方加，能加就加，给个1，不能加给个0，加到2的-32次方，0.1010001 string ans = \"0.\"; while(num != 0)&#123;//怪了，double怎么能判断!=0的 num*=2; if(num&gt;=1)&#123; ans += \"1\"; num -= 1; &#125; else ans+=\"0\"; if(ans.size()&gt;32) return \"ERROR\"; &#125; return ans; &#125;&#125;; 正经吐槽：怎么还能拿double和0 == 的，这合适吗，这一点都不合适，不应该double - 0 &gt; 1.79E+308嘛 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211122","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-28T14:20:24.993Z","comments":true,"path":"2021/11/22/20211122/","link":"","permalink":"http://spcablast.club/2021/11/22/20211122/","excerpt":"","text":"384打乱数组给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果 题（吐）解（槽）：这又是数学题，排列组合和概率问题，实现每一位出现其中的数字的概率都相同，可以这样做，也可以每一位随机一个数，再在整体里删了用过的数 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; m_nums; vector&lt;int&gt; origin; Solution(vector&lt;int&gt;&amp; nums) &#123; //copy(m_nums.begin(),nums.begin(),nums.end()); m_nums = nums; origin = nums; &#125; vector&lt;int&gt; reset() &#123; return origin; &#125; vector&lt;int&gt; shuffle() &#123; int temp = 0, index = 0, len = m_nums.size(); for(int i = 0; i &lt; len; i++)&#123; temp = m_nums[i]; index = i + rand() % (len - i); m_nums[i] = m_nums[index]; m_nums[index] = temp; &#125; return m_nums; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */ ###剑指 Offer 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]示例 2： 输入：arr = [0,1,2,1], k = 1输出：[0] 123456789101112class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; sort(arr.begin(),arr.end()); //if(arr.size() == 0) return null; vector&lt;int&gt; ans; for(int i = 0;i &lt; k; i++)&#123; ans.push_back(arr[i]); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211121","date":"2021-11-20T16:00:00.000Z","updated":"2021-11-21T14:56:01.423Z","comments":true,"path":"2021/11/21/20211121/","link":"","permalink":"http://spcablast.club/2021/11/21/20211121/","excerpt":"","text":"###8. 字符串转换整数 (atoi)请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: //我又倒了，我应该学一下怎么写自动机的，或者是正则表达式 //int myAtoi(string s) &#123; //丢空格 //起始是正负号，或者没有 //有数字转数字，没数字返回0 //大于INT_MAX返回INT_MAX小于INT_MIN返回INT_MIN //为什么我用VS和这里结果不一样 // if(s.size() == 0) return 0; // long flag = 1 ,temp = 0, ans = 0; // for(int i =0; i &lt; s.size(); ++i)&#123; // //先都当负数，有正负号存到flag里 // if(s[i] == ' ')&#123; // &#125; // else&#123; // if(s[i] == '+')&#123; // flag = 1; // &#125; // else if(s[i] == '-')&#123; // flag = 0; // &#125; // else if((s[i] - '0')&gt;=0 &amp;&amp; (s[i] - '0')&lt;=9)&#123; // temp = s[i] - '0'; // ans = ans*10 - temp; // &#125; // else // break; // &#125; // &#125; // ans = flag?-ans:ans; // if(ans &gt; INT_MAX) return INT_MAX; // if(ans &lt; INT_MIN) return INT_MIN; // return ans; // &#125; //考虑到各种情况的题解 //这题目不仅要取出数字，还得判断是不是一个正常意义的数字 int myAtoi(string str) &#123; unsigned long len = str.length(); // 去除前导空格 int index = 0; while (index &lt; len) &#123; if (str[index] != ' ') &#123; break; &#125; index++; &#125; if (index == len) &#123; return 0; &#125; int sign = 1; // 处理第 1 个非空字符为正负符号，这两个判断需要写在一起 if (str[index] == '+') &#123; index++; &#125; else if (str[index] == '-') &#123; sign = -1; index++; &#125; // 根据题目限制，只能使用 int 类型 int res = 0; while (index &lt; len) &#123; char curChar = str[index]; if (curChar &lt; '0' || curChar &gt; '9') &#123; break; &#125; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; (curChar - '0') &gt; INT_MAX % 10)) &#123; return INT_MAX; &#125; if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; (curChar - '0') &gt; -(INT_MIN % 10))) &#123; return INT_MIN; &#125; res = res * 10 + sign * (curChar - '0'); index++; &#125; return res; &#125;&#125;; ###908. 最小差值 I给你一个整数数组 nums，请你给数组中的每个元素 nums[i] 都加上一个任意数字 x （-k &lt;= x &lt;= k），从而得到一个新数组 result 。 返回数组 result 的最大值和最小值之间可能存在的最小差值。 示例 1： 输入：nums = [1], k = 0输出：0解释：result = [1]示例 2： 输入：nums = [0,10], k = 2输出：6解释：result = [2,8]示例 3： 输入：nums = [1,3,6], k = 3输出：0解释：result = [3,3,3] or result = [4,4,4] 提示： 1 &lt;= nums.length &lt;= 100000 &lt;= nums[i] &lt;= 100000 &lt;= k &lt;= 10000 123456789101112class Solution &#123;public: int smallestRangeI(vector&lt;int&gt;&amp; nums, int k) &#123; int min = INT_MAX,max = INT_MIN; for(int num :nums)&#123; if(num &lt; min) min = num; if(num &gt; max) max = num; &#125; int ans = max - min - 2*k; return ans&gt;=0?ans:0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211120","date":"2021-11-19T16:00:00.000Z","updated":"2021-11-20T13:50:15.758Z","comments":true,"path":"2021/11/20/20211120/","link":"","permalink":"http://spcablast.club/2021/11/20/20211120/","excerpt":"","text":"###剑指 Offer 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 12345678910111213141516class Solution &#123;public: int fib(int n) &#123; int i &#x3D; 0, j &#x3D; 1, temp, ans; if(n &#x3D;&#x3D; 0) return 0; if(n &#x3D;&#x3D; 1) return 1; for(int k &#x3D; 1; k&lt;n;k++)&#123; ans &#x3D; i + j; temp &#x3D; k; i &#x3D; j; j &#x3D; ans % (1000000007); &#125; ans &#x3D; ans % (1000000007); return ans; &#125;&#125;; ###29. 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3题（吐）解（槽）：这题也太离谱了，我提交了16次，边界情况这么多,以及我写的方法又死了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: int divide(int dividend, int divisor) &#123; &#x2F;&#x2F;被除数为最小值，除数分别为1和-1 if (dividend &#x3D;&#x3D; INT_MIN) &#123; if (divisor &#x3D;&#x3D; 1) &#123; return INT_MIN; &#125; if (divisor &#x3D;&#x3D; -1) &#123; return INT_MAX; &#125; &#125; if(divisor &#x3D;&#x3D; INT_MIN)&#123; if(dividend &#x3D;&#x3D; INT_MIN)&#123; return 1; &#125; return 0; &#125; if(divisor &#x3D;&#x3D; 0 ) return 0; &#x2F;&#x2F;一定要转成负的，因为如果被除数是INT_MIN不好表示 bool flag &#x3D; false; int m_dividend &#x3D; 0, m_divisor &#x3D; 0, ans &#x3D; 0; if(dividend &gt; 0)&#123; m_dividend &#x3D; -dividend; flag &#x3D; !flag; &#125; else m_dividend &#x3D; dividend; if(divisor &gt; 0)&#123; m_divisor &#x3D; -divisor; flag &#x3D; !flag; &#125; else m_divisor &#x3D; divisor; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 vector&lt;int&gt; listDividend &#x3D; &#123;m_divisor&#125;; while(m_dividend - m_divisor &lt;&#x3D; m_divisor)&#123; m_divisor +&#x3D; m_divisor; listDividend.push_back(m_divisor); &#125; for(int i &#x3D; listDividend.size() -1; i&gt;&#x3D;0 ; i--)&#123; if(listDividend[i] &gt;&#x3D; m_dividend)&#123; ans +&#x3D; 1 &lt;&lt; i; m_dividend -&#x3D; listDividend[i]; &#125; &#125; return flag?-ans:ans; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; -1)return -dividend; &#x2F;&#x2F; int ans &#x3D; 0, temp &#x3D; abs(divisor), totle &#x3D; 0, m_dividend &#x3D; abs(dividend); &#x2F;&#x2F; while(m_dividend -totle &gt;&#x3D; temp)&#123; &#x2F;&#x2F; totle +&#x3D; temp; &#x2F;&#x2F; ans++; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if((dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0)) &#x2F;&#x2F; return ans; &#x2F;&#x2F; else &#x2F;&#x2F; return -(ans); &#x2F;&#x2F; long m_dividend &#x3D; abs(dividend), m_divisor &#x3D; abs(divisor); &#x2F;&#x2F; if(divisor &#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D; -1)return -dividend; &#x2F;&#x2F; int temp &#x3D; divisor, itera &#x3D; 1; &#x2F;&#x2F; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F; &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 &#x2F;&#x2F; while(m_divisor &lt; m_dividend)&#123; &#x2F;&#x2F; temp &#x3D; m_divisor; &#x2F;&#x2F; itera++; &#x2F;&#x2F; m_divisor +&#x3D; m_divisor; &#x2F;&#x2F; &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211119","date":"2021-11-18T16:00:00.000Z","updated":"2021-11-20T01:02:59.852Z","comments":true,"path":"2021/11/19/20211119/","link":"","permalink":"http://spcablast.club/2021/11/19/20211119/","excerpt":"","text":"50. Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。 示例 1： 输入：x = 2.00000, n = 10输出：1024.00000示例 2： 输入：x = 2.10000, n = 3输出：9.26100示例 3： 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: double powe(long itera, double x)&#123; double ans &#x3D; 1, temp &#x3D; x; while(itera &gt; 0)&#123; if(itera%2 &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;ans &#x3D; x*temp; ans *&#x3D; temp; &#125; temp &#x3D; temp*temp; itera &gt;&gt;&#x3D; 1; &#125; return ans; &#125; double myPow(double x, int n) &#123; &#x2F;&#x2F;暴力方法超时了 &#x2F;&#x2F; double ans &#x3D; 1.00000; &#x2F;&#x2F; long nplus &#x3D; n; &#x2F;&#x2F; if(nplus &#x3D;&#x3D; 0) return 1; &#x2F;&#x2F; if(abs(abs(x) - ans) &lt;&#x3D; 0.000001) return x; &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; abs(nplus); i++)&#123; &#x2F;&#x2F; ans &#x3D; ans*x; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(nplus&lt;0)&#123; &#x2F;&#x2F; ans &#x3D; 1&#x2F;ans; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return ans; if(n &#x3D;&#x3D; 0) return 1.00000; if(abs(x - 1.00000) &lt; 2.22045e-16) return 1.000; long itera &#x3D; n; double ans; ans &#x3D; powe(abs(itera), x); return itera&gt;0?ans:1&#x2F;ans; &#125; &#125;; 598. 范围求和 II 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 输入:m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释:初始状态, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] 1234567891011class Solution &#123;public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) &#123; int mina &#x3D; m;int minb &#x3D; n; for(int i&#x3D;0;i&lt;ops.size();i++)&#123; mina &#x3D; mina&gt;ops[i][0]?ops[i][0]:mina; minb &#x3D; minb&gt;ops[i][1]?ops[i][1]:minb; &#125; return mina*minb; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211118","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:55:18.810Z","comments":true,"path":"2021/11/18/20211118/","link":"","permalink":"http://spcablast.club/2021/11/18/20211118/","excerpt":"","text":"###48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 题（吐）解（槽）：今天无力吐槽，干活 123456789101112131415161718192021class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#x2F;&#x2F;外圈到内圈轮流换位置 &#x2F;&#x2F;圈数等于n&#x2F;2 &#x2F;&#x2F;1 1 &#x2F;&#x2F; &#x2F;&#x2F;3 4 &#x2F;&#x2F;转起来（0+1，0）（0+1，n-1）(n-1,n-1-1)(0,n-1-1) int n &#x3D; matrix.size(); for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123; for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; ++j) &#123; int temp &#x3D; matrix[i][j]; matrix[i][j] &#x3D; matrix[n - j - 1][i]; matrix[n - j - 1][i] &#x3D; matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] &#x3D; matrix[j][n - i - 1]; matrix[j][n - i - 1] &#x3D; temp; &#125; &#125; &#125;&#125;; ###771. 宝石与石头 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 字母区分大小写，因此 “a” 和 “A” 是不同类型的石头。 示例 1： 输入：jewels = “aA”, stones = “aAAbbbb”输出：3示例 2： 输入：jewels = “z”, stones = “ZZ”输出：0 123456789101112131415class Solution &#123;public: int numJewelsInStones(string jewels, string stones) &#123; int ans &#x3D; 0; for(int i &#x3D; 0;i&lt;jewels.size();i++)&#123; int cur &#x3D; jewels[i] - &#39;0&#39;; for(int j &#x3D; 0; j&lt;stones.size();j++)&#123; if(stones[j] - &#39;0&#39; &#x3D;&#x3D; cur)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"ffmpeg操作","slug":"ffmpeg操作","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:57:41.824Z","comments":true,"path":"2021/11/18/ffmpeg操作/","link":"","permalink":"http://spcablast.club/2021/11/18/ffmpeg%E6%93%8D%E4%BD%9C/","excerpt":"","text":"ffmpeg.exe -i aa.mp4 -y -f image2 -ss 8 -t 0.01 -s 800x600 test.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpgffmpeg -i test.mp4 -r 30 -t 4 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 -vframes 10 image-%3d.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpg -i file name-r frame/s-f ..F… set commands file-ss time_off set the start time offset-t duration record or transcode “duration” seconds of audio/video","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"-ffmpeg命令行操作","slug":"ffmpeg命令行操作","permalink":"http://spcablast.club/tags/ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"}],"author":"YP"},{"title":"VSCode","slug":"VScode的配置","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-20T00:47:46.999Z","comments":true,"path":"2021/11/18/VScode的配置/","link":"","permalink":"http://spcablast.club/2021/11/18/VScode%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"最近要 机器 学习了，down个VSCode用用 pip install flake8装了个flake8,获得了语法提示 pip install yapf装个yapf，Alt+Shift+F可以自动化格式代码 setting.json设置一下 123456&#123; \"workbench.colorTheme\": \"Default Dark+\", \"python.defaultInterpreterPath\": \"C:\\\\Program Files\\\\Python39\\\\python.exe\", \"python.linting.flake8Enabled\": true, \"python.formatting.provider\": \"yapf\"&#125;","categories":[{"name":"VSCode","slug":"VSCode","permalink":"http://spcablast.club/categories/VSCode/"}],"tags":[],"author":"YP"},{"title":"论意欲的自由","slug":"论道德和自由","date":"2021-11-17T16:00:00.000Z","updated":"2021-12-01T12:55:59.506Z","comments":true,"path":"2021/11/18/论道德和自由/","link":"","permalink":"http://spcablast.club/2021/11/18/%E8%AE%BA%E9%81%93%E5%BE%B7%E5%92%8C%E8%87%AA%E7%94%B1/","excerpt":"","text":"论意欲的自由 起因：挪威皇家科学院提出的问题 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是自由的？ 叔本华回答这个问题写了这篇论文 正文： 第一部分，先对几个关键概念定义 1.1自由 (叔本华认为）我们能想到的是：不存在任何起妨碍的作用的东西。根据妨碍的作用之物将自由分为三类： 身体、物质、上的自由 智力上的自由 道德上的自由。 A 身体、物质上的自由指的是不存在任何种类的物质障碍。比如：人和动物没有受到皮带、绳索、监狱、瘫痪等的阻碍，他们的身体与他们的意愿相符，那动物和人就称为自由的。这是原初的，直接的，最常见的涵义。 自由的哲学概念的涵义： B 智力上的自由。智力是动因传递到意识的媒介，智力的区别导致动因是否能准确，清晰的传递到人的意识之中。 C 道德(不是日常通用的那个道德的涵义)上的自由起始： 在人没有受到物质阻碍的情况下，一个人却可以纯粹受动因的制约而不会随心所欲的行事。（动因包括恐吓，许诺，危险等） 若要接受本文的推理过程，那就得接受以上物质上的智力上的和道德上的自由就包括了自由所有的范畴了，但是是吗 引出问题：受到如此制约的人是自由的吗？人的意愿会受到以上动因的影响，那么意愿本身是自由的吗？ 从物质上对自由的制约因素到精神上对自由的制约因继续推理：如此，自由的定义从仅指能否做出行为，到与意愿发生了关联。 这样，自由的定义: 不存在任何起妨碍的作用的东西， 就变成了: 与自己的意愿相符（如果我可以根据自己的意愿行事，那我就是自由的） 这个定义把问题：“我们的意愿本身是自由的吗”变成了废话 因为把自由的定义代入之后就变成了“我们的意愿本身是自由（与自己的意愿相符）的吗” 显然是的，但是没有告诉我们东西。 所以，问题：意愿的背后是否还有原因，意愿是否依赖于其他，意愿本身是自由的吗？为了解决这个问题，需要改变自由的定义。 得出新的自由的定义：自由：不存在任何必然性。 修改后的定义还是一个否定的定义，是前一个定义的抽象涵义 是吗是吗，不存在妨碍和不存在必然性这真的是一个东西？ 必然性： 某一充足原因（根据）引发出结果。（某样东西就是从某一原因引发的结果，我们就会知道这个结果是必然的。比如，逻辑方面，数学方面，物理方面，三角形的角度相同可以得到三角形的边长相同）也就是说，不存在任何必然性，就是不依赖于任何原因，也就是一个人的意愿在外现时，并不受到原因，或者理由的左右和决定，因为否则的话，一个人的意欲活动就不会是自由的，而是必然的了。 问题变成：能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 那么接下来讨论自身意识和人的意欲（意愿）的定义，通过自身意识来定义人的意欲。 1.2 自身意识 定义：对我们自身的意识。 这个定义是相对于我们对于其他事物的意识而言的。作者把意识分成对自身的意识和对其他事物的意识，分界线由自身的定义决定 人认知其他事物的认知功能的形式分为时间，空间，因果律。我们无法使用这些功能得到对自身的意识，只能用来掌握其他事物的客观知识。 认知官能首先是以直观的方式认识、把握这一现实外在世界；然后，认知官 能就反思、琢磨以此方式所获得的直观认识，并把这些认识加工、整理 成概念。在语词的帮助下对这些概念进行无穷尽的组合，就构成了思维活动。在减去了我们总体意识中这绝大部分的内容以后，所剩下的部分 就是对自身的意识. 问题：一个人是怎么意识到自身的？ 回答：自身意识的对象物是始终就是自己的意欲活动。（通过意欲活动感受到自身） 是不是说我们能感受到的关于自己的内容，都是自己的意欲活动。 意欲活动的外现：一切渴望、奋斗、愿望、希冀、怀念、爱恋、高兴、欢庆 等，还有就是不情愿和抗拒的感情，所有的厌恶、反感、害怕、愤怒、 憎恨、悲哀、痛苦，一句话，所有一切的情感和激情。 这些情感和激情都是我们意欲的骚动，我们的意欲要么得到满足，要么无法得到满足，与我们获得或错失我们的欲望之物、忍受或者去掉我们的厌恶之物有关。这些构成了我们内在感觉的对象。 那么可以说，当一个人完全感觉不到外部的世界之后，再没有情绪，他就感觉不到自己了？没有触觉听觉视觉味觉嗅觉 而这些自身意识或者说内在感觉的对象，和外在世界存在着联系。我们在外在世界的察觉的对象，是诱发上述活动的动因和材料。 这里把自身意识和外在世界联系起来了，联系关系是外在世界诱发自身意识的活动。 2.1意欲和自身意识的关系 当一个人意欲着，他就是意欲着某一对象物。意欲活动是我们自身意识的对象，某一事物进入到我们对其他事物的意识，意欲活动产生了。 >前半句算结论还是算假设呢，或者是即将被证明的假设？ 动因： 上一句的某一事物在与我们认知官能的关系中，被称为动因,也是意欲活动的素材。意欲活动的目标就是对动因产生反应。意欲活动的本质就在这个反应之中。得出结论:没有动因，意欲活动就不会产生 问题：如果这些事物进入到我们对其他事物的意识里，意欲活动是否必然发生？发生的意欲活动一定是一样的吗？也就是，意欲会不会对这些事物有所反应？在完全一样的条件下，意欲能否有彼此相反的反应？也就是说，意欲活动会由动因必然引起吗？ 自由不自由就在这了，如果一个动因对应一个意欲活动，那人就不是自由的了当动因进入意识的时候，意欲是否保留着活动或者不活动的完全自由？ 回顾问题： 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 因为人对自身的意识 = 意欲活动，而意欲是由人对外部的意识引起的，对自身的意识不包含人对外部的意识，所以光凭人对自身的意识是不足以的得到问题的答案的。 人的自身的意识关于意欲活动的感受大致是： 我可以做我意欲要做的事。这句话真正的含义是，我们能做出与意欲相符的事。而我们无法意识到意欲的产生，只能感受到意欲产生之后，我们这么做了。无法说明我们的意欲活动的产生是否依赖于外在世界。 自身意识能感受意欲活动和操作身体。*还在酝酿过程中的是愿望，酝酿结束了的叫决定，在做出行为之后，这一行为才向自身意识表明这是决定，因为在付诸行动之前，愿望是能改变的。人们可以有相反的愿望，却只能意欲其中之一，因为到底意欲什么，只能通过做出的行动才让自身已是知道。 自身意识只包含了意欲活动，却不包含决定意欲活动的原因和理由（原因和理由在对其他事物的意识里） 那么问题就变成了： 一个人是否也和世界上的所有其他事物一样，由于自己的构成而从此成为一个明确的存在物，并且就像大自然的所有其他存在物一样，有着自己确定永恒的素质；这些素质随着外在机会的出现而必然作出反应；因此，这些素质从这方面看都带有其不变的特性（性格）；所以，这些素质以及那些可作些微调整的东西，是完全听任外在机会和诱因的限定和左右？抑或人类惟独就是大自然的例外？ 动因在进入人的意识之后，是否通过这个人的性格的处理，输出一个确定的结果，形成一个唯一的确定的意欲活动？他想说的是我可以这样做，也可以完全相反的那么做，但是由于我个人的性格，我最后只会选择一个确定的行为。 一个人的意欲就是他本身，这个人存在的真正内核。人的意欲构成了人的意识的基础。他就是想说人的性格是确定的，不变的，天生的，后天的经验无法改变一个人的性格， 3.1意欲和我们对其他的意识 让我们观察那些受意欲驱使着的意欲生物。把因果律的原因分为三种：原因，刺激，动因3.1.1原因指的是机械的物理的化学的变化3.1.2刺激指的是适当的刺激引起相应的变化//那个时候的科学不太行，这俩都不是很合适3.1.3动因以认知为媒介的因果作用。动物的活动随着动因展开，在动物的自身意识中由动因引起的内在动力叫做意欲。 人的行为动因大多是思想和念头，目前时空形成的的动因不多。所有的动因都是原因，所有的因果都有其必然性。 举个例子：我可以做出我所意欲的事情。如果我意欲（愿意）的话，我可以把我所拥有的一切捐献给穷人，以致自己也成为穷人中的一员——如果我意欲（愿意）的话！但我却无法真有这样的意欲，因为与此相反的动因 对我产生了太强有力的作用。而如果我的性格是另外一种样子，甚至是一个圣人，那我就会有捐献所拥有的一切的意欲。我真要是这样的圣人，那我就不这样意欲也不行。也就是说，我就必然要这样做。所有这些都与自身意识中的表白“我可以做出我所意欲的事情”并行不悖。 *性格首要决定了各种不同的动因在某一个人 身上的作用方式，因为动因所引出的所有结果，其基础根源是性格，正如由最狭窄意义上的原因所引出的结果，其基础根源是普遍自然力，由 刺激所引出的结果，其基础根源是生命力一样。与自然力一样，性格同样是原初的、无法改变的和无法解释的。 每个人的性格不一样； 性格是在经验之后才能了解到的； 性格是持续如一的； 性格是与生俱来的；人由于自己的性格始终不渝的追求自己的目标，性格无法改变，能通过改变他的认知改变他追求这个目标的方法和手段。 有什么用呢，比如我以为明天能早起，我下定决心等会儿去跑步，我以为我到了那个点就会去跑步，而事实上，根据我的性格，也就是意欲，也就是那个使我不同与其他人的那个事物，决定了我等会儿并不会去跑步，而是回去坐着。那这个又有什么用呢，可以根据我的性格，设置一个行为，比如走在路上突然跑起来，我就会跑回去（因为我的性格是万事开头难，开了个头就会想做完，做完了或者受到不可抗力打断才会中断），跑着跑着跑到楼下就算热好身了，甚至还有可能会练一会别的。 结论怎么来的呢，不知道，我在中途绕进去了，建议看原文结论：有了既定的动因和确定的性格，那么必然引出一定的行为结果。所有发生的事情，无论大小，都是必然地发生。 这些结论可以给作者提供平静和安慰，我觉得这样就少了人定胜天的那种感觉，既然胜天都是注定了，那么胜天也就没有失去了应该有的那种感觉。 4.1先行者列举了一些历史上对这个问题发表过意见的伟人。顺便骂了几个人（比如黑格尔）命运引领情愿者，单但拖曳不情愿的人。 –伏尔泰所以，我们可以承认：如果我们真有可能对一个人的思维方式——这通过内在和外在的行为呈现出来——有一深刻的了解，清楚 知道这个人行为后面的每一或大或小的推动力，以及所有能够影响 这个人的思维方式的外在诱因，那我们就像可以确切计算出在何时 日食、月食一样地确切计算出一个人将来的行为。 –康德 这证实了这一已得到人们承认和赞扬的格言：在科学的探索中，我们都要尽可能地精准和诚实，不受干扰地走自己的路；不要 担心自己的探索是否有可能与这一学科以外的事情相抵触，而要尽我们所能真实、完美地把这一探索工作本身进行到底。我经常看到 的情形让我确信：当我们的探索工作完结以后，那在探索进行过程 中，在考虑到其他领域的学说时，有些东西有时候会显得大有疑 问；但只要我把这些疑问置之不理，心无旁骛地专注于自己的探索 直至完成，那原先似乎大有疑问的东西，却出乎预料地与在丝毫没 有顾虑到别人的学说、对那些东西既没有先入为主的偏好也没有偏 恶的情况下，所独自发现的东西完全吻合。只要著作者能够下定决 心，更加诚实地投入工作中去，那他们就会避免犯下许多的错误， 避免无谓浪费那么多的精力。（《实践理性批判》第四版，190 页） –康德 哲学家的武器是事实的理据，而不是权威的言论。（由于我没有跟上他的思路推出来结论，只能放点结论了） *“他是个坏人，是个恶棍，或者“这是个无赖，或者“他是个渺小、下作、虚假的 人，等等。这就是人们的判定；人们的指责总是针对这个人的性格。 做出的行为连带其动因，纯粹只是表明行为人的性格的证据而已；行为只是这个人的性格的外相，而这个人的性格已是永远和无法逆转地确定了下来。所以，亚里士多德说得很对，“我们赞扬做出了某一行为的 人，但那些行为只是显示了做出行为的人的性格而已。就算是行为还没 有做出来，但只要我们相信这个人会做出这样的行为，那我们仍然会赞 扬这个人。因此，引起我们厌恶、鄙视和憎恨的，并不是那瞬间就过 去了的行为，而是做出这些行为的人身上那些永远存在的素质，亦即性格。因此，在所有的语言里，形容道德败坏的词语、标示劣性的绰号都 是对人更甚于对事，因为性格才应该承担罪责，而这罪责只是因为有了 机会才通过做出行为得到证实。结论： 一个人永远只做出他所意欲（愿）的行为，但他做出这样的行为其实是必然的。原因全在于这个人已经就是他所意欲：因为只要这个人是这样的人，那必然就会做出所有这样的事情。如果我们客观（体）考察这个人的行事，亦即从外在考察这些所为，那我们就会确实 无疑地认出：这些行为和大自然每一存在物的发挥是一样的，都是严格 受制于因果法则。从主观（体）上看，每个人都感觉自己总是按照自己 的意欲行事。但这只说明了他的发挥（行为），只是他自身本质的纯粹外现而已。所以，大自然的每一存在物，甚至最低级的一类，都会有这同一样的感觉——如果它们能够感觉的话。//我是我 再贴一段： 因此，大致上而言，所有在当事人当时不知道自己在干什么或者完全没有能力考虑到制止这样做的理由，亦即在没有能力考虑到事情后果 的情况下所犯下的罪行，都可视为在欠缺智力自由的情况下的犯罪。因 此，这种情形的犯罪，犯罪者是不应受到惩罚的。 但如果人们认为：由于没有道德上的自由，因此，一个人做出某种行为是不可避免的，所以，犯下罪行的人不应该受到惩罚，那他们可是 理解错了刑罚的目的。也就是说，他们误以为对罪犯实施惩罚是因为罪 行本身的缘故，是基于道德理由的以牙还牙的报复。虽然康德也教导这 样的观点，但这样的惩罚却是荒谬的、没有任何目的的、绝对是没有任 何理由的。这是因为一个人又有何权利以绝对法官自居去判断他人的道 德，并因为他人的罪过而对其加以折磨！其实，法律——亦即威胁给予 惩罚——目的却是要成为制止人们将来犯罪的相反动因。如果在某些情 形里，法律起不到这样的制约作用，那也得执行法律，因为如果法律得 不到实行，那在将来的所有情形里，法律都将无法再发挥制约的作用。 在罪犯方面，罪犯在这种情况下遭受惩罚是自己的道德品质所致——罪 犯自己的道德品质与那外在环境的动因，再加上误导自己让自己以为可 以侥幸逃脱惩罚的智力，三者结合起来，不可避免地促成了犯罪。在这 种情况下，只有当事人的道德性格并不是这个人自己的作品，并不是认 知的行为，而是他人的作品，那他遭受惩罚才是不公正的。如果一个人 罪恶行为的结果并不是人为的，而是遵循大自然的规则，那行为与其后 果也是一样的关系。例如，如果因放肆纵欲而导致疾病，又或者，如果 一个人在夜间闯入别人的猪圈，试图盗走里面的猪，但却碰上碰巧在这过夜的主人寄宿在这猪圈里的大熊。 既然一切都是确定的，那么对于个人来说，只知道是确定的而不知道确定的内容是什么，那么未来就还是未知的，只不过能更加平静地对待以后会发生的一切事情，和以往发生的一切事情，因为都是注定的，人的性格决定了他知道了一切都是确定的之后会做出的反应。 上面对自身的意识和对外界的意识分的比较怪，可能是为了方便论证。 论文里还有点对道德和良心的论述，因为性格是确定的，所以善恶也确定了，良心是事情发生后对事情的反思。//由于后面跟不上了，只能贴很多原文，建议看原文，100页左右。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"叔本华","slug":"叔本华","permalink":"http://spcablast.club/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"自由","slug":"自由","permalink":"http://spcablast.club/tags/%E8%87%AA%E7%94%B1/"},{"name":"意欲","slug":"意欲","permalink":"http://spcablast.club/tags/%E6%84%8F%E6%AC%B2/"},{"name":"推理","slug":"推理","permalink":"http://spcablast.club/tags/%E6%8E%A8%E7%90%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211117","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T13:42:26.191Z","comments":true,"path":"2021/11/17/20211117/","link":"","permalink":"http://spcablast.club/2021/11/17/20211117/","excerpt":"","text":"###1552. 两球之间的磁力在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 题解：干啊，思路有了，写出来还差一点 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool legal(int m, vector&lt;int&gt;&amp; position, int k)&#123; int pre &#x3D; position[0], count &#x3D; 1; for(int i &#x3D; 0;i &lt; position.size();++i)&#123; if(position[i] - pre &gt;&#x3D; m)&#123; pre &#x3D; position[i]; count++; &#125; &#125; if(count &gt;&#x3D; k) return true; else return false; &#125; int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; &#x2F;&#x2F;又是数学题，gan啊 &#x2F;&#x2F;阅读理解：数轴上n点，position[i], 激活m个点，找到使得m个点中每两个点的距离都尽可能的大的位置 &#x2F;&#x2F;既然这样，首尾两个球肯定是要用的，然后求中间的值，看最接近的是哪个，这样就有两段，分别取中值，找最接近的，比较四段长度 &#x2F;&#x2F;那我岂不是可以排序，然后求出所有的间隔，由大到小，不行 &#x2F;&#x2F;好像懂了，太顶了，直接找答案，答案就在0到最大值减去最小值，然后对这个值进行二分查找，存在m个长度的段大于等于这个值就对了，多于m个说明这个值可以加，小于m说明这个值得减 sort(position.begin(),position.end()); int l &#x3D; position.size(); int dis &#x3D; position[l -1] - position[0]; int left &#x3D; 1, right &#x3D; dis, prelen &#x3D; 0, ans &#x3D; -1; while(left &lt;&#x3D; right)&#123; int mid &#x3D; (right + left) &#x2F;2; if(legal(mid, position, m))&#123;&#x2F;&#x2F;如果有m个大于等于len，说明m小了 ans &#x3D; mid; left &#x3D; mid + 1; &#125; else&#123; right &#x3D; mid - 1; &#125; &#125; return ans; &#125;&#125;; ###169. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：[3,2,3]输出：3示例 2： 输入：[2,2,1,1,1,2,2]输出：2 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 题解： 123456789101112131415161718192021222324252627class Solution &#123;public: &#x2F;&#x2F;这题我见过，用哈希map吧，map好像还行，不如哈希 &#x2F;&#x2F;进阶挺难的 int majorityElement(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F; unordered_map&lt;int, int&gt; counts; &#x2F;&#x2F; int majority &#x3D; 0, cnt &#x3D; 0; &#x2F;&#x2F; for (int num: nums) &#123; &#x2F;&#x2F; ++counts[num]; &#x2F;&#x2F; if (counts[num] &gt; cnt) &#123; &#x2F;&#x2F; majority &#x3D; num; &#x2F;&#x2F; cnt &#x3D; counts[num]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return majority; unordered_map&lt;int,int&gt; map; int ans &#x3D; 0, count &#x3D; 0; for(int num:nums)&#123; ++map[num]; if(map[num] &gt; count)&#123; ans &#x3D; num; count &#x3D; map[num]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211116","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-17T04:57:58.142Z","comments":true,"path":"2021/11/16/20211116/","link":"","permalink":"http://spcablast.club/2021/11/16/20211116/","excerpt":"","text":"###67. 二进制求和给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100”示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。1 &lt;= a.length, b.length &lt;= 10^4字符串如果不是 “0” ，就都不含前导零。 题解分四种情况不如官方题解直接分两种情况，优化代码，不可能优化的，字符串的操作还得多学 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; &#x2F;&#x2F;先把字符串倒过来，用两个数存长度， &#x2F;&#x2F;a &#x3D; a.reverse(); &#x2F;&#x2F;b &#x3D; b.reverse(); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans; int acc &#x3D; 0; char tempa, tempb; int la &#x3D; a.size(), lb &#x3D; b.size(); for(int i &#x3D; 0; (i &lt; la || i &lt; lb); i++)&#123; if(i&lt;la) tempa &#x3D; a[i]; else tempa &#x3D; &#39;0&#39;; if(i&lt;lb) tempb &#x3D; b[i]; else tempb &#x3D; &#39;0&#39;; if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 3) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 2) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 1) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 0; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 0) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 0; &#125; &#125; if(acc &#x3D;&#x3D; 1)&#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(),ans.end()); return ans; &#125;&#125;; 看看人家 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int n &#x3D; max(a.size(), b.size()), carry &#x3D; 0; for (size_t i &#x3D; 0; i &lt; n; ++i) &#123; carry +&#x3D; i &lt; a.size() ? (a.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; carry +&#x3D; i &lt; b.size() ? (b.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; ans.push_back((carry % 2) ? &#39;1&#39; : &#39;0&#39;); carry &#x2F;&#x3D; 2; &#125; if (carry) &#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-binary&#x2F;solution&#x2F;er-jin-zhi-qiu-he-by-leetcode-solution&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ###299. 猜数字游戏链接你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数字和朋友猜测的数字都可能含有重复数字。 示例 1: 输入: secret = “1807”, guess = “7810”输出: “1A3B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1807” |“7810”示例 2: 输入: secret = “1123”, guess = “0111”输出: “1A1B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1123” “1123” | or |“0111” “0111”注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。 题解（吐槽）：中等题的难度也是有区别的，这个算简单吧，而且阅读理解可能是大问题，阅读理解对了之后就是怎么把已知信息用算法表现出来了，欸，思想，就是思想。优化，是不可能优化的，就是从这里跳下去，我也不会优 12345678910111213141516171819class Solution &#123;public: string getHint(string secret, string guess) &#123; &#x2F;&#x2F;简单的方法应该是遍历一遍，把公牛数字找出来，不如排序，或者用map，0到9分别有几个，对应数量相减，再减去公牛数字就是奶牛数字个数，直接用数组就行了 int cow &#x3D; 0, bull &#x3D; 0; int counts[10] &#x3D; &#123;0&#125;,countg[10] &#x3D; &#123;0&#125;; for(int i &#x3D; 0;i &lt; secret.size();++i)&#123; if(secret[i] &#x3D;&#x3D; guess[i]) bull++; else&#123; counts[secret[i] - &#39;0&#39;]++; countg[guess[i] - &#39;0&#39;]++; &#125; &#125; for(int i &#x3D; 0;i&lt;10;i++)&#123; cow +&#x3D; min(countg[i],counts[i]); &#125; return to_string(bull) + &#39;A&#39; + to_string(cow)+&#39;B&#39;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211115","date":"2021-11-14T16:00:00.000Z","updated":"2021-11-17T08:47:50.068Z","comments":true,"path":"2021/11/15/20211115/","link":"","permalink":"http://spcablast.club/2021/11/15/20211115/","excerpt":"","text":"###264. 丑数 II给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10输出：12解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 123456789&#x2F;&#x2F;没人比我更懂暴力算法.jpgint all[] &#x3D; &#123;1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400&#125;;class Solution &#123;public: int nthUglyNumber(int n) &#123; return all[n-1]; &#125;&#125;; #######正常解法 12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] &#x3D; 1; int p2 &#x3D; 1, p3 &#x3D; 1, p5 &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; int num2 &#x3D; dp[p2] * 2, num3 &#x3D; dp[p3] * 3, num5 &#x3D; dp[p5] * 5; dp[i] &#x3D; min(min(num2, num3), num5);&#x2F;&#x2F;取个最小的保证顺序 if (dp[i] &#x3D;&#x3D; num2) &#123;&#x2F;&#x2F;pi++的意思是这个数乘了2还是最小的，其他的数乘了3，5应该加到下一个了 p2++; &#125; if (dp[i] &#x3D;&#x3D; num3) &#123; p3++; &#125; if (dp[i] &#x3D;&#x3D; num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 那我只能说，我不理解，到底该谁乘2，谁乘3，谁乘5，乘几次啊 ###剑指 Offer II 069. 山峰数组的顶部符合下列属性的数组 arr 称为 山峰数组（山脉数组） ： arr.length &gt;= 3存在 i（0 &lt; i &lt; arr.length - 1）使得：arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。 示例 1： 输入：arr = [0,1,0]输出：1示例 2： 输入：arr = [1,3,5,4,2]输出：2 1234567891011class Solution &#123;public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) &#123; int max &#x3D; arr[0]; for(int i&#x3D;1;i&lt;arr.size();++i)&#123; if(arr[i] &lt; max) return i - 1; max &#x3D; arr[i]; &#125; return 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211114","date":"2021-11-13T16:00:00.000Z","updated":"2021-11-17T08:47:58.276Z","comments":true,"path":"2021/11/14/20211114/","link":"","permalink":"http://spcablast.club/2021/11/14/20211114/","excerpt":"","text":"###455. 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 1234567891011121314151617181920class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; int totol &#x3D; 0; sort(g.begin(),g.end());&#x2F;&#x2F;默认由小到大排序 sort(s.begin(),s.end()); int j &#x3D; 0; for(int i &#x3D; 0; i&lt; g.size();++i)&#123; while(j &lt; s.size())&#123; if(s[j] &gt;&#x3D; g[i]) &#123; totol++; j++; break; &#125; else j++; &#125; &#125; return totol; &#125;&#125;; ###剑指 Offer 56 - I. 数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;我只能说，NB，这方法，顶 int ret &#x3D; 0; for (int n : nums) ret ^&#x3D; n; int div &#x3D; 1; while ((div &amp; ret) &#x3D;&#x3D; 0) div &lt;&lt;&#x3D; 1; int a &#x3D; 0, b &#x3D; 0; for (int n : nums) if (div &amp; n) a ^&#x3D; n; else b ^&#x3D; n; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211113","date":"2021-11-12T16:00:00.000Z","updated":"2021-11-17T08:48:03.461Z","comments":true,"path":"2021/11/13/20211113/","link":"","permalink":"http://spcablast.club/2021/11/13/20211113/","excerpt":"","text":"###面试题 10.11. 峰与谷在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。 示例: 输入: [5, 3, 1, 2, 3]输出: [5, 1, 3, 2, 3] 1234567891011121314151617181920212223242526272829class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; vers(nums); int left &#x3D; 0, right &#x3D; nums.size()-1, len &#x3D;nums.size(); sort(vers.begin(),vers.end()); int index &#x3D; 0; while(left &lt; right)&#123; nums[index++] &#x3D; vers[left++]; nums[index++] &#x3D; vers[right--]; &#125; if(nums.size()%2 !&#x3D; 0) nums[index] &#x3D; vers[left]; &#x2F;&#x2F;这个回答和我有缘，想到一块去了 &#x2F;&#x2F; size_t idx &#x3D; 0, len &#x3D; nums.size(); &#x2F;&#x2F; if (len &lt; 3) return; &#x2F;&#x2F; size_t low &#x3D; 0, high &#x3D; len - 1; &#x2F;&#x2F; vector&lt;int&gt; sorted(nums); &#x2F;&#x2F; sort(sorted.begin(), sorted.end()); &#x2F;&#x2F; while (low &lt; high) &#123; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[high--]; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[low++]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if (len % 2 &gt; 0) nums[idx] &#x3D; sorted[low]; &#x2F;&#x2F; 作者：gfu &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;peaks-and-valleys-lcci&#x2F;solution&#x2F; bi-jiao-zhi-guan-de-xiang-fa-xian-pai-xu-by-gfu&#x2F; &#x2F;&#x2F; 来源：力扣（LeetCode） &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; ###13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: int romanToInt(string s) &#123; int lastNum &#x3D; 0, totol &#x3D; 0; for(int i &#x3D; 0; i&lt; s.length();i++)&#123; if(s[i] &#x3D;&#x3D; &#39;I&#39;)&#123; lastNum &#x3D; 1; totol +&#x3D; 1; &#125; else if(s[i] &#x3D;&#x3D; &#39;V&#39;)&#123; if(lastNum &lt; 5)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 5; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 5; totol +&#x3D; 5; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;X&#39;)&#123; if(lastNum &lt; 10)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 10; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 10; totol +&#x3D; 10; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;L&#39;)&#123; if(lastNum &lt; 50)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 50; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 50; totol +&#x3D; 50; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;C&#39;)&#123; if(lastNum &lt; 100)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 100; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 100; totol +&#x3D; 100; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;D&#39;)&#123; if(lastNum &lt; 500)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 500; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 500; totol +&#x3D; 500; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;M&#39;)&#123; if(lastNum &lt; 1000)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 1000; totol +&#x3D;lastNum; &#125; else totol +&#x3D; 1000; &#125; &#125; return totol; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211112","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-17T08:48:08.786Z","comments":true,"path":"2021/11/12/20211112/","link":"","permalink":"http://spcablast.club/2021/11/12/20211112/","excerpt":"","text":"###5. 最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 Solution &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public: void len(int * result, int i, int j, string s)&#123; if(i!&#x3D;j &amp;&amp; s[i] !&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; i; &#125; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; j; --i; ++j; &#125; return; &#125; string longestPalindrome(string s) &#123; if(s.length() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; int maxLen[2], maxi, maxL; int start &#x3D; 0, end &#x3D; 0; int index1[2],index2[2]; for(int k &#x3D; 0; k &lt; s.length(); ++k)&#123; len(index1, k, k, s); len(index2, k, k+1, s); if(index1[1] - index1[0] &gt; end -start)&#123; start &#x3D; index1[0]; end &#x3D; index1[1]; &#125; if(index2[1] - index2[0] &gt; end -start)&#123; start &#x3D; index2[0]; end &#x3D; index2[1]; &#125; &#125; return s.substr(start, end - start + 1); &#x2F;&#x2F;for(int j &#x3D; k, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; (j+1) &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F;&#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;for(int k &#x3D; 1; k &lt; s.length(); ++k)&#123; &#x2F;&#x2F; for(int j &#x3D; k+1, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; j &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i] &#x3D;&#x3D; s[j])&#123; &#x2F;&#x2F; if(maxLen &lt;&#x3D; 2)&#123; &#x2F;&#x2F; maxLen &#x3D; 2; &#x2F;&#x2F; maxi &#x3D; j; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;return s.substr(maxi, maxLen); &#125;&#125;; ###14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1： 输入：strs = [“flower”,”flow”,”flight”]输出：”fl” 123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; string ans &#x3D; strs[0]; for(int j &#x3D; 0; j &lt; strs.size() ; ++j )&#123; int i &#x3D; 0; for(; i &lt;&#x3D; strs[0].length() &amp;&amp; i &lt; ans.length(); ++i)&#123; if(ans[i] !&#x3D; strs[j][i])&#123; break; &#125; &#125; if(ans.length() &#x3D;&#x3D; 0) return &quot;&quot;; ans &#x3D; strs[0].substr(0,i); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211111","date":"2021-11-10T16:00:00.000Z","updated":"2021-11-17T08:48:14.096Z","comments":true,"path":"2021/11/11/20211111/","link":"","permalink":"http://spcablast.club/2021/11/11/20211111/","excerpt":"","text":"###1785. 构成特定和需要添加的最少元素给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 1234567891011121314151617class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long long int sum &#x3D; 0; for(int num:nums)&#123; sum +&#x3D; num; &#125; if(sum &#x3D;&#x3D; goal) return 0; if(abs(sum - goal) &lt; abs(limit))&#123; return 1; &#125; if(abs(sum - goal) % abs(limit) &#x3D;&#x3D; 0 )&#123; return abs(sum - goal) &#x2F; abs(limit); &#125; else return abs(sum - goal) &#x2F; abs(limit) + 1; &#125;&#125;; ###剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left) , maxDepth(root-&gt;right)) +1; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-17T08:48:20.645Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211109","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-17T08:48:25.246Z","comments":true,"path":"2021/11/09/20211109/","link":"","permalink":"http://spcablast.club/2021/11/09/20211109/","excerpt":"","text":"###1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans(2,0); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int temp &#x3D; target - nums[i]; &#x2F;&#x2F;if( temp &lt; 0 ) continue; for(int j &#x3D; i+1; j &lt;nums.size(); ++j)&#123; if(temp &#x3D;&#x3D; nums[j] )&#123; ans[0] &#x3D; i; ans[1] &#x3D; j; return ans; &#125; &#125; &#125; return ans; &#125;&#125;;&#x2F;&#x2F;我就说哈希表好嘛，虽然我不会 ###198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 1234567891011121314151617181920class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1)&#123; return nums[0]; &#125; if(nums.size() &#x3D;&#x3D; 2)&#123; return max(nums[0],nums[1]); &#125; vector&lt;int&gt; ma(nums.size()+1, 0); ma[0] &#x3D; nums[0]; ma[1] &#x3D; max(nums[0], nums[1]); int maxNum &#x3D; 0; for(int i &#x3D; 2; i &lt; nums.size(); i++)&#123; maxNum &#x3D; nums[i]; ma[i] &#x3D; max(ma[i - 1], ma[i -2] + maxNum ); &#125; return ma[nums.size() - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211108","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-17T08:48:31.915Z","comments":true,"path":"2021/11/08/20211108/","link":"","permalink":"http://spcablast.club/2021/11/08/20211108/","excerpt":"","text":"###1105. 填充书架附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; &#x2F;&#x2F;我大受震撼，且我不理解，下次让我做我还不会 &#x2F;&#x2F; vector&lt;int&gt; d(books.size()+1,INT_MAX); &#x2F;&#x2F; d[books.size()] &#x3D; 0; &#x2F;&#x2F; for(int i &#x3D; books.size() - 1; i &gt;&#x3D; 0 ; --i)&#123; &#x2F;&#x2F; int MaxHeight &#x3D; 0; &#x2F;&#x2F; int leftWith &#x3D; shelfWidth; &#x2F;&#x2F; for(int j &#x3D; i; j &lt; books.size() &amp;&amp; leftWith &gt; books[j][0]; ++j)&#123; &#x2F;&#x2F; MaxHeight &#x3D; max(books[j][1], MaxHeight); &#x2F;&#x2F; d[i] &#x3D; min(MaxHeight + d[j+1],d[i]); &#x2F;&#x2F; leftWith -&#x3D; books[j][0]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return d[0]; vector&lt;int&gt; dp(books.size() + 1, INT_MAX); dp[books.size()] &#x3D; 0; for (int i &#x3D; books.size() - 1; i &gt;&#x3D; 0; --i) &#123; int max_book_height &#x3D; 0; int left_width &#x3D; shelfWidth; &#x2F;&#x2F; 把第 j 本书拿到第 i 本书后面 for (int j &#x3D; i; j &lt; books.size() &amp;&amp; left_width &gt;&#x3D; books[j][0]; ++j) &#123; max_book_height &#x3D; max(max_book_height, books[j][1]); dp[i] &#x3D; min(dp[i], max_book_height + dp[j+1]); left_width -&#x3D; books[j][0]; &#125; &#125; return dp[0];&#125;; ###1822. 数组元素积的符号已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 12345678910111213class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int product = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) product *= -1; &#125; return product; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211107","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-17T08:48:36.580Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211106","date":"2021-11-05T16:00:00.000Z","updated":"2021-11-17T08:48:43.077Z","comments":true,"path":"2021/11/06/20211106/","link":"","permalink":"http://spcablast.club/2021/11/06/20211106/","excerpt":"","text":"###82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。示例 1：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates( ListNode* head) &#123; if(!head) return head; ListNode* singleNode = new ListNode(0,head); ListNode* flagHeader = singleNode; while(flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;next)&#123; if(flagHeader-&gt;next-&gt;val == flagHeader-&gt;next-&gt;next-&gt;val)&#123; int temp = flagHeader-&gt;next-&gt;val; while( flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;val == temp )&#123; flagHeader-&gt;next = flagHeader-&gt;next-&gt;next; &#125; &#125; else&#123; flagHeader = flagHeader-&gt;next; &#125; &#125; return singleNode-&gt;next; &#125;&#125;; ###剑指 Offer 39. 数组中出现次数超过一半的数字 链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //来个map? unordered_map&lt;int, int&gt; myMap; int temp = 0, maxNum = 0; for(int num : nums)&#123; ++myMap[num]; if(myMap[num] &gt; maxNum)&#123; temp = num; maxNum = myMap[num]; &#125; &#125; return temp; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"报的错","slug":"报的错","date":"2021-08-28T01:50:14.674Z","updated":"2021-08-28T01:50:14.776Z","comments":true,"path":"2021/08/28/报的错/","link":"","permalink":"http://spcablast.club/2021/08/28/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2021-07-16T09:14:24.409Z","updated":"2021-04-24T12:07:09.991Z","comments":true,"path":"2021/07/16/Markdown_test/","link":"","permalink":"http://spcablast.club/2021/07/16/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-16T09:14:24.358Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2021/07/16/hello-world/","link":"","permalink":"http://spcablast.club/2021/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"}]}