{"meta":{"title":"YP Blog","subtitle":"咸的博客","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"书单","date":"2021-04-24T08:30:14.020Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-24T08:25:31.069Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""}],"posts":[{"title":"20211110","slug":"20211110","date":"2021-11-10T13:02:14.825Z","updated":"2021-11-10T13:04:56.760Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[],"tags":[]},{"title":"20211107","slug":"20211107","date":"2021-11-07T12:59:45.924Z","updated":"2021-11-07T13:32:31.820Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[],"tags":[]},{"title":"报的错","slug":"报的错","date":"2021-08-28T01:50:14.674Z","updated":"2021-08-28T01:50:14.776Z","comments":true,"path":"2021/08/28/报的错/","link":"","permalink":"http://spcablast.club/2021/08/28/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2021-07-16T09:14:24.409Z","updated":"2021-04-24T12:07:09.991Z","comments":true,"path":"2021/07/16/Markdown_test/","link":"","permalink":"http://spcablast.club/2021/07/16/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-16T09:14:24.358Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2021/07/16/hello-world/","link":"","permalink":"http://spcablast.club/2021/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"}]}