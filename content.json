{"meta":{"title":"YP Blog","subtitle":"�̵Ĳ���","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-11-18T00:47:46.650Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://spcablast.club/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-13T12:48:45.850Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"about/index.html","permalink":"http://spcablast.club/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-11-15T05:02:33.109Z","updated":"2021-11-15T05:02:33.109Z","comments":true,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"分类","date":"2021-11-13T12:49:26.061Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://spcablast.club/categories/index.html","excerpt":"","text":""},{"title":"reading","date":"2021-11-18T00:51:00.817Z","updated":"2021-11-18T00:51:00.817Z","comments":true,"path":"books/书单.html","permalink":"http://spcablast.club/books/%E4%B9%A6%E5%8D%95.html","excerpt":"","text":"《艺术创造学》 余秋雨 《论道德和自由》叔本华 《六祖坛经》 论充足根据律的四重根 叔本华 裸猿三部曲 生命是什么 薛定谔 《上瘾》 机器学习 周志华 鲁迅全集（太长） 作为意志和表象的世界 叔本华 荣格 红书，认识人性 弗洛伊德 阿德勒 《自卑与超越》 韦启昌译叔本华 心理学之旅 论语 道德形而上学奠基句读 邓晓芒 etc.虽然作者著书的时间不同于当代，但是他们想表达的内容确实在人的范围里，这是他们根据自己的智慧得出来的结论或者经验或者是过程的记录，是他们自己的感受。是，前人的智慧。可以从中学到他们的思考方式，甚至有些东西能直接拿来用 藏书馆：《自私的基因》 《人为什么活着》王小波 《西方哲学史》罗素 《代码之美》 《非暴力沟通》 《浮生六记》 九把刀 古龙 《把时间当朋友》 《相约星期二》 《数学原理》罗素 《源氏物语》《活着本来单纯》《丰子恺文集》 《社会性动物》 《理解人性》阿德勒 《怪诞心理学》 《陈丹青音乐笔记》 《艺术创造学》 《道德情操论》 《逃避自由》 《怪诞行为学》 《直觉泵和其他思考工具》 《生命是什么》薛定谔 《叔本华思想随笔》 《深入理解计算机系统》 《菊与刀》 《皮肤的秘密》 《偶像的黄昏》 《作为意志和表象的世界》 《纯粹理性批判》 《宪法》 《行政法》 《民法》 《中医基础理论》 《自然哲学之数学原理》 《杨戬-人生长恨水长东》 《精神现象学》我觉得一点没看 《叔本华美学随笔》 《茶花女》 《逻辑学上/下》我怎么一点印象没有 《北京折叠》 《康德哲学选讲-邓晓芒》 《象与骑象人》 《中国-传统与变革》 《当下的力量》 《韩瑜文集》 《现代操作系统》 《Linux内核完全注释》 《偶像的黄昏》 《大学，中庸》 《偶像的黄昏》 《中国文化的深层结构》 《态度改变与社会影响》 《自卑与超越》 《裸猿》 《侠客行》 金庸 《大问题 简明哲学导论》 《丧家狗》 《春秋大义》 《1984》 《悟空传》 《动物农场》 《哥伦比亚的倒影》 《变形记》 《洛丽塔》 《周易参同契》 《我所有的朋友都死了？》 《子不语》 《各自的朝圣路》 《资本论》必没看完 《梦的解析》 《雪中悍刀行》 《木心诗选》 《你应该熟读的中国古诗》 《尼采诗集》 《遇见最美的宋词》 《人间失格》 《瓦尔登湖》 《牛虻》没看 《一个陌生女人的来信》 《闲情偶寄》 《杀死一只知更鸟》 《罗生门》 《我与地坛》 《芥川龙之介作品选集》没印象 《人生哲思录》 《荣格自传》 《无人生还》 《人间草木》 《小王子》 《王尔德诗选》 《诗境浅说》 《忏悔录》 《论人生不平等的起源和基础》 《月亮和六便士》 《简爱》 《苦儿流浪记》 《文学回忆录》《木心谈木心》 《苏东坡传》 《感觉的自然史》 下次继续列"},{"title":"","date":"2021-12-24T04:25:08.028Z","updated":"2020-11-11T09:08:54.000Z","comments":true,"path":"dist/APlayer.min.css","permalink":"http://spcablast.club/dist/APlayer.min.css","excerpt":"","text":".aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;transition:all .3s ease;max-width:400px}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffff\",endColorstr=\"#00ffffff\",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:\" \"}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#00ffffff\",endColorstr=\"#ccffffff\",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;transition:all .5s ease-out;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;transition:all .5s ease;will-change:height;display:none;overflow:hidden}.aplayer .aplayer-list.aplayer-list-hide{max-height:0!important}.aplayer .aplayer-list ol{list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list ol::-webkit-scrollbar{width:5px}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list ol li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list ol li:first-child{border-top:none}.aplayer .aplayer-list ol li:hover{background:#efefef}.aplayer .aplayer-list ol li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list ol li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}} /*# sourceMappingURL=APlayer.min.css.map*/"},{"title":"友情链接","date":"2021-11-13T13:26:44.960Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""},{"title":"","date":"2021-12-24T04:26:43.395Z","updated":"2021-12-24T04:26:43.395Z","comments":true,"path":"dist/music.js","permalink":"http://spcablast.club/dist/music.js","excerpt":"","text":"const ap = new APlayer({ container: document.getElementById('aplayer'), fixed: true, autoplay: false, audio: [ { name: \"你一定要幸福\", artist: '简弘亦', url: 'http://www.ytmp3.cn/down/51689.mp3', cover: 'http://img.ytmp3.cn/image/52.jpg', }, { name: '一百万个可能(Live)', artist: '摩登兄弟', url: 'http://www.ytmp3.cn/down/52772.mp3', cover: 'http://img.ytmp3.cn/image/53.jpg', }, { name: 'The Rose', artist: 'Westlife', url: 'http://www.ytmp3.cn/down/56694.mp3', cover: 'http://img.ytmp3.cn/image/51.jpg', }, { name: 'In The Eyes', artist: '江映东', url: 'http://www.ytmp3.cn/down/53053.mp3', cover: 'http://img.ytmp3.cn/image/10.jpg', } ] });"},{"title":"Repositories","date":"2021-04-24T08:25:31.071Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://spcablast.club/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-13T12:49:53.171Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://spcablast.club/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-12-24T04:25:08.031Z","updated":"2020-11-11T09:08:54.000Z","comments":true,"path":"dist/APlayer.min.js","permalink":"http://spcablast.club/dist/APlayer.min.js","excerpt":"","text":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"APlayer\",[],t):\"object\"==typeof exports?exports.APlayer=t():e.APlayer=t()}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,\"__esModule\",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"/\",n(n.s=41)}([function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=/mobile/i.test(window.navigator.userAgent),a={secondToTime:function(e){var t=Math.floor(e/3600),n=Math.floor((e-3600*t)/60),i=Math.floor(e-3600*t-60*n);return(t>0?[t,n,i]:[n,i]).map(function(e){return e=0;t--){var n=Math.floor(Math.random()*(t+1)),i=e[n];e[n]=e[t],e[t]=i}return e}([].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);ti?t:e+(t-e)*((a=n/i)n?\"function\"==typeof i&&i(t):l(u)}()},n=function(e){if(!e.defaultPrevented){e.preventDefault(),location.hash!==this.hash&&window.history.pushState(null,null,this.hash);var n=document.getElementById(this.hash.substring(1));if(!n)return;t(n,500,function(e){location.replace(\"#\"+e.id)})}};return document.addEventListener(\"DOMContentLoaded\",function(){for(var e,t=document.querySelectorAll('a[href^=\"#\"]:not([href=\"#\"])'),i=t.length;e=t[--i];)e.addEventListener(\"click\",n,!1)}),t}})?i.call(t,n,t,e):i)||(e.exports=a)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var i=function(){function e(e,t){for(var n=0;n1),n=0===this.audios.length;this.player.template.listOl.innerHTML+=(0,a.default)({theme:this.player.options.theme,audio:e,index:this.audios.length+1}),this.audios=this.audios.concat(e),t&&this.audios.length>1&&this.player.container.classList.add(\"aplayer-withlist\"),this.player.randomOrder=r.default.randomOrder(this.audios.length),this.player.template.listCurs=this.player.container.querySelectorAll(\".aplayer-list-cur\"),this.player.template.listCurs[this.audios.length-1].style.backgroundColor=e.theme||this.player.options.theme,n&&(\"random\"===this.player.options.order?this.switch(this.player.randomOrder[0]):this.switch(0))}},{key:\"remove\",value:function(e){if(this.player.events.trigger(\"listremove\",{index:e}),this.audios[e])if(this.audios.length>1){var t=this.player.container.querySelectorAll(\".aplayer-list li\");t[e].remove(),this.audios.splice(e,1),this.player.lrc&&this.player.lrc.remove(e),e===this.index&&(this.audios[e]?this.switch(e):this.switch(e-1)),this.index>e&&this.index--;for(var n=e;n"}],"posts":[{"title":"《孤注一掷》","slug":"《孤注一掷》","date":"2023-09-09T16:00:00.000Z","updated":"2023-09-10T14:53:37.865Z","comments":true,"path":"2023/09/10/《孤注一掷》/","link":"","permalink":"http://spcablast.club/2023/09/10/%E3%80%8A%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7%E3%80%8B/","excerpt":"","text":"看了看《孤注一掷》，片名和剧中举例的那位受害者的心理状态是很符合的，贪心和不甘心，还有一丝丝的愧疚，组合成了他孤注一掷的疯狂。 电影整体节奏比较快，可以说是扣人心弦了，配乐也很符合情景。 印象比较深刻的画面是那个老哥用棍子打了那么多下没打断腿，胫骨这么不容易断吗？他敲的是垂直方向呀，他还那么胖，蓄力一下就能打断然后送下去休息了吧，敲了那么多下，看着都疼。 对于本剧被诈骗的小哥的经历，观众以第三人称视角可能会想：他为什么不收手呢“收手吧，阿祖，外面全是成龙(混入奇怪的东西)”，但是于他本人来说，他已经深陷其中，他的所思所想，接收到的诈骗方的信息、他自己的幻想、已经投入的成本和亲人朋友的期望让他无法自拔，满脑子都是赢回来，而不是停下来，从头开始。在这个状态下他已经回不去了，这里建议直接送精神病院每天打镇静剂或者可以让他没有力气的药物，缓上几个月，物理隔离一段时间也许还好点。这个例子应该是比较典型且将经历快进过的一个缩影，或者是比较极端的例子，因为普通人输完几万几十万可能就一无所有了。只能从头再来。贷款，贷不了一点。 一些电影表达的内容： 中国警方在国外没有执法权； 越南当地官匪勾结； 国内的人贩子、打印社、洗钱团伙为虎作伥 警方努力侦破诈骗案，鲜有成效 境外救回来的、逃回来的人、受害者的家人参与反诈宣传； 受骗人员家破人亡、从头再来； 总感觉有人会跟着这个学去怎么诈骗，emmmm 这部剧的反诈宣传很到位了，希望多出一点这样的精品。","categories":[{"name":"影视","slug":"影视","permalink":"http://spcablast.club/categories/%E5%BD%B1%E8%A7%86/"}],"tags":[{"name":"影评","slug":"影评","permalink":"http://spcablast.club/tags/%E5%BD%B1%E8%AF%84/"}],"author":"YP"},{"title":"饥饿感的产生","slug":"饥饿感的产生","date":"2023-09-08T16:00:00.000Z","updated":"2023-09-09T14:33:38.399Z","comments":true,"path":"2023/09/09/饥饿感的产生/","link":"","permalink":"http://spcablast.club/2023/09/09/%E9%A5%A5%E9%A5%BF%E6%84%9F%E7%9A%84%E4%BA%A7%E7%94%9F/","excerpt":"","text":"产生源头下丘脑的摄食中枢控制人的饥饿感和饱腹感， 进食中枢和饱腹中枢的信号强弱对比决定决定感觉到饱还是俄 哪个更高就是什么感觉 饱腹感的来源： 胃肠道的饱胀感。 血液中的血糖和脂肪含量 所处环境的温度，温度高饱腹中枢越活越（这就是夏天不想吃饭的某个原因嘛） 影响饱腹感的其他原因：开始进食到神经中枢能做出反应的时间差大概是十几分钟，所以吃得快的时候能吃下更多的东西。","categories":[{"name":"健康","slug":"健康","permalink":"http://spcablast.club/categories/%E5%81%A5%E5%BA%B7/"}],"tags":[{"name":"饮食","slug":"饮食","permalink":"http://spcablast.club/tags/%E9%A5%AE%E9%A3%9F/"}],"author":"YP"},{"title":"人体脂肪的形成","slug":"人体脂肪的形成","date":"2023-09-07T16:00:00.000Z","updated":"2023-09-08T14:39:24.566Z","comments":true,"path":"2023/09/08/人体脂肪的形成/","link":"","permalink":"http://spcablast.club/2023/09/08/%E4%BA%BA%E4%BD%93%E8%84%82%E8%82%AA%E7%9A%84%E5%BD%A2%E6%88%90/","excerpt":"","text":"首先脂肪是什么：平时常见的包括：饱和脂肪酸和不饱和脂肪酸 脂肪里面的脂肪酸含不含双键。不含就是饱和，含有就是不饱和。 结构就决定了一些特点，有双键就可以被氧化，所以植物油不饱和脂肪酸含量高，是液态的，最好不要暴露在空气里，容易坏，顺便提一句，食用油的桶里面的增塑剂是有严格标准的，有机物相似相溶，其他塑料桶最好不要装油。动物油饱和脂肪酸含量高，就容易凝固。 摄入的脂肪被消化系统在体内被拆分成甘油分子和脂肪酸分子。 一个甘油分子和三个脂肪酸分子结合成甘油三酯分子，脂肪细胞里面就存这个，脂肪细胞的体积可大可小。 短链和中链脂肪酸不会被人体储存，进入身体就被消耗掉，比如减肥炒热的椰子油。 长链脂肪酸：C14+中链脂肪酸：C8-C12短链脂肪酸：C2-C6 身体里存储的脂肪怎么来的途径： 食用的脂肪转存到脂肪细胞 非脂肪物质合成脂肪 脂肪细胞成年前数量增加，250-300亿个，成年后凋亡和复制的速度持平，保持这个数量，过胖之后数量还可以增加（30kg脂肪后）。PS:没有参考文献 顺带说一下，果糖在肝脏能够很快地合成脂肪： 包括❶果糖衍生的磷酸二羟丙酮可转化为脂肪； ❷果糖衍生的甘油醛也会经糖酵解以及三羧酸循环（TCA）途径形成其他底物（丙二酰CoA）参与脂肪的从头合成（DNL）。 大多数情况下，过多的摄入果糖会通过各种途径增加或加速肝脏脂肪的合成，最终过多脂肪积累导致脂肪肝，以及增加循环中甘油三酯、VLDL的分泌释放。参考链接 由于肝细胞对果糖的摄取不受胰岛素控制，摄入果糖后会有高达约80%~90%在肝脏代谢，仅有少部分会进入循环。 而吃水果（不是果汁）的时候，水果含有的膳食纤维能够减缓果糖的吸收，能够代谢掉果糖而不是存储为脂肪。","categories":[{"name":"健康","slug":"健康","permalink":"http://spcablast.club/categories/%E5%81%A5%E5%BA%B7/"}],"tags":[{"name":"饮食","slug":"饮食","permalink":"http://spcablast.club/tags/%E9%A5%AE%E9%A3%9F/"}],"author":"YP"},{"title":"运动强度与运动量量化","slug":"运动强度与运动量量化","date":"2023-09-06T16:00:00.000Z","updated":"2023-09-07T14:59:21.990Z","comments":true,"path":"2023/09/07/运动强度与运动量量化/","link":"","permalink":"http://spcablast.club/2023/09/07/%E8%BF%90%E5%8A%A8%E5%BC%BA%E5%BA%A6%E4%B8%8E%E8%BF%90%E5%8A%A8%E9%87%8F%E9%87%8F%E5%8C%96/","excerpt":"","text":"运动强度分级 强度分级 相当于最大心率百分比/% 相当于最大吸氧量百分比/% 自觉疲劳程度 代谢当量 低 &lt;57 &lt;37 很轻松 &lt;2 较低 57-63 &lt;37-45 轻松 2-2.9 中 64-76 46-63 有点费力 3-5.9 高 77-95 64-90 费力 6-8.7 极高 &gt;96 &gt;90 很费力 &gt;8.8 什么是经常参加体育锻炼：每周参加体育锻炼或活动3次及以上，每次持续30分钟及以上，运动强度达到中等及以上，称为”经常参加体育锻炼“","categories":[{"name":"运动","slug":"运动","permalink":"http://spcablast.club/categories/%E8%BF%90%E5%8A%A8/"}],"tags":[{"name":"运动强度","slug":"运动强度","permalink":"http://spcablast.club/tags/%E8%BF%90%E5%8A%A8%E5%BC%BA%E5%BA%A6/"},{"name":"运动量","slug":"运动量","permalink":"http://spcablast.club/tags/%E8%BF%90%E5%8A%A8%E9%87%8F/"}],"author":"YP"},{"title":"《自己动手写编译系统》","slug":"编译器","date":"2023-09-05T16:00:00.000Z","updated":"2023-09-06T14:16:22.176Z","comments":true,"path":"2023/09/06/编译器/","link":"","permalink":"http://spcablast.club/2023/09/06/%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"概述 首先，编译是什么？ 是把编程语言翻译成机器语言。 源代码-》编译器-》汇编代码-》汇编器-》二进制目标文件-》链接器-》可执行文件 最初使用二进制指令控制计算机，太慢了，程序猿封装成了汇编语言， 程序越写越大，可以复用的东西越来越多，把重复的内容拿出来，放到多个文件里面，那么最后就需要把这些文件拼接起来，形成完整的可执行代码。这是链接器的功能。 既然要链接了，那怎么链呢？链接分静态和动态，静态就是把引用的代码拷到你的可执行文件里，动态就是留个地址信息，运行前缺什么就到留的地址里去找，也可以运行的时候缺什么找什么。 预编译，编译，汇编，链接 ==以GCC为例== 预编译 处理宏定义和文件包含 会把.h文件拷过去，宏定义进行替换 hello.c-&gt;hello.i 编译 hello.i-&gt;hello.s 编译成AT&amp;T格式的汇编代码(Intel有Intel的格式) 操作符，源操作数，目标操作数 汇编 helo.s-&gt;hello.o 成为了汇编代码，但是很多符号没有有效的地址信息，随便赋的值 链接 hello.o-&gt;hello 链接之后符号地址信息已经修正为正确的符号地址， 2.1编译包括词法分析，语法分析，语义分析，代码生成 2.1.1词法分析先上示例： 假设，已经有了一段程序，要对其进行词法分析，分析过程如下： 比如：var2 = var1 + 100; 分析的结果：6个词法记号：“var2”“=”“var1”“+”“100””;” 工具：有限自动机。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://spcablast.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://spcablast.club/tags/%E7%BC%96%E8%AF%91/"}],"author":"YP"},{"title":"《艺术创造学》","slug":"艺术创造学","date":"2023-09-04T16:00:00.000Z","updated":"2023-09-05T14:51:30.268Z","comments":true,"path":"2023/09/05/艺术创造学/","link":"","permalink":"http://spcablast.club/2023/09/05/%E8%89%BA%E6%9C%AF%E5%88%9B%E9%80%A0%E5%AD%A6/","excerpt":"","text":"余秋雨-《艺术创造学》他通过研究美学艺术学的主要著作总结出来的（样本来自14个国家，没说数量）两大结构：一：无结论的两难结构二：半透明的双层结构 先看一：一般认为，正确的主题思想+合适的艺术形式=好作品其实伟大的作品没有清晰地主题思想，没有简明的结论，有的都是后人加的。创作时作者基于一个或几个想不出答案的问题（当时的人想不出，以后的人可能也想不出），处于一种，你给出一个任意一个答案，就会遭到同等力度的反驳。譬如《老人与海》看二：提出一个概念“泛化误读功能”，他认为伟大作品不一定能让很多人“懂”，但是能吸引很多的受众，大概就像“不知道为什么，这幅画就是好看，这音乐挺好听的，==即使误读了也没有脱离美的控制==。有浅层变现，有深层内涵（一中的问题）， 进入论文正文:本论：艺术：艺术是人加入自然，解放自然 梵高艺术是人与自然相乘 培根艺术的难点在于使外在的现象成为心灵的表现 黑格尔 也就是使自然人化人法天，人补天工，人出于天，天自补也 艺术是一种纯粹而孤独的创造，他要构造一种原来并不存在的虚像，就算与现实相关，也是一种主观经验和情感生活的表现。 创造的说服力：让精神虚设变成精神成果，让人接受他“不管他画的是谁，这张画像极他”-画的太好了 综上，下定义：艺术是一种把==人类生态==变成==直觉审美==的创造。 第二章艺术眼光解释上一章的定义前先解释艺术眼光 解释艺术眼光前先解释什么不是艺术眼光相比于历史眼光，历史眼光由于过于追求功业，因此太冷，太硬相比于政治眼光，艺术眼光只敏感于生命状态，（写目前的政治都时写某个生命体的心理特征）相比于道德眼光，艺术眼光并不关注道德，只关心在各种道德规范下蠕动的生灵，因为这些生灵，才反观道德。 艺术眼光： 是一种在关注人类生态的大前提下，不在乎各种权力结构，不在乎各种行为规程，不在乎各种流行是非，不在乎各种学术逻辑，值敏感于具体生命状态，并为这种生命状态寻找直觉形式的眼光 第三章人生意识对于情节性的作品，其中的一个一个人生就是“==人类生态==”的具体形式。这章解释定义中的“人类生态”，解释这个之前又引入了人生意识这个概念。这里的人生不是指“人”这个大的概念，是指人生，指人的历史性展开，人的==动态==发展流程，是人创造价值的过程，是人的生命的具体实现，人生意识，动态的认识自身，认识人生，流动的时空世界其一，人生况味，不懂，像是人生总体生态的浓缩，魔幻的人生总是会发生一些魔幻的事情其二，人生命题， 第四章哲理品格，艺术家概括人生，将其与自然或历史对应，就到哲理层面了。艺术哲理的本质，是在审美意义上对人生意蕴的整体性开发。怎么说呢，他说原始人还有整体感，随着分工逐渐细化，就不如原始人了，19世纪往后能看太空了，整体性又回来了一点，人们就追求那种整体性的哲理，情节还是情节，求具体，求局部，在故事的整体架构上表现哲理，求普遍，求整体。举例说上世纪30年代的电影乱世佳人魂断蓝桥什么的，注重历史细节过多，当时的人看还行，现在的人已经和那段历史没关系了，加上其中哲理性不够，所以没味儿，现在人看不下去。 第五章 未知和两难 艺术的哲理追求，也就是用艺术手段燃起人探索未知领域的欲求。作者也不一定知道答案，他们想和读者、观众一起研究。 艺术家是想靠近“天心”和“神性”吗？ 杰出的艺术大多会通过对不可把握的事物的描绘来探寻世界的“伟大秘密” 艺术作品，用艺术自身的方式，在公认正确的道理的外面，反面或者边缘地带，发现新的道理。 两难，比如老人与海，他是胜利者还是失败者， 真正优秀的作品，不管你读多少遍，你不知道他是怎么写成的。这是因为一切伟大的作品都有神秘之处，而这种神秘之处是分离不出来的。它继续存在着，永远有生命力。你每重读一次，你看得到或者学的到新的东西。你不会首先感觉到你读头一遍时是如何上技巧的当的。–海明威 问：把自己还没有解决的问题拿出来交给观众，不是太不负责了吗？答：把生活中并未解决的问题在艺术上轻便的解决了，不是太不负责了吗？问：还找不到答案的问题，有什么表现的必要呢？答：已经找到了答案的问题，有什么表现的必要呢？ 在这些现代艺术家看来（在作者看他们看来的看来），世界的意义，人生的意义，都不是某种事先的强加，而只能产生在探索过程中。探索有结果吗？可能有，也可能没有。最大的那些未知课题与人类相始终，因此肯定不会找到答案，又永远充满吸引力，于是探索、开发、发现、创造，这就是新世纪艺术的主旋律。 第六章 集体深层心理， 接上章说探索未知，最经典的就是探索人类自身的未知， 先看潜意识，弗洛伊德开启的对人的深层潜意识的大规模研究。既不是产生于个人经验，也不是产生于后天积累，而是生来就有的。 艺术家只要有效的把自己的潜意识释放出来，便能在深入的层次上接通人类。（欸，别人一看这个作品，虽然看不懂，但是好像什么东西被触发了，就有了神奇的感觉） 再看荣格提出的集体无意识，上边是所有的人类共有的，这个偏向于各个种族自己的特色的，就像德国的歌德才能写出浮士德，中国的鲁迅才能写出孔乙己。每当人们误入迷途，便感到需要有个向导、导师、甚至医生。这个意象在总的形势产生混乱的时候，它才会出现在个人的梦境或艺术作品中。-荣格 这种意象，是每个民族代代相传的，算是“自古以来一直存在的普遍意象”，甚至往前能推到神话，近点可以推到“君子”这个意象， 鲁迅就在作品中体现了近代中国人的集体深层心理。 第七章 直觉上面是内容，那么表达内容需要形式。 直觉是一种挣脱了理性分析而能直接、整体、本能的把握世界和人类意识的能力。 在直觉之后，进行分析，那么，任何一项分析都是转述，一种使用符号的阐述，一种由于采取一连串观点而获得的表述；从多少个观点出发，就是指出所研究的对象与其他被认为已经知道的对象之间有多少联系。 所谓直觉就是指那种理智的体验，它使我们置于对象的内部，以便与对象中那个独一无二、不可言传的东西相契合。 有一部分没看懂 第八章 造型 艺术家把直觉变现在艺术作品中， 情感的直觉造型，《背影》最值得注意的，是情感和文字之间的一个中介结构，那就是情感的直觉造型，这个背影就是一个出色的情感的直觉造型 演员将那个角色的生活的那段生活的内在形式，体现在自己的形貌体止上，构成了直觉造型。 在艺术中，哲理追求也应该体现在直觉形式上。比如红楼梦里的诗句， 第九章 象征 象征之一，寓言象征寓言把以此喻比、以表喻里的半透明结构锤炼成一个整体，而不仅仅是一些部件；寓言之二，实体象征比如老人与海里面的老人，海，孩子，鲨鱼它以艺术家自己发现、构建的一个平实的世界，来与世界整体对应。由于它固守着现象实体，因此被称作“实体象征”。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"艺术","slug":"艺术","permalink":"http://spcablast.club/tags/%E8%89%BA%E6%9C%AF/"}],"author":"YP"},{"title":"随笔(二)","slug":"随笔(二)","date":"2023-09-03T16:00:00.000Z","updated":"2023-09-08T08:17:49.951Z","comments":true,"path":"2023/09/04/随笔(二)/","link":"","permalink":"http://spcablast.club/2023/09/04/%E9%9A%8F%E7%AC%94(%E4%BA%8C)/","excerpt":"","text":"逍遥游的某一种解读： 现代人不喜欢自己的岗位，不喜欢自己的上司，不喜欢自己的同事，上起班来哪哪都不舒服，要让他找原因，人们往往谦虚说自己的学历不够，能力不够，也就是人们错误的认为自己的知识不够，掌握知识应用知识的能力不够（我觉得现在的年轻人已经不会这么想了，最多是潜意识里这么想想，自己都感受不到，已经多从外部找原因了），所以才不能拥有一份心满意足的工作，才不能主宰自己的人生。人们忽略了可能是因为位置不对，位置不对能力难以发挥，天性压抑则兴趣不在，兴趣不在则干什么都类。只有摸鱼的人知道摸鱼时心有多累，（啊？是嘛，我摸一会儿鱼我开心）神志有多胆怯，时间有多难熬，人世间最悲惨的事情是，工作与兴趣不符。 物质压力如此之大的现实生活之中，你是否还有勇气调整自己的位置呢？ 去找，去体验，慢慢找，生命结束之前找到就不晚，也许有人的意义就是在找这个的过程中实现的，也许找这个动作就是他想要的。去体验，去感受自己做每一种类型的事情的真实感受，什么让自己开心，什么让自己长久的开心。 在最合适的位置上，发挥天赋的秉性，这件事你喜欢干，干起来就有无限的耐心，这就是你的逍遥之境。 又一种解读： 其实庄子想说的恰恰是世界上压根没有什么正确的位置，你只要把自己的心放空，不让地位、名望、功利拘束自己的内心，你所在的地方就是你的位置。 这俩不一样嘛。只要原文作者站不出来，怎么解读都行。适合自己就好。同意某种解读就选哪个。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://spcablast.club/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"逍遥游","slug":"逍遥游","permalink":"http://spcablast.club/tags/%E9%80%8D%E9%81%A5%E6%B8%B8/"}],"author":"YP"},{"title":"从零开始练写作","slug":"从零开始写作","date":"2023-09-02T16:00:00.000Z","updated":"2023-09-03T14:23:16.710Z","comments":true,"path":"2023/09/03/从零开始写作/","link":"","permalink":"http://spcablast.club/2023/09/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%BD%9C/","excerpt":"","text":"整体思想：类比学英语，上手语法书不如背背单词跟人家用英语简单聊聊天，类比到写作就是仿写！ 新手通过模仿成熟写法，快速写出高质量文章 操作方式： 拆解， 句子段落仿写，语言节奏修辞手法， 仿写不是同义词替换！ 实际操作：1、选择模仿对象 喜欢的 3、拆解模仿对象 带着写作者的眼光，看这个作品，分析作者是怎么推进故事的，怎么描述的人物，这个人物为什么会有这个结局，如果是我，我会怎么写。比如，具体段落：长短句结合，短句给人的感觉急促，节奏快，长句沉稳悠长，二者结合，能有节奏感。比如长篇故事先总结整体故事，再总结每一部每一章故事转场，故事线是怎么配合的，起点冲突高潮结尾是怎么设计的故事的对话安排，人物形象设计，场景描写 3、根据拆解结果模仿写作 写，就硬写，反正就自己看，写就完了，不要管的 4、对比，看看哪里好哪里不好","categories":[{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"写作","slug":"写作","permalink":"http://spcablast.club/tags/%E5%86%99%E4%BD%9C/"}],"author":"YP"},{"title":"大文件切片","slug":"大文件切片","date":"2023-09-01T07:51:48.322Z","updated":"2023-09-03T14:23:12.793Z","comments":true,"path":"2023/09/01/大文件切片/","link":"","permalink":"http://spcablast.club/2023/09/01/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87/","excerpt":"","text":"layout: posttitle: Windows大文件切片subtitle: Gitdate: 2023-09-02author: YPheader-img:catalog: truetoc: true # 是否启用内容索引categories: - 工具tags: - Git 起因：git推文件推不上去原因是文件内容大于100M 解决方法1、文件切片2、用Git LFS 这里使用的是第一个办法 操作系统：Windows使用git bash的split命令（前置条件，安装了Git）split -b 200m xxxx.log -d -a 3 以下是该命令的help文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ split --helpUsage: split [OPTION]... [FILE [PREFIX]]Output pieces of FILE to PREFIXaa, PREFIXab, ...;default size is 1000 lines, and default PREFIX is 'x'.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too. -a, --suffix-length=N generate suffixes of length N (default 2) --additional-suffix=SUFFIX append an additional SUFFIX to file names -b, --bytes=SIZE put SIZE bytes per output file -C, --line-bytes=SIZE put at most SIZE bytes of records per output file -d use numeric suffixes starting at 0, not alphabetic --numeric-suffixes[=FROM] same as -d, but allow setting the start value -x use hex suffixes starting at 0, not alphabetic --hex-suffixes[=FROM] same as -x, but allow setting the start value -e, --elide-empty-files do not generate empty output files with '-n' --filter=COMMAND write to shell COMMAND; file name is $FILE -l, --lines=NUMBER put NUMBER lines/records per output file -n, --number=CHUNKS generate CHUNKS output files; see explanation below -t, --separator=SEP use SEP instead of newline as the record separator; '\\0' (zero) specifies the NUL character -u, --unbuffered immediately copy input to output with '-n r/...' --verbose print a diagnostic just before each output file is opened --help display this help and exit --version output version information and exitThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).Binary prefixes can be used, too: KiB=K, MiB=M, and so on.CHUNKS may be: N split into N files based on size of input K/N output Kth of N to stdout l/N split into N files without splitting lines/records l/K/N output Kth of N to stdout without splitting lines/records r/N like 'l' but use round robin distribution r/K/N likewise but only output Kth of N to stdoutGNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;Report any translation bugs to &lt;https://translationproject.org/team/&gt;Full documentation &lt;https://www.gnu.org/software/coreutils/split&gt;or available locally via: info '(coreutils) split invocation'","categories":[],"tags":[]},{"title":"论美","slug":"论美","date":"2023-08-28T16:00:00.000Z","updated":"2023-08-28T14:08:04.763Z","comments":true,"path":"2023/08/29/论美/","link":"","permalink":"http://spcablast.club/2023/08/29/%E8%AE%BA%E7%BE%8E/","excerpt":"","text":"美德就好比一块宝石，朴素的装饰最能映衬它的价值。无疑，美德存在于外表动人者身上最好不过，不过若没有精致的容貌，在气质方面展现出的庄重大方也会胜过容貌的姣美。此外，拥有俊俏容颜者也拥有杰出的德行是不多见的，仿佛大自然太过于繁忙只求没有差错而已，而不愿意在塑造卓越上花费更多的工夫，因此这些人虽然拥有标致的外貌，却没有优秀的精神气质，对行为举止的钻研热情要高于对德行的追求。但情况也不总是如此，因为奥古斯都·恺撒、提图斯·维斯帕西亚努斯[74]、法国国王美男子菲利普[75]、英国国王爱德华四世[76]、雅典的亚西比德[77]、波斯统治者伊斯梅尔，都志存高远、气宇轩昂，并且也是他们所处时代中第一等的美男子。就美而言，容貌之美要胜过肤色之美，而优雅得体的举止之美又胜过容貌之美。美最摄人心魄之处，是用图画也难以表达的，是第一眼难以发现的。任何一种精妙绝伦的美在其比例上都会有一些独特和奇妙之处。一个人很难说出阿佩里斯[78]和阿尔伯特·丢勒[79]谁更为不明智。他们中的一位，用几何比例来画人；另外一位，取若干面孔的最佳部分来构造一张完美的脸庞。这样画出来的人，我想，除了能取悦画家自己，谁也取悦不了。我不是认为一位画家不能描绘出一张前所未有的俊美面孔，而是认为他应该在创作时运用一种巧妙的画法（就如音乐家在谱曲时蕴涵的神韵），而不是依据规则来创作。如果你对人的脸进行一部分一部分的仔细观察，那你是找不到一张能视为美的面庞的，人应该将面孔作为整体来看，这样才能发现其动人之处。如果美的主要部分是存在于端庄的举止中这句话是真的，那么确实不会令人惊奇的是，有些人历经岁月风霜后却似乎更为可爱了，““美之迟暮也是美的”。[80]因为如若不宽容，并且将青春年少本身视为对美的弥补，就没有青年人能算是美丽的。美就像是夏日的水果，容易腐坏，不易长久保持；并且大多数情况下，美造就了放荡不羁的青年人，也造成了悔恨的老年时代。但仍然确定无疑的是，如果美能适当地起作用的话，它会使美德闪耀，使恶习赧颜。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"随笔(一)","slug":"随笔","date":"2023-08-28T16:00:00.000Z","updated":"2023-09-06T14:14:16.679Z","comments":true,"path":"2023/08/29/随笔/","link":"","permalink":"http://spcablast.club/2023/08/29/%E9%9A%8F%E7%AC%94/","excerpt":"","text":"今天推荐一个动画，来自公众号动画学术趴的推荐， 动画名字是《缝制爱》（Sewing Love）是来自个人作者许愿的2023年学生毕设动画短片。 评价是给了它的观众对于亲密关系的一种最坏的想象，也让观众开始对亲密关系产生提防和自省。 推文链接 动画链接 想必看到标题就开始浑身难受了，放两张图感受一下： 作者介绍他的创作思路和历程的时候给我一种感觉-这就是热爱吧，用心在做了，是调动了自己生命的全部，感觉、精神、和智力以及体力来完成这件事，作者在制作的过程中在不断推倒重来，螺旋上升，最终完成这一版，作者通过这部动画也在表达自己，他在学习知识，使用知识，总结知识。想到一句很老套的话，做任何事都要用心，用心就有做好的可能，不一定成功，但是一定会有收获。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://spcablast.club/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://spcablast.club/tags/%E5%8A%A8%E7%94%BB/"}],"author":"YP"},{"title":"论养生","slug":"论养生","date":"2023-08-25T16:00:00.000Z","updated":"2023-08-26T15:39:46.464Z","comments":true,"path":"2023/08/26/论养生/","link":"","permalink":"http://spcablast.club/2023/08/26/%E8%AE%BA%E5%85%BB%E7%94%9F/","excerpt":"","text":"健康之道是一门学问，不是医学的规则所能涵盖的。一个人的自我观察是他保持健康的灵丹妙药，因为这些自我观察里包含着什么是对他有益的，什么是对他有害的体验。不过更稳妥的结论是“这个不适合我，所以我不会继续这样做”，而不是“我发现这个对我没什么害处，所以我会用它”。这个就像庖丁解牛，不去用刀剁骨头，刀就不会钝年轻时体质强韧，可以承受一些过度的行为，但这些行为到人年老时终将产生不良的后果，就像欠的债务总要归还一样。要清醒地意识到自己年岁的增长，并且应明确不能再做和年轻时候一样的事情，因为变老的趋势是不容藐视的。 要注意在饮食这一重要环节不可突然改变，如果是迫不得已必须如此，也应使其他方面与之相适应。因为其奥妙在于，不论是在自然界还是在国家之中，改变多方面的事物比改变单独一个事物要更为安全可靠。对饮食、睡眠、锻炼、穿着等方面的习惯进行一一审视，看有哪些方面对你的健康是会造成损害的，一点一点地逐步将其戒除。如果改变后你觉得并不适应，就恢复原来的习惯，因为很难在如下两者之间进行区分，即一般人普遍认为是好的和有益健康的习惯，以及适合自己身体状况的特殊习惯。 在吃饭的时候、睡觉的时候及锻炼的时候，保持轻松愉悦的心情，把烦恼放在一边，这是延年益寿的要诀之一。至于头脑中的情绪和思虑，应避免妒忌、焦虑恐惧、内在的愤怒烦躁、过于敏感以及绞尽脑汁的冥思苦想、过度的喜悦和兴奋、压抑心底的悲伤。怀抱希望，尽情欢笑，而不是狂喜，享受各种喜悦而不是过度地沉浸其中，有好奇心和赞美之心（从而对生活保持新鲜感），用辉煌灿烂的事物充实心灵（如历史、寓言及对自然的沉思等）。喜怒哀乐之未发，谓之中，发而中节，谓之和。情绪也要顺其自然，不去压抑，也不要太过 如果你在健康状况方面从来不求医问药，当你不得不需要这样做的时候，你的身体就会很不适应。如果你在求医问药上过于频繁，当疾病来临之时，医药就不会有特别的效果了。我推荐的是，随季节变换调整饮食，而不是常常求助于医药，除非药物的使用已经变成一种习惯，因为日常饮食对身体的补益更大，且不会对身体造成不良影响。不要对身体产生的新问题视而不见，而是要询问医生相关的建议。若身体抱恙，要多遵从有助恢复健康的准则；如果身体康健，则应多活动以保持良好的状态。因为对于那些身体较为强健的人来说，倘若染上的不是重症急病，大多数情况下只需调节饮食和多加休养就能痊愈。 塞尔苏斯兼医生和智者于一身，单纯作为医生和单纯作为智者的塞尔苏斯都很难道出他曾说过的如下这番健康长寿之道，他说，一个人应该尝试各种，甚至截然相反的习惯，不过应更倾向对自己有益的那一种：在禁食和饱食之间，更偏重饱食；在不眠与睡眠之间，更侧重睡眠；在不锻炼与锻炼之间，更注重锻炼，诸如此类。 这样做，会使体质得以增强，体魄更强健。一些医生对病人的性情十分理解和包容，以至于他们对疾病无法实施真正有治愈效果的措施；还有一种医生严格地遵守治疗的程序，而没有充分地考虑病人的具体情况。看病时，应选取介于两种类型医生之间的那一种或者，如果不能找到同时调和这两种类型的医生，那就各找一位然后将两者的优点结合起来。并且就医时，除了去找德高望重以技艺扬名的医生，也不要忘记去找那位最熟悉你身体状况的医生。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"},{"name":"养生","slug":"养生","permalink":"http://spcablast.club/tags/%E5%85%BB%E7%94%9F/"}],"author":"YP"},{"title":"时间的暴政","slug":"时间的暴政","date":"2023-08-24T16:00:00.000Z","updated":"2023-09-03T23:34:53.151Z","comments":true,"path":"2023/08/25/时间的暴政/","link":"","permalink":"http://spcablast.club/2023/08/25/%E6%97%B6%E9%97%B4%E7%9A%84%E6%9A%B4%E6%94%BF/","excerpt":"","text":"有学者认为，小孩的思想和行动大多指向现在，中年和老年的思想和行动更多地指向过去，只有青年的思想和行动指向未来。 这种内生于青年本身的指向未来的时间观，使人在青年时期更倾向于追求一个美好的明天，那么以未来的利益为诱饵，资本就可以精心策划一套支配青年的制度。在这种制度的设计下，资本有意无意地鼓励青年对时间进行榨取，并经常树立牺牲当前时间来实现未来价值的时间幻象。 ==当一个人既沉浸于当下，又抬头望见梦想时，他就超越了时间，也超越了自己。当有一天，青年不再为速度所困扰，不再为过时所慌张，亦不再为未来所忧虑的时候，他的创造力就会自然开启，他的活力就会自动迸发，并随之而来一份精神的馈赠—幸福感。我们希望青年能够多一些自由的时间去放空自己，这种放空不是放纵，而是充分体验生活的快乐、工作的快乐以及社会关系带来的快乐。== 是嘛，我感觉我老是被死去的回忆攻击，很少想到未来，基本都是想着现在手头的事情","categories":[{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"青年","slug":"青年","permalink":"http://spcablast.club/tags/%E9%9D%92%E5%B9%B4/"},{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"长寿花养护","slug":"长寿花养护","date":"2023-08-23T16:00:00.000Z","updated":"2023-08-25T08:34:45.334Z","comments":true,"path":"2023/08/24/长寿花养护/","link":"","permalink":"http://spcablast.club/2023/08/24/%E9%95%BF%E5%AF%BF%E8%8A%B1%E5%85%BB%E6%8A%A4/","excerpt":"","text":"长寿花养护 浇水时机：掂一掂盆，干了的时候土很轻；或者看表面的土是不是变成了白色（夏天有可能因为晒太阳就表面一层白了，里边还是湿的，注意）；或者用干的竹签插到土里，看竹签是不是带着湿气；不要在炎热的中午且阳光直射的时候浇水（开空调就没事）；这样会导致土壤温度过高，泡烂根部。(就像深圳室外刚下完雨出太阳的大马路上) 浇水方法：沿着四周慢慢浇水，很干的时候水会很快流到底座，这样需要重复再浇一次；一般情况下沿着四周浇水，底座开始有一些水就说明浇透了。 养护：多晒太阳，能一直开花，长得好；适宜温度是20-25摄氏度；耐热，但是35度以上最好不要拿出去晒，不浇水也许能晒耐寒，深圳没有冬天更没事为了防止长太高可以开完花之后把超过一定高度的枝剪掉，花芽是从叶柄里长出来的，没事 浇水长寿花的浇水方法遵循==不干不浇，浇就浇透==的原则，为了确定是否浇水，可用竹签插进土壤，若其上有湿气，则土壤湿润不必浇水；此外还要遵照宁干勿湿的原则，尤其冬夏极端天气，在气温高于35℃或低于8℃时，就应该断水。长寿花的叶子是肉质叶，耐旱不耐涝，天热的话一周浇一次水，不热的时候十天浇一次水就可以了。 虽然说长寿花在浇水的时候，需要保持一个土壤的湿润，尤其是在它的花芽生长的时候，但是在某些时间段内，浇水必须要注意宁干勿湿。这两个时间段就是寒冷的冬季和炎热的夏季，在气温高于35℃或者是低于8℃的时候，就应该断水。 夏季的时候，气温高蒸发快，人们会认为土壤已经干了，便经常的浇水，但是其实，夏季的时候空气湿度非常大，虽然土壤的表面是已经干了，但是底部仍然不干，所以此时在浇水的话，就容易导致土壤潮湿，根部腐烂。在冬季的时候，如果浇水，水温应该和室内的温度相接近，但是还是尽量不要浇水，以免植株冻伤腐烂。 施肥施肥过多也会引起叶子发黄，通常在翻土的时候施入适当的肥即可，盆栽一年翻土1～2次为宜。 常见问题：1. 花友问得最多的一个问题就是：“我的长寿花叶尖发黄干枯，叶片软软的，也不见长，这是怎么回事？”长寿花下面的少量老叶片叶尖叶缘发黄干枯问题不大，可能是==自然老化==（就是大部分是好的，只有一两片在发黄的同时叶尖叶缘干枯，健康的叶片颜色翠绿，温度合适不缺水时摸上去不发软），只需要把黄了的叶片剪掉，注意观察就行。要是长寿花新老叶片都出现叶尖叶缘发黄干枯，发软不生长的现象，那就是烂根了，最好脱盆处理。 2. 为什么长寿花叶尖叶缘发黄干枯并发软就是烂根了？ 在==温度比较高==的时候，长寿花会进入==休眠状态==。在休眠时，根系活跃性下降，对水分养分的吸收能力变弱，输送给叶片的水分减少，叶片就会出现发软的现象。但休眠时的长寿花仅仅只有生长缓慢、叶色暗淡、光泽感不强、叶片发软问题，并不会出现叶尖叶缘发黄干枯。 暴晒，长寿花虽然喜光但不宜暴晒，如果长寿花叶子从边缘开始干枯就有可能是暴晒所致。 ==长寿花叶片发软的同时叶尖叶缘发黄干枯==，是输送给叶片的水分养分出现了严重问题，导致叶片失养，开始发黄干枯。在这种情况下，只能是根系出了问题，已经停止给叶片输送养分水分。这个时候的长寿花叶片看上去还没有完全死，没有发黄的部分也是绿色的，实际上已经死了，之所以还保留绿色是因为原本叶片中储存的养分水分还养活着一部分细胞，等这些养分水分消耗完以后，整片叶子就完全干枯。 3. 什么原因导致长寿花根系腐烂叶尖叶缘发黄干枯？ 通常导致长寿花根系腐烂叶尖叶缘发黄干枯的主要原因就是浇水不当。前面说了，夏天温度高时长寿花休眠了，休眠时生长几乎停止，对水分的需求量就很少。要是这个时候还是给长寿花浇水过多，加上温度高，根系就非常容易腐烂。所以有些花友的长寿花春天好好的，夏天看起来蔫不拉几，等到了秋天原本快速生长的时候就发软、叶尖叶缘发黄。因此，想让长寿花安全度夏，夏天要少浇水多通风，等秋天凉爽以后长寿花开始生长，再适当多浇水勤施肥，秋末冬天就容易开花了。 4. 长寿花叶片发软叶尖叶缘发黄干枯时不处理行不行？ 要是你的长寿花只有下面一两片叶子叶尖叶缘发黄，叶片发软，其他叶片都很正常，可以不用处理，把发黄的叶片剪掉就行，很可能是自然老化，多观察。要是你的长寿花上面下面都有叶尖叶缘干枯的现象，而且整株叶片都发软，没有新叶生长或者生长非常缓慢时，就需要脱盆处理，否则会出现两个后果：A、长寿花慢慢整株枯死。B、长寿花就算一时半会的死不了，但状态越来越差，秋冬冬天不开花或者开花质量非常差。","categories":[{"name":"植物","slug":"植物","permalink":"http://spcablast.club/categories/%E6%A4%8D%E7%89%A9/"}],"tags":[{"name":"多肉植物","slug":"多肉植物","permalink":"http://spcablast.club/tags/%E5%A4%9A%E8%82%89%E6%A4%8D%E7%89%A9/"},{"name":"长寿花","slug":"长寿花","permalink":"http://spcablast.club/tags/%E9%95%BF%E5%AF%BF%E8%8A%B1/"}],"author":"YP"},{"title":"中国居民膳食指南2022","slug":"膳食指南2022","date":"2023-08-21T16:00:00.000Z","updated":"2023-08-23T11:00:30.368Z","comments":true,"path":"2023/08/22/膳食指南2022/","link":"","permalink":"http://spcablast.club/2023/08/22/%E8%86%B3%E9%A3%9F%E6%8C%87%E5%8D%972022/","excerpt":"","text":"中国居民膳食指南2022金字塔文字版盐5g，油25-30g奶及奶制品，300-500g，大豆坚果，25-35g动物性食物，100-200g，每周一到两次鱼，每天一个鸡蛋蔬菜300-500，水果200-350g谷类200-300g，其中包含全谷物和杂豆50-150g薯类50-100g 看图 PS：这些量都可以攒的，比如今天没吃青菜明天多吃点，但是请不要攒到几年后。而且消化系统每天能消化的油脂和蛋白质是有量的，除非吃自助，一般不会吃到腹胀，也就是今天消化不了了。 其他： 足量饮水，少量多次。在温和气候条件下，低身体活动水平成年男性每天喝水1700ml，成年女性每天喝水1500ml。 少吃深加工肉制品。少吃肥肉、烟熏和腌制肉制品。 少吃添加剂对肝好，少吃肥肉，看看上边的25-35g油脂，可以攒一个星期的量，然后吃一顿红烧肉3. 鼓励适当进行高强度有氧运动，加强抗阻运动，每周2~3天。减少久坐时间，每小时起来动一动。4. 平均每天摄入12种以上食物，每周25种以上，合理搭配。（吃食堂才能做到了） 一些分析： 建议碳水化合物占每天供能的40%到70%，因为高了低了都会提高死亡率，大概就是从1%提高到1.6%，没啥事的样子，还行。 上边推荐每天吃点全谷物， 薯类是因为能降低糖尿病发病风险26%，也不多，图一乐。 燕麦可以改善血脂异常，书里没有给数值； 薯类还可以降低便秘发生的风险，大家都知道他润肠通便了，别说了， 还能维持正常体重，全谷物一个个都是吃了不好消化的，吃点就饱了，肯定降低吃其他东西的量了。50g也很多了。 还能补充VB 豆类(成熟、干燥)很特别，豆类不仅提供一定比例的淀粉，而且还是蛋白质(19-24%)、纤维(15-25%)和微量营养素的重要来源； 多喝水能够提高新陈代谢，运送废物，排出多余的热量，发烧的时候多喝水能带走一部分热量，有助于降温，药吃多了多喝水也能给他快速代谢掉，喝太多会水中毒，看上边的量； 上边推荐每天运动，一周累计中等强度运动150分钟，每天30分钟，每次最少10分钟，一周5天为基本款。 中等强度运动指：心率在最大心率60%到75%。 最大心率 = 207-年龄*0.7 主观感觉在心跳呼吸加快，用力但不吃力，可连续说话但不能放声唱歌 运动，动起来啊，靓仔 中等强度身体活动，可降低心血管病、糖尿病、结肠癌和乳腺癌等慢性病的风险与病死率。 处于不健康状态的就低强度运动吧运动强度参考链接 上面是标准的 消化不好的原因：主要原因有一下三个： 精神紧张， 感染了幽门螺杆菌， 不良的生活习惯 细分直接原因: 病变 胃肠动力不足(为什么不动呢)；胃肠溃疡，都烂啦，就像摔跤了擦破了皮，还往上糊食物，往上糊胃酸，ph1啊，那得多痛，胃酸分泌过多？ 脾胃虚弱,“脾”主运化，消化和吸收都包括进去了，大肠是肺经，肝主疏泻，小肠是心对应的腑，胃是脾对应的腑，有个词叫纳呆，诶，我看看几个治消化不好的中成药主治什么就好了，一会儿看 生活习惯 碳酸饮料含有过多的糖，肠胃无法吸收的时候会导致腹胀，为什么糖都吸收不了乳制品如果乳糖不耐受，蛋白质分解不了就会腹胀，为什么分解不了会胀？给细菌分离了？豆类一堆分解不了的东西，在那儿 进食糖后胃不舒服,与进食糖后刺激胃酸分泌过多有关,导致胃内平衡机制被打破,攻击因子过强,黏膜保护机制受损所致。且吃糖会 降低食欲.所以适量吃 坚果油脂含量太高，不好消化 烟酒，浓茶，暴饮暴食，饭后很快洗澡、运动、睡觉，前两个是供血没给胃，睡觉是胃不动了 那么消化不好的时候吃什么：下次更新：下次一定","categories":[{"name":"健康","slug":"健康","permalink":"http://spcablast.club/categories/%E5%81%A5%E5%BA%B7/"}],"tags":[{"name":"饮食","slug":"饮食","permalink":"http://spcablast.club/tags/%E9%A5%AE%E9%A3%9F/"}],"author":"YP"},{"title":"人啊，认识你自己","slug":"人啊，认识你自己","date":"2023-08-09T16:00:00.000Z","updated":"2023-08-10T02:30:28.895Z","comments":true,"path":"2023/08/10/人啊，认识你自己/","link":"","permalink":"http://spcablast.club/2023/08/10/%E4%BA%BA%E5%95%8A%EF%BC%8C%E8%AE%A4%E8%AF%86%E4%BD%A0%E8%87%AA%E5%B7%B1/","excerpt":"","text":"今天讨论对自身的意识首先对意识这个过程下定义，把人的意识分为对自身的意识和对其他事物的意识，其中自身规定为除其他事物之外的东西，就像一束光只能照到除了他自己之外的事物，意识也不能直接意识到自身，那么人怎么意识到自身呢？ 通过分析自己的意欲活动来获得对自身的意识。这里的意欲活动指所有一切的情感和激情：一切渴望、奋斗、愿望、希冀、怀念、爱恋、高兴、欢庆 等，还有就是不情愿和抗拒的感情，所有的厌恶、反感、害怕、愤怒、 憎恨、悲哀、痛苦。 而情感和激情是通过与外在世界联系产生的，我们意识外在世界，产生了情感和激情。 所以对自身的意识的材料来自我们与外在世界的互动，通过分析互动产生的结果，也就是自身产生的情感和激情，我们认识了自己。 一个人的意欲(根据外界刺激产生对应的情感和激情)，就是他本身。","categories":[{"name":"认识自己","slug":"认识自己","permalink":"http://spcablast.club/categories/%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"幸福才是检验奋斗的标准","slug":"廉思-幸福才是检验奋斗的标准","date":"2022-12-26T16:00:00.000Z","updated":"2023-08-10T02:25:23.904Z","comments":true,"path":"2022/12/27/廉思-幸福才是检验奋斗的标准/","link":"","permalink":"http://spcablast.club/2022/12/27/%E5%BB%89%E6%80%9D-%E5%B9%B8%E7%A6%8F%E6%89%8D%E6%98%AF%E6%A3%80%E9%AA%8C%E5%A5%8B%E6%96%97%E7%9A%84%E6%A0%87%E5%87%86/","excerpt":"","text":"节选自《廉思：从蚁族、骑手到码农，青年应当被涵养而不是被消耗｜正午访谈》原文链接界面新闻：最近关于996、内卷的讨论很多，你怎么看待这种现象？对加班、奋斗和成功，你有什么思考？ 廉思：我们制度的立足点，是让人民更幸福。无节制地去赞美透支健康乃至生命的奋斗，能得到真正的幸福么？奋斗和幸福是什么关系？我们提倡奋斗成就未来，但奋斗的内涵和逻辑要讲清楚。 我们赞美奋斗，但反感996，说明“奋斗”有个边界，一旦突破了这个边界，奋斗就变成了对人的榨取，反而会激发奋斗者的反感。过度的奋斗，感受不到成就和意义，只会沦为单纯的消耗和痛苦。年轻人谈到“内卷”“躺平”，很多人听到很着急，说年轻人怎么不想奋斗了？其实，青年不是不想奋斗，而是想知道自己为谁奋斗，奋斗的价值和意义何在。 这要从奋斗的本质谈起。奋斗其实是一种劳动，而996是过劳的一种表现。一般认为，劳动是美德，而过劳是一种“恶”。这里面要区分几个概念。首先要区分被迫过劳和自愿过劳。尽管被迫过劳大量存在，但应被批评，应被禁止，也是法律所不允许的。在现实生活中，我们还能看到很多自愿过劳——心甘情愿的超时工作。自愿过劳所能带来的价值，通常体现为个人事业的成功。必须承认，自愿过劳付出更多的努力，确有可能带来更多事业成功的机会。此外，自愿过劳还可以带来一种特殊的成就感、价值感和自豪感。但我们要注意的是，事业是生活的全部么？事业确实是生活的重要组成部分，但事业成功并不等于生活幸福。生活幸福是一个内涵丰富的概念，它应当包含更多美好的事物。 还有一部分自愿过劳者并不是为了追求自己事业的成功，而是为了谋求其他人的幸福。谋求他人幸福的自愿过劳者与追求个人幸福的自愿过劳者相比，他们更看重他人的幸福、社会的幸福、国家的幸福甚至人类的幸福。在需要时，他们更愿意为了他人、社会、国家、人类而牺牲自己。比如抗疫斗争中的医护人员、驻守边疆的解放军战士等。 这种高尚的行为理应受到全社会的赞扬，给予高度的肯定和表彰。但是，没有这种行为的人也不应受到谴责，毕竟不可能人人都具备这种高尚的情操，我们不能强求，更不能强迫任何人都做出这样的行为。 我们之所以批判资本，是因为资本偷换了上述概念。他们把为企业工作的被迫过劳美化为国家倡导的、为他人幸福的自愿过劳，并以此鼓励青年人不断加班，美其名曰“奋斗”。实际上，国家提倡的奋斗，里面有个人意义的价值，但更包含了为国家、为社会这种为他人幸福的内涵。而资本提倡的所谓“奋斗”，把其中为国家、为社会的部分，偷换为企业自己。一旦青年感觉到自己奋斗的结果，最终成就的对象不是国家和社会，而是资本，对他而言，奋斗的动力就完全不同了。在这种情况下，抱怨年轻人躺平，其实症结并不在年轻人那里。 当然，任何形式的劳动，本质上都应指向幸福，所以，什么才是检验奋斗的标准？我认为应当是——幸福。","categories":[{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"青年","slug":"青年","permalink":"http://spcablast.club/tags/%E9%9D%92%E5%B9%B4/"},{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"“你是什么青年？”——当代中国青年的政治谱系分析","slug":"廉思-当代中国青年群体的思想谱系","date":"2022-12-26T16:00:00.000Z","updated":"2023-08-10T02:28:07.110Z","comments":true,"path":"2022/12/27/廉思-当代中国青年群体的思想谱系/","link":"","permalink":"http://spcablast.club/2022/12/27/%E5%BB%89%E6%80%9D-%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E9%9D%92%E5%B9%B4%E7%BE%A4%E4%BD%93%E7%9A%84%E6%80%9D%E6%83%B3%E8%B0%B1%E7%B3%BB/","excerpt":"","text":"接上一篇文章的内容，《中国底层青年的生存困境和出路》，2014年的时候，作者认为中国青年的困境是阶级纵向流动变得困难，表现是房子买不起，在工作城市有房的年轻人和没房的年轻人是两个阶级；困境的原因是贫困的代际传递，表现为由于上一代的社会资源和经济资源的不足，导致下一代的贫困，这个贫困体现在工作、婚姻、教育上，根本原因是（那就得再问房价为什么这么高了） 解决办法是先横向流动，再追求纵向流动，在大城市买不起房回老家买房，一代上不去可以代代累积，可能下一代就人上人了（怎么离谱的跟修仙小说一样），14年返乡买房的年轻人现在已经三十多了，可能有孩子了已经，不知道他们的下一代能否完成阶级的向上流动，（14年的出生率还有13%，到21年只有7.52%了看链接，21年死亡率都有7.18%，四舍五入就是人口没变，显然最近这些年有些人放弃了累积到下一代进行阶级的向上流动的想法，摸了，评论区有无说法。） [1]经济上是贫困的，我认为在目前这个还能看盗版书的时代，精神上可以不贫困，但是如果经济上不贫困，这个精神上不贫困的比例是不是可以更高呢？[2]假设人的生活的目标是幸福，那么在当前社会下，幸福是实现阶级的上行？没房的买房，买了房之后生活不拮据？那这个假设就默认在买了房之后就幸福了,听起来不太合理啊，阶级上去了一点点，就会想维持这个样子或者是更上一层楼？那么他就一直处于幸福之中？幸福是得到？[3]我不懂，以上都是想象。 那么看看已经2022年了，人口自然增长率0.34‰，人们将更多的资源放在自己身上而不是下一代身上，这样他们也能实现生活的幸福，2017年19大提出，在现阶段我国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾；我们的根本任务是集中力量发展社会生产力；但是工人生产出来的商品却作为资本家的财富与工人对立，工人越奋斗，工人阶级就越贫困。 不说了，看今天的第一篇文章内容原文链接 廉思：“你是什么青年？”——当代中国青年的政治谱系分析本文是参考了毛泽东的《中国社会各阶级的分析》，用政治学思维导向来分析当代中国青年问题。按14-35岁是青年来分，我国有约4.5亿青年，科学认识青年的时代特点和发展趋势，正确分析各青年群体相互之间的社会关系和思想变动，是做好新时代党的青年群众工作的重要基础，是建设社会主义现代化国家、实现“两个一百年”奋斗目标的重要依据。 开个大头，他先说这个研究是有意义的，就是说怎么能用好这4.5亿人建设国家而不出问题。用完了得安置好，要不然后人怎么看，还有谁奋斗 那么先分析这4.5亿人的结构，######建国70年来结构变化的原因：社会成员的结构归根结底是由一定的==社会生产力水平==决定的，我国目前生产力的发展状况和生产力发展所决定的社会主要矛盾的变化，以及产业结构状况、所有制结构状况、分配结构状况、就业结构状况，是我国社会成员构成结构、当然也是青年结构变化的主要原因。具体而言，结构变化的原因包括以下四个方面：一是社会生产力发展所引起的所有制结构变化和新兴产业兴起==所带来的产业结构调整，是青年结构变化的经济原因。二是城乡结构、职业结构、脑力劳动和体力劳动结构的变化所引起的分配方式和分配政策的调整，是青年结构变化的社会原因。三是教育（高等教育的普及化）、科学（尤其是互联网技术和新媒体技术的快速发展）、制度（政治制度的民主、公开、透明）等现代文明的发展，是青年结构变化的政治原因。四是各种社会思潮的流入融合以及文化产品供给的丰富多元，是青年结构变化的文化原因。#####分类及分类依据的优化：以往对社会群体的划分，无论是采用单一标准还是多元标准，其核心思路都是把教育、职业、收入、户籍、住房等作为分类的重点，所描述的是不同教育、职业、收入、户籍或住房的社会群体所掌握资源的多寡。（这是根据韭菜的高度分）如果我们变换一个视角，从社会学思维转换到政治学思维，就会有不一样的发现。政治学研究阶层结构是为了分析影响稳定的因素，预测政治制度的风险，解决非常态化的社会行为。（这是根据韭菜的造反难度分） 运用政治学的病理学方法来切入社会结构，并以此辨析不同青年群体的政治需求及其与政治制度的关系，将更有助于我们深入理解不同青年群体在中华民族伟大复兴进程中社会心态的波动变化及其对政治制度产生的潜在影响。 那么怎么分类呢原文链接： 再赶考：新百年如何赢得新青年一是按照==与体制距离的远近==，可分为成长性、内生性、建制性和原子性二是按照==发声能力==的大小，可分为杠杆性、示范性、知识性和边缘性。以上八类具体为：一是成长性群体，指在学校就读的青年，主要包括初中、高中、大中专院校就读学生等；4243.01万，占10.36%二是内生性群体，指在体制内单位就业的青年，主要包括青年公务员、国有企事业单位青年职工，青年军人等；6461.72万，占15.78%三是建制性群体，指成建制就业于体制外单位的青年，主要包括两新组织青年，即外资企业和民营企业青年管理技术人员、中介组织和社会组织从业青年等；1.07亿，占26.19%四是原子性群体，指不隶属于某一单位而以个体形式生存的青年，该群体易成为社会管理服务的盲区，主要包括数字蓝领（外卖骑手、网约车司机、大卡车司机等）、自由职业青年、零工青年、个体工商户青年、务农青年等；1.95亿，占47.67%前四类群体为互斥关系，加总之和为青年人口整体规模。五是杠杆性群体，指发声能力强、具有引导社会舆论、意识形态能力的青年，该群体人数虽少，但动员能力强，主要包括新媒体从业青年、新文艺从业青年等；3433.25万，占8.38%六是示范性群体，指受过高等教育且就业于劳动附加值较高的新兴产业，对生活品质有一定要求，行为方式和消费品味对社会大众具有示范效应的青年，主要包括房地产、互联网、生物医药和金融领域从业青年等；5303.81万，占12.95%七是知识性群体，指受教育程度和知识资本储备远高于社会平均水平的青年，主要包括高校青年教师、科研机构青年研究人员、青年科技工作者、民间智库研究人员、青年工程师、青年律师和青年医生等；1398.49万，占3.42%八是边缘性群体，指拥有社会资源较少、舆论关注较少或处于社会主流视野之外的青年，主要包括新生代农民工、返乡青年、小镇青年、农村青年等。4615.62万，占11.27% 当代青年群体的社会政治态度第一，个体生活观。当然是学生最幸福，边缘性群体幸福感最低，但是边缘性群体的幸福感提升快（因为最后一名进步空间最大…如果国家不关注，他们也提升不了，快，感谢）第二，现实社会观。社会信任感：逾六成成长性、内生性、示范性和知识性群体认同“这个社会绝大多数人都是可以信任的”，社会公平感：过半的示范性和知识性群体认同“当前社会是公平的”，明显高于其他群体，边缘性和原子性群体的社会公平感最低（那肯定啊）。收入差距感：成长性、边缘性和原子性群体最认同“我国社会成员之间的收入差距太大了”（中间和偏下的收入的差距不大，大的是收入高的那部分），第三，网络政治观。互联网与政治赋权：逾六成杠杆性群体认为“互联网使人们有更多的政治权利”，互联网与政治参与：逾八成知识性群体认同“互联网能使人们更多地讨论政治事务”，互联网与政治素养：逾八成知识性和杠杆性群体认同“互联网可以促使人们更好地理解政治”互联网与社会资源分配：逾八成示范性、杠杆性和内生性群体认同“互联网能让越来越多的人获得社会资源”，第四，政府权责观。社会舆情管控：知识性群体认为政府不应该管控舆情，逾四成知识性群体认同“政府不应该干涉公共场所批评政府的言论”（删东西比谁都快，就差一个无敌的AI监视所有人的聊天框了）。工作生活管控：知识性群体最认同“政府不应该干涉个人在哪里工作和生活”，第五，性别平等观。男女角色认知：各群体对“男性应以事业为重，女性应以家庭为重”这一观点的认同存在明显差异，边缘性群体认同度最高（是这样的）。传统观念认知：各群体对“干得好不如嫁得好”这一观点的认同度都未过半（那每天发富婆看看我的都是什么人，没过半，我不信），夫妻家务分工：各群体对“夫妻双方应分摊家务”认同度都较高，整体来看，青年整体的男女平等观念都在上升，但边缘性群体存在较为明显的重男轻女观念，而且在某些认知上趋向保守，边缘性群体的角色观念与其他群体的差异正在拉大。 怎么“用”青年成长性群体是后备军，他们是推动国家高质量发展的建设者，是中华民族伟大复兴的有生力量。内生性群体是顶梁柱，是我们党执掌政权、抵御风险、迎接挑战的中流砥柱。建制性群体是稳压器，在青年总人口中所占比重较大（26.19%），其生存状态影响整个青年群体的社会心态。杠杆性群体是放大器，知识性群体是思想源，这两类群体发挥着辐射影响的作用。知识性群体是知识分子群体与青年群体的交叉集合体，长期的知识储备使该群体具有高于常人的思考能力，在结合专业知识的基础上，该群体发表的言论多具有剖析性、预测性的特点，往往引发社会各界的高度关注。杠杆性群体掌握着海量的社会思想动态，在话语权上有着后发优势，具有个体简单相加所不具备的巨大能量。示范性群体是时尚引领者，他们教育水平高、收入高、个人预期也高。随着经济增速下降，社会流动速率也将放缓，示范性群体很可能成为影响我国社会结构性变化的==拐点==。（因为他们在的行业都是高附加值的行业，国家最近整治這些行业，他们的收入将受到影响，他们将产生巨多的负面情绪，杠杆性群体将抓住热点为他们提供理论武器和话语支持，放大负面情绪，进而影响全社会的心态。）可以说，上述六类群体的状态决定了中国社会整体面的安定团结与和谐有序。在基本盘稳固后，国家就能有更多的财力和精力为相对弱势的群体（原子性群体和边缘性群体）提供更为丰盈系统的兜底性保障和改善性支出。 但也要看到，相较其他群体，这两个群体在各个指标上的评分依然垫底，长此以往，难免产生消极心态。随着他们的相对剥夺感逐渐增强，甚至可能抵消已经形成的政策满意度和生活幸福感。现实困境往往是激发思想和情绪波动的导火索，原子性和边缘性群体发声能力相对较弱，社会资源相对较少，但他们与各行各业连接紧密。如果生活压力持续增强，可能会激发社会矛盾。 但在性别认知、教育公平、动物保护主义、环境保护、劳动救济、计划生育等话题的讨论中，某些青年用泛道德化的标准进行群体识别和政治定性，滋生了社会戾气，加剧了群体分化。在网络规范和网络立法尚不完善的当前，对社会问题的贬抑一旦掺进道德评判的因素，就很容易将问题简单化、脸谱化、标签化、政治化，导致群体关系紧张。在不同时代不同阶层的价值观共存同一空间的大背景下，如何引领大多数青年认同主流价值观，凝聚社会观念的最大公约数，是亟待解决的迫切问题。","categories":[{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"青年","slug":"青年","permalink":"http://spcablast.club/tags/%E9%9D%92%E5%B9%B4/"},{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"乔先生的书-持续更新","slug":"乔先生的书-持续更新","date":"2022-12-20T01:37:54.895Z","updated":"2022-12-20T01:35:51.417Z","comments":true,"path":"2022/12/20/乔先生的书-持续更新/","link":"","permalink":"http://spcablast.club/2022/12/20/%E4%B9%94%E5%85%88%E7%94%9F%E7%9A%84%E4%B9%A6-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","excerpt":"","text":"金刚经 第一品 法会因由分如是我闻。一时，佛在舍卫国。祇树给孤独园。与大比丘众千二百五十人俱。尔时，世尊食时。著衣持钵。入舍卫大城乞食。于其城中次第乞已。还至本处。饭食讫，收衣钵，洗足已。敷座而坐。 朴实枯燥且无味的一天，出门讨饭，吃完回家，洗碗洗脚，躺 金刚经 第二品 善现启请分时长老须菩提在大众中。即从座起。偏袒右肩。右膝着地。合掌恭敬。而白佛言。希有世尊。如来善护念诸菩萨。善付嘱诸菩萨。世尊。善男子。善女人。发阿耨多罗三藐三菩提心。云何应住，云何降伏其心。佛言。善哉善哉。须菩提。如汝所说。如来善护念诸菩萨。善付嘱诸菩萨。汝今谛听。当为汝说。善男子。善女人。发阿耨多罗三藐三菩提心。应如是住，如是降伏其心。唯然。世尊。愿乐欲闻。 有个徒弟须菩提提问，如果有人发无上正等正觉的心，心地法门，明心见性由世俗超越而达到明成佛的境界，在行为上是大慈大悲菩萨心菩提心，入世救一切众生（就是如果有人想成佛该怎么办啊），想成佛，想自性成佛，众生没有成佛是因为找不到自己的心，迷失了，如果他觉悟了，不再迷失，就自性成佛。佛说，他都发无上正等正觉的心了，那就护住这个念。这个心念怎么住在清净、至善的境界，这个心里乱七八糟的念头怎么降伏，我来给你讲。注释：善护念，念指脑海里出现的念头，护，照顾自己的念头，照应好自己的思想，前人曾经说过“只要思想不滑坡，办法总比困难多”，维持着烦恼的念头就处于烦恼之中，维持着解决办法的念头就在成功或者失败的路上。发心：发，动机，心，念20220923 金刚经 第三品 大乘正宗分佛告须菩提。诸菩萨摩诃萨。应如是降伏其心。所有一切众生之类。若卵生。若胎生。若湿生。若化生。若有色。若无色。若有想。若无想。若非有想。若非无想。我皆令入无余涅盘而灭度之。如是灭度无量无数无边众生。实无众生得灭度者。何以故。须菩提。若菩萨有我相。人相。众生相。寿者相。即非菩萨。 金刚经 第四品 妙行无住分 金刚经 第十一品 无为福胜分 须菩提。如恒河中所有沙数。如是沙等恒河。于意云何。是诸恒河沙。宁为多不。须菩提言。甚多。世尊。但诸恒河尚多无数。何况其沙。须菩提。我今实言告汝。若有善男子。善女人。以七宝满尔所恒河沙数三千大千世界。以用布施。得福多不。须菩提言。甚多。世尊。佛告须菩提。若善男子。善女人。于此经中。乃至受持四句偈等。为他人说。而此福德。胜前福德。 他布施了无量的物质，不如将此精神传递给他人，思想上的改良，幸福的根本是思想的改变，因为思想的改变能导致社会的改变，改变成一个能让每个人获得获得幸福的途径 金刚经 第十二品 尊重正教分 复次。须菩提。随说是经。乃至四句偈等。当知此处。一切世间天人阿修罗。皆应供养。如佛塔庙。何况有人。尽能受持读诵。须菩提。当知是人。成就最上第一希有之法。若是经典所在之处。即为有佛。若尊重弟子。 这个思想在的地方，就可以说这个地方有佛了 金刚经 第十三品 如法受持分 尔时。须菩提白佛言。世尊。当何名此经。我等云何奉持。佛告须菩提。是经名为金刚般若波罗蜜。以是名字。汝当奉持。所以者何。须菩提。佛说般若波罗蜜。即非般若波罗蜜。是名般若波罗蜜。须菩提。于意云何。如来有所说法不。须菩提白佛言。世尊。如来无所说。须菩提。于意云何。三千大千世界所有微尘。是为多不。须菩提言。甚多。世尊。须菩提。诸微尘。如来说非微尘。是名微尘。如来说世界。即非世界。是名世界。须菩提。于意云何。可以三十二相见如来不。不也。世尊。不可以三十二相得见如来。何以故。如来说三十二相。即是非相。是名三十二相。须菩提。若有善男子。善女人。以恒河沙等身命布施。若复有人。于此经中。乃至受持四句偈等。为他人说。其福甚多。 同十一 他们有一个悉知悉见的佛的概念在看着他们，这个形象作为一个标准时刻约束着他们的行为,就像君子无终食之间以违仁，颠沛必于是，造次必于是，君子必慎其独也，是人为自己立法，做你认为所有人遇到这种情况都应该做这个选择，","categories":[],"tags":[]},{"title":"论文相关","slug":"论文相关","date":"2022-12-20T01:37:54.894Z","updated":"2022-12-20T01:35:51.419Z","comments":true,"path":"2022/12/20/论文相关/","link":"","permalink":"http://spcablast.club/2022/12/20/%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"MachineLearning问题记录","slug":"ML问题记录","date":"2022-12-13T16:00:00.000Z","updated":"2022-12-20T01:35:51.415Z","comments":true,"path":"2022/12/14/ML问题记录/","link":"","permalink":"http://spcablast.club/2022/12/14/ML%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一、配置清华源报错提示：Conda经典配环境报错来官网就完了清华镜像官网配清华镜像源三步：1、conda config –set show_channel_urls yes运行上述命令在c盘user目录下生成.condarc文件2、在.condarc文件中输入 123456789101112131415channels: - defaultsshow_channel_urls: truedefault_channels: - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;msys2custom_channels: conda-forge: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud msys2: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud bioconda: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud menpo: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud pytorch: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud pytorch-lts: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud simpleitk: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud 3、运行 conda clean -i 清除索引缓存，保证用的是镜像站提供的索引。 行了。 注意：如https可能会导致连接出错，报错了，改成http就行了","categories":[{"name":"报错记录","slug":"报错记录","permalink":"http://spcablast.club/categories/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://spcablast.club/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://spcablast.club/tags/windows/"},{"name":"anaconda","slug":"anaconda","permalink":"http://spcablast.club/tags/anaconda/"}],"author":"YP"},{"title":"中国底层青年的生存困境和出路","slug":"廉思-中国底层青年的困境和出路","date":"2022-11-18T16:00:00.000Z","updated":"2023-08-10T02:26:11.359Z","comments":true,"path":"2022/11/19/廉思-中国底层青年的困境和出路/","link":"","permalink":"http://spcablast.club/2022/11/19/%E5%BB%89%E6%80%9D-%E4%B8%AD%E5%9B%BD%E5%BA%95%E5%B1%82%E9%9D%92%E5%B9%B4%E7%9A%84%E5%9B%B0%E5%A2%83%E5%92%8C%E5%87%BA%E8%B7%AF/","excerpt":"","text":"廉思：中国底层青年的生存困境和出路前言：这个话题是前几个月就打算写的，有一次在b站刷到一个视频，是讲廉思先生2021.4.4的一篇文章《当代中国青年群体的思想谱系》，提到从政治学视角把当代青年分为五类，分的也比较有意思，所以挺感兴趣的，最近又翻了出来，读一读，发现21年9月份又改进了，分为了八类，没关系。在查原文的时候又发现一篇他2014年的文章，就是标题，看了一遍觉得不是像某些专家一样“把闲置的房子租出去”，稍微接地气一点。 目录：1、青年问题不仅中国有 全世界都有 2、青年向上流通渠道变慢变窄 焦虑感越来越强 3、30岁以上的北漂比例在不断增大 4、横向流动与纵向流动同时受阻就可能出现暴力革命 5、面对政治态度更加世俗化的青年，宣传工作该怎么做? 6、中国年轻人对主流意识形态消极接受、被动认可 7、做年轻人的思想工作要实现时代化的转变 8、城乡二元结构增加了中国青年问题的复杂性 9、5.4亿青年正站在中国转型的十字路口上 10、一个国家进入稳定状态 阶层出现固化是必然趋势 11、中国教育最大的问题在于让每个人都成为精英 12、寄望后人通过我们的青年研究窥见中国转型 13、原文全文 1、青年问题不仅中国有 全世界都有（标题不太对，大概就是介绍了一下作者背景，以及研究的问题背景） 作者07年开始研究大学毕业生的就业问题，09年提出“蚁族”概念，11年研究高校青年教师的生存现状，提出“工蜂”概念，14年研究在北上广务工后逃离北上广后返乡的青年，提了一下二战后国际上爆发的青年运动，青年问题逐渐显现，青年运动可能出现，所以社会学研究青年问题是必要的。 2、青年向上流通渠道变慢变窄 焦虑感越来越强（==问题一：住房问题==） 首先定义标题里提到的名词概念，“底层青年”：根据出身，社会资源和经济资源相对较少；收入并不低，但是并不能改变生活窘迫的状况，比如文中“我一个月挣一万多块钱，每个月花2000块钱，我剩下13000，我还有一个弟弟要供上大学，你算算我多长时间能买到房”提到住房又多说了一句“==一个外地的年轻人，一个月可能挣一万块钱，他在北京不敢消费，他可能要存起来买房子，为了以后能够在北京长期的定居。但是一个北京的青年人，可能一个月挣三千块钱，他有两套房，他可以做月光族==。”（注意，时间是14年）看起来中国的阶层只有一个了，有无住房；社会阶层流通的通道在变窄，甚至断裂，在这样一个社会背景下，青年的焦虑和不安在增强是正常的。 3、30岁以上的北漂比例在不断增大（==贫困的代际传承==） 中国青年的生存困境到底体现在哪些方面？随着社会的发展，人的生理性成熟提前，社会性成熟延后，大学毕业奋斗3、5年，成为中产买了房子，或者没买回老家，30岁左右就得做出抉择。影响上述抉择的条件有：住房、教育、婚姻，这些因素导致贫困的代际传承。教育：对家庭年收入和上大学的类型做相关性分析，发现家庭条件越好越有可能上重点大学；婚姻：门当户对还是很普遍的；工作：社会资源和经济资源影响找工作的难度，体制内的工作就不说了，体制外的工作还算公平。 4、横向流动与纵向流动同时受阻就可能出现暴力革命 为什么问题这么多还没有出现暴动呢？横向流动：职业、收入、声誉在地点或者其他方面的同级的流动纵向流动：职业、收入、声誉的上升或下降因为我国横向流动相对顺畅，比如去一线城市工作几年再回到家乡。横向流动的顺畅有效减缓了纵向流动变慢对社会结构造成的冲击。 5、面对政治态度更加世俗化的青年，宣传工作该怎么做?年轻人过的这么艰难，抱怨国家怎么办呢？ 现在年轻人他的政治判断有时候是基于利益诉求（大部分？），而且他们这一种政治判断有从宏大的叙事向自己身边小事转化的趋势。最近空间站宣传的很多，谁知道上去的是谁，关注的人有多少，现在年轻人会说，==天天给我们以国家发展的希望，能不能给我们以个人发展的希望==。现代青年接触到的信息太多，用一个名词来说就是知识的平权化，你想学，大部分的东西都能学到。==青年形成稳定的对事物的认识或者说价值观变得比较困难==。（看最近几年，百度热搜，微博热搜是要受管制的，百度热搜第一条的上面得放一个国家大事，b站也入驻了各地共青团，每次火箭发射、空间站活动都能上推荐位，宣传打入青年内部）现在青年的距离感也在改变，对于很多的90后、95后来讲，虚拟的世界就是他真实的世界，他不认为是一个假的世界，跟他的现实生活是一样的，是两个并行的世界，远方的可以很近，身边的也可以很远。 6、中国年轻人对主流意识形态消极接受、被动认可 从90年代那波计划生育，产生了大量独生子女，他们的经历和上一代人不同，从小他们就受全家人的关注，关注是过剩的，在离开学校进入社会后，关注一下就变成了稀缺资源，就会产生一种“看我啊看我啊”的情绪需求。从这个角度看，青年的政治判断会受到社么影响呢？年轻人对主流意识形态是消极接受和被动认可，而不会主动传播。 7、做年轻人的思想工作要实现时代化的转变（==宣传主流意识形态的更细节性的建议==） 年轻人天生是反叛的是叛逆的，他没有被你教育、被你规范的需求，但是任何一个国家，一定要在一个人年轻的时候对他引导和规范，让青年成为社会的建设力量，而不是破坏力量。所以宣传要以满足年轻人的需求为主，宣传和意识形态是副产品。大人物讲小故事，老人物讲新故事：比如讲习大大吃包子；讲雷锋是一个普通人，他没有那么高，高的我们摸不着，他离我们不远，你上你也行。 8、城乡二元结构增加了中国青年问题的复杂性中国社会底层青年所面临的问题，与其他国家/地区相比有没有特别之处？ 特别之处在于，一个是中国大的背景是城乡二元结构。在城中村里有很多大学生，这些人漂泊异乡，这个世界的历史绝大多数是由这些漂泊的无根之人创造出来的，这样的年轻人有1.5个亿。1.5亿的人，平均的户数是3户，爸爸、妈妈，还有一个老人的牵挂，4.5亿人的牵挂。 9、一个国家进入稳定状态 阶层出现固化是必然趋势面临很多问题的中国青年，这样一个群体对中国的政治和社会稳定的冲击在将来会出现什么样的变化和影响? 首先是国家对青年人的定位是合格建设者和可靠接班人；当然我们说现在网络的舆论，媒体很发达，青年发声的机会更多，而且现在由于我们社会发展的壮大，所以也可以预见到一个趋势，未来体制外青年群体会发力。（没事儿，都封号了）中国初步统计15岁到19岁的青年是5.4个亿，这5.4个亿青年的群体，他的影响力实际上是任何国家都没有处理过的，没有面对过的。前几年有一个帖子非常有意思，我奋斗了18年才跟你喝咖啡，尽管喝的是同一杯咖啡但是喝的味道是不一样的。（这个梗怎么感觉时间不长，是大家对网络上热梗的时间感觉都很迟钝嘛）当然说它的影响的走向，从微博到微信，这样的网络化的工具应该是年轻人最先使用的，由于知识技术和年轻人这样紧密的结合，这是任何历史时代所没有的，也使得我们青年的价值观更加多元，更加多变。青年的发声能力更强。所以说后移时代向前移时代的转化是必然的，年轻人这样的价值判断跟以前的年代完全不一样，但说具体的，它会往哪个方面发展我们要拭目以待，根据具体的情况做出判断。（2022年了，往哪个方向发展了，我起了，一刀秒了，还能怎么说嘛，摆） 10、一个国家进入稳定状态 阶层出现固化是必然趋势（==造成阶层固化，阶层断裂的原因==） 一个国家他进入了稳定状态以后，阶层出现固化是一个必然趋势，所谓固化为什么会出现，就是处于每一个社会阶层的人，他一定对自己的发展有一个心理预判，预判就会相对的固化下来。但是中国人的平等观念从“王侯将相，宁有种乎”就有了，“我上我也行”谁都能喊，都想往上；作者认为，以后长途的流动会越来越少，短途的流动会越来越多，你可以先考上985，回省城发展，你的后代再往上。所以我们说纵向流动的加强，加强高等教育从各个社会阶层选拔出精英这样的机制，==大学应该成为保守社会德行的底线，而不能再成为社会利益分配的工具。高等教育它应该是一个社会公平的平衡器，而不是社会分化的加剧器==。（所以高考加分去了一些，自主招生也去了一些，公平，只能功公平一部分）我们各项政策实际上的目的是让所有年轻人生存的有尊严，大部分的年轻人发展有希望。你要给年轻人一个看得见的未来，这个未来不能太远，他才会往上走。（2022了，未来，emmmmmmmm） 11、中国教育最大的问题在于让每个人都成为精英对于那些正生活在或者正在奋斗的底层青年们有什么样的建议 看本节标题就知道了，学会做一个普通人，做好一个普通人。要相信奋斗和成功相关性不高，现在的社会是努力奋斗不一定成功，但是不努力不奋斗一定不成功，而且那个成功和你想的成功不一样。蚁族最缺的就是关系和资源，回去之后发展更受阻滞。首先要对自己有一个评估，盲目的探索、坚守还是逃离没有意义，要根据个人的状况来看，还要根据自己的发展状况去定位、去比较、去琢磨，然后才能确定你自己人生的方向。而且你在选择行业的时候，包括你自己创业的时候，也要经过多方面的考虑，自己去斟酌和打磨。我们的精英就是这样的教育，就是成败的教育，我们没有教会一个人如何用平和的状态成为一个社会的普通人，成为一个社会的公民，我们对成功的定义理解的太肤浅了。(行吧，这年头普通人的生活也不太对劲了) 12、寄望后人通过我们的青年研究窥见中国转型青年的作用也取决于我们现代人如何去对待他，从长远的观点来看，这个世界是属于年轻人的，任何掌权者或者决策层只不过替下一代人来代管，你管的不好年轻人当然不满意，他要起来，因为你让年轻人安分是有前提条件的，前人栽树后人乘凉，年轻人相信你，你留给他的世界是更好的。 但是如果他觉得你把蛋糕都分完了，到我这儿我连汤都喝不到，我的上升空间都没有了，我当然不满意，我就要爆发。华尔街青年运动中提出的口号，你们有背景的人占了我们99%的财富，我跟你一个学校毕业，我不比你差，只不过就是你的爸爸比我爸爸强。社会对青年开放的程度，渠道放开的程度，其实决定了一个社会的活力，是社会活力重要的评价指标。现在我们的社会由固态中国向流动中国的变化，你不让年轻人进入实体平台发言，他会有虚拟的平台发言。我们一定要让青年多去发声，这一点我们的渠道是窄的，我们的政治参与的渠道，利益诉求的渠道，都是有待加强的。 ps:我以为，我高中的时候一直以为，两个一百年要靠我们这一代的年轻人来实现，但是怎么看这些人都不怎么靠谱的样子，这个问题经常出现啊，我就想，前些天突然想明白了，跟我们有什么关系，都是工具人，上面有人决策，下面只能做；然后又看到了阿迪带头抵制新疆棉之后，在中国的销量是稳步下滑，所以好像在这个时代人民还是有力量的，互联网也是有记忆的，还有今年的停贷事件，所以社会的变化要从思想的变化开始，思想这个东西是比新冠隐蔽的，传染性也更强的，每个人都在参与。 以下系在线文字稿全文： 主持人：“底层青年困境和出路”这期在线预告发布以后，有个网友发布评论说”共识网终于开始关注青年问题了”，我把这理解为读者对共识网的委婉批评，确实，共识网在这个问题上的关注显得很不够。 因此，今天我们特别请到国内青年问题研究专家，”蚁族”一词的最早提出者，对外经贸大学教授廉思老师，同共识网的广大网友就”底层青年的生存困境和出路”这一话题进行探讨。 应该讲，廉思老师在这一块做了很长时间的研究，而且出了像《蚁族》、《工蜂》等一系列研究成果。关于底层青年这样一个群体，我相信很多人都不会感动陌生，因为在现实中我们身边就有不少这类人群，特别是在北上广这样的大城市。但同时，我又注意到，真正深入做这块研究的人又不是很多。 廉思：确实如此。 青年问题不仅中国有 全世界都有 主持人：首先，我想请教廉思老师的第一个问题是您最初是怎么想到要研究这样一个群体的? 廉思：应该说，选择研究底层青年这个群体是始于2007年，那个时候，我看到一篇新闻报道，谈到了北京市周边的村子，居住着一些大学毕业生，并且在报道里边讲述了几个大学生的故事，这个报道对我触动不小。 在2007年，大学毕业生找工作的困境还不是特别凸显，对于他们的生存状态关注的人也不是很多。于是，我去到了那篇报道里边提到的村子–也就是后来为很多人所熟知的的唐家岭。进到这个村子，我看到很多年轻人，一问都是大学毕业生，但是，他们为什么在这儿聚居，那个时候我还不了解。 但我注意到，这个村子同北京其他城乡结合部的村子不太一样。在这儿，房屋的出租广告可以没有独立的厨房和卫生间，但是一定要有网络。一开始是一个好奇心，对此也不是很理解，因为这跟我通常意义上的大学毕业生，我们日常看到的报纸媒体所宣传的天之骄子的感觉反差很强烈。 有了这样一个基础认识，也因为对自己触动比较大，我开始专注做这块研究。到2009年，我们出了第一本书《蚁族》，讲了大学毕业生的一些生存状况，从这本书以后，国家对就业问题的重视，对大学毕业生生存状态的重视比以前有了高度的转化。 再后来，到了2011年，因为我是一个大学的青年老师，切身体会到了很多青年教师在高等教育中遭遇的怪现状，包括科研的问题、评职称的问题、教学的问题等等，我觉得这是一个非常严肃的问题。于是，2012年我们出版了主要讲述高校青年教师生存现状的著作《工蜂》，因为这个群体并不像蚁族那样，社会公众对他们的了解并不多，并且存在不少误解。大家会认为，老师很体面，有两个假期，收入也不少，但实际上这个群体同样活得很苦。现下的体制，某种程度上使得这样一群人变成了知识民工，跟蚁族一样，同样是”底层”。而知识分子是一个国家创新的动力源泉，他们代表的是一个国家的精神面貌，所以，我们觉得有必要将他们作为一个群体来单独研究。 此后，我们又做了新生代农民工、青年白领方面的调查和研究，今年上半年我们还做了很有意思的一个群体–洄游青年。前几年有一个争论，说逃离北上广，那么逃离后到底怎么样?比如，前几年，我做蚁族研究的时候就有人跟我说，在北京干那么多年，一过春节回家，小学同学都是开着大奔来接我，于是不少年轻人选择了逃离北上广，回到老家。到底年轻人回去过得怎么样，我们只是听到一些零星表述，没有做过系统化研究。基于此，从去年年底开始到今年上半年，我们就选了22个县，做了返乡青年的调查，我们叫洄游青年，像鱼类的洄游一样，看看这些人的个人变化对当地社会经济发展的影响，尤其是研究了这种大的迁移经历对年轻人价值观的冲击，以及他们以后的发展方向的影响。 应该讲，我们这个团队自从做了蚁族研究以后，大家对这个方向也越来越感兴趣了。一方面，我们注意到原来的青年问题，从社会学角度来做的研究偏少，另一方面，近几年来青年问题越来越在社会中凸显出来，不仅仅是中国问题，而且是一个世界性问题。 二战以后的青年运动有过几次浪潮，一个是在20世纪60年代，中国当时正值文化大革命，红卫兵、红小兵纷纷登上舞台，在法国则发生了六月风暴、在美国也爆发了学生运动;第二次浪潮发生在80年代末期，这个时间是以意识形态为主的一些学生运动，此一时期的中国同样出现过了类似情况;进入21世纪，出现了第三波青年运动浪潮，这次跟前两次有很多很明显的区别，它并不是以意识形态为主要特点。这样的一些青年问题，及其青年运动的出现，对世界各国政府都提出了严峻的挑战。正是在这样的大背景下，青年问题凸显出来，逐渐回归社会学主流。 青年向上流通渠道变慢变窄 焦虑感越来越强 主持人：我们今天讨论的主题叫底层青年，要说底层的话，我相信很多人心理上会有这么一个概念，可能是生活条件比较差，收入比较低，生活现状没那么好的这么一个群体。但是，它到底是怎么样一个群体，好像还没有几个人能说得清楚。 正如我们一位网友在提问里边说的那样，”底层青年的说法好像说的是社会中处在末端的一小部分人，但其实中国青年绝大部分都是属于这个群体，白领和农民工的身份特征(生活现状)越来越相似，命运也将渐渐走到同一条路上”。 那么，您能在这儿大概介绍一下这样一个群体的基本特征吗?这一群体又大概涵括哪几类人? 廉思：在我们的学术研究中，原来比较避免出现像底层群体这类的判断，因为我们认为它的外延是比较模糊的，而且，从社会学角度来讲，它也不是一个特别严谨的学术概念。但是，确实很多人有底层的感觉，或者说底层的认知，而且越来越强烈。当然，从我们这几年的研究来看，总体上也验证了这样的认知和判断，不少人都觉得自己的生活越来越艰难。尽管从经济状况上来讲，比方说像我们去年发布的新生代农民工报告，北京的新生代农民工月平均工资是2500块元左右，蚁族的月收入从今年和去年的调查来看都已经是4000多块钱，今年都接近5000元了，收入并不是特别低。 很多人说农民工和白领的差距在缩小，其实这里边有其他一些因素在起作用，青年群体本身他正处于人生的上升期，在这样一个特定的人生阶段，他本身的社会资源和经济资源就相对较少。应当讲，一般的年轻人或者大多数年轻人他没有很强的家族资源，尤其是中国现在贫富差距这么大，青年人难免会有这种感受，这是第一点。 第二，即使是青年人，也有不同的社会层次和社会群体，像蚁族、白领和农民工，他们的感受就会有差别， 在青年的时候，我们要强行的分开他不同的社会层次和社会群体，像蚁族、白领和农民工，他们之间，我们发现现在也会有差别，但是有些方面也有共同特点。比如说像蚁族，我们确实碰到过一个月挣一万多块钱的蚁族，也住在聚集村。很奇怪，说廉老师我一个月挣一万多块钱，每个月花2000块钱，我剩下13000，我还有一个弟弟要供上大学，你算算我多长时间能在北京买到房。他的月供可以自己出，但是首付一定要自己给。但是对于绝大多数出生在农村的人来说，他连首付也是付不起的，一定要自己出，这种情况会延续到35岁，他会在相当长的时间段内经历这样的情况。所以我们可能要重新定义贫困，贫困严格意义上讲叫无行为能力，老人、小孩或者残疾人吗，可能都不能解释。他的收入并不低，但是并不能改变他的生活窘迫的状况。我们现在还可以说白领和农民工有区别，但是白领和蚁族基本很难划分。我们调查中确实是在北京的金融街、CBD周围出现了一些聚集村，这种情况在武汉也出现了，所以并不是个案，我们给他们起了一个名称叫在职贫困。 如果有一天你一旦生病或者不工作，一下子进入贫困状态。有一点很有意思就是住房，由于住房的存在，它会压缩你生活的所有开支和成本。也就是说，住房资源一旦弱势，会导致你成为弱势群体。而且由于住房上你处于弱势，你不敢消费，不敢买东西，甚至不敢结婚。这一点特别明显。一个外地的年轻人，一个月可能挣一万块钱，他在北京不敢消费，他可能要存起来买房子，为了以后能够在北京长期的定居。但是一个北京的青年人，可能一个月挣三千块钱，他有两套房，他可以做月光族。社会学上划分人的阶层有三个标准，职业、收入、声誉，在中国目前来看很有意思的是就只有一个标准，就是住房，尤其在特大型城市这种感觉特别强烈。这样穷忙族的感觉在青年中尤其更甚，这几年我们也确实能感觉到青年向上流动的通道在变慢变窄，也出现了社会阶层的断裂的情况。 在这样的一个大的社会的背景下，青年的这种焦虑感和他的不安感在增强也是可以理解的。 30岁以上的北漂比例在不断增大 主持人：您刚才讲的这些我自己就有亲身的感受，我相信很多人都跟我有差不多的状态，在北京白天到一个公司体面的上着班，晚上回去住在群租房里，而且有可能还要住得相对偏一些，或者说住在像您刚才说的CBD旁边的城中村里。 下一个问题，关于这样一个群体的生存状态，刚才您随口就提了很多实证的调查材料。那么，据您研究，中国青年的生存困境究竟体现在哪些方面。您刚才说的主要是住房问题，我们中国古代人讲三十而立，但实际上我们发现在大城市三十不立是正常现象，而立的则很少。 廉思：应该说随着社会的发展，人的社会性成熟在后移和生理性成熟的前移，这是一个必然的趋势。所谓说从人的青年期的界定来看，也就是不同的社会或者不同的结构、不同的组织有不同的界定，联合国有了最新的界定称到44岁，也有的国际机构的界定到60岁都是青年。无论怎么界定，所谓的青年期是生理性成熟的前移，包括女子和男子性成熟一些特征的前移，还有人的社会性成熟的后移。所以您说的三十不立，其实就是他的社会性成熟比较晚，这个时间段其实我们都应该叫做人的青年期。 从我们近几年做调查来看，蚁族是我们连续做的调查，连续做了5年的调查。原来我们最早2009年做研究的时候，有一个判断叫三十而离，一般22岁大学毕业，或者23、24研究生毕业，奋斗个3年、5年，如果我从蚁族中脱颖而出成为中产了，我买了房子，到真正的社区去长期的居住，要不然就是回到老家。我们发现一般30岁的时候会给自己做个抉择，不会结婚了还住在群租房里。从去年的调查来看这样的情况在增多，30岁以上的蚁族比例在增多，结婚的蚁族在增多，这都是很明显的一个群体。原来我们很难想象30多岁了还当北漂，现在比例在不断的增大。 困境一个是住房资源的问题，包括对于很多的年轻人，我们特别关注的是这样的一种贫困的状态在代际之间的传承，你的父辈生活在农村或者县城，当你来到大城市之后，你发现你的社会资源和经济资源无法跟大城市的年轻人相抗衡，这样传承的一个根本性的问题，就体现在你的住房贫困，你的教育贫困，你的婚姻上等等。我们大家都很清楚，由于你的家庭的贫困出现了代际的传承，导致了你住房买不起，首付付不起，各项生活都在延续。在蚁族中我们去年的调查表明，即使在蚁族这么一个群体，我们做了一个相关性的分析，把蚁族包括父母在内的家庭年收入和蚁族所上的学校，我们首先就学校的级别做了一个相关性分析，发现你的家庭经济条件越好越可能上研究生，其次是本科，家庭条件差上大专的可能性最大。我们把父母的家庭年收入和学校的类型也做了相关性分析，发现家庭条件越好的越有可能上重点大学，也是呈递减的趋势。所以你会发现你的父辈的职业情况、教育情况，会影响到你的发展。这是教育方面。 然后是婚姻方面，尽管大家都不说，但我觉得现在门当户对的观念在社会上还是比较普遍的。这是一个根本的问题。我们非常清楚，现在找工作的时候，对于城里的孩子来说他的社会资源和经济资源会助力他找工作的过程，尤其是在一些体制外的行业，考试的方式还相对公平，在一些体制外的行业中就更明显了。所以找工作会造成他各个方面成为弱势的情况，其实根源在于整个社会的流动性出现了一定的阻滞。 横向流动与纵向流动同时受阻就可能出现暴力革命 廉思：去年我们一直在做国际青年运动方面的研究，也有人提出这样的一个问题，说廉老师为什么中国青年出现这么多的困境，仍然没有爆发特别大的革命暴乱，或者说叫社会运动。为什么没有爆发社会运动?有一个对比性，就是突尼斯。突尼斯的经济发展水平跟中国很像，在世界排名比中国还靠前，突尼斯爆发革命之前，他的大学毕业生的失业率据世界银行的统计高于52%。突尼斯跟中国的经济发展水平特别像，还有一点跟中国非常像，经济好了以后干了一件事，大量扩招大学毕业生，所以他的所谓的暴乱就是大学生卖水果摆摊，被城管发现了，然后点燃自焚，最后传到脸书上。中国为什么没有发生?中国横向流动的相对顺畅，有利减缓了纵向流动变慢对社会结构和政治稳定的冲击。这是我们一个判断。 我们认为一个社会的结构流动性分为两种，一个是横向流动，一个是纵向流动。纵向流动有三个关键词，教育、阶层，年轻人都想通过上好大学，找到一个好工作，最后实现阶层的跃升。对于很多的年轻人来讲，我们最新的调查表明，蚁族，包括白领，他们跟之前相比，他们坚守在北京的执著程度在下降。我们有一个问题问他们是否坚持在北京买房，2010年35%多，现在已经20%多。 主持人：我身边就有几个朋友在北京工作，收入还可以，但是他们选择在家乡的城市买房，在北京供月供。 廉思：其实我们发现一个有意思的现象，一种情况是我的父母在农村，我在北京工作，但我以后安家是在二、三线城市。这是一种新的结构，我以后的发展在廊坊或者保定或者我家乡的地级市。还有一种是实际上我在北京，如果他这儿有我的上升通道，我先平移到一个稍弱一点的城市，先横向流动，再纵向流动，回游青年就是这个道理。我在北上广干了5年，开阔了眼界，再回到家乡。恰恰是中国横向流动的相对顺畅，还比较容易，有效减缓了纵向流动变慢对社会结构造成的冲击。突尼斯太小，没有横向流动，只有纵向流动，他的横向流动就只有出国了。研究中国问题有一个视角很重要，中国的面积大是他的弱势，也是它的优势，空间大就可以替换。这样可以实现先横向流动，凡是在历史上发生大的暴力流血冲突或者大的暴力革命的时候，关键的时间点，包括英国革命、法国大革命，都是这个社会当时的横向流动和纵向流动同时受阻，那就没有办法了。所以从十八届三中全会我们的决议精神来看，中央对特大型城市是严控人口的，但对中小城市是放开人口的，实际上横向流动是加强了，是要打破这种壁垒。所以说怎么缓解青年的问题，其实原则上来讲就是一方面要增强纵向的流动性，一方面要继续保持比较高的横向流动的顺畅。这两方面都要做好才可以。 面对政治态度更加世俗化的青年，宣传工作该怎么做? 主持人：听了前边讲的，总体感觉中国的年轻人相对过的还是比较艰难，所以在这些人当中难免会出现对国家或者制度抱怨的情绪，不知道您怎么看待这样的情绪? 廉思：我们认为现在年轻人他的政治判断，可能跟我们之前的感觉不太一样，会有所区别。刚才您谈到年轻人的抱怨，有一个词叫愤青，也体现出他对社会这样一种担忧的感觉。年轻人的政治态度跟老一辈的政治态度不同，据我们在这几年的调查中发现，年轻人的政治态度更加世俗，他有的时候不太习惯或者不太愿意用老一代的主义或道路的方式来表达他们的政治观点，他们更现实。所以有的时候他的一些政治判断是基于利益诉求。马克思说过思想一旦离开利益就会让自己出丑，其实也是这个意思。他们的政治判断是跟他们的利益诉求紧密结合在一起的，而且他们这一种政治判断有从宏大的叙事向自己身边小事转化的趋势。 比如神五的时候，我们都知道飞行员杨利伟上天，神十谁是宇航员，年轻人很多都不知道。能够明显的感觉到宏大叙事对年轻人的激励作用存在边际效益递减的现象。现在年轻人会说，天天给我们以国家发展的希望，能不能给我们以个人发展的希望，天宫一号对接了老给我们讲太阳系的事，离我们有点远，我们明天工作怎么办。出现了这样一些变化，这样的变化使得他对国家的认识也出现了变化，愤青还是前几年比较火的概念，这几年的概念改成了吐槽。愤青有的时候有民族和国家的担当感，吐槽往往是自己的事，买不起房子，找不到女朋友。所以你脱离开青年的利益，去跟他理想信念，有的时候是脱节的。说大一点，这种思想政治工作青年是不欢迎的。年轻人跟我说廉老师你有理想，你们全家都有理想，你们全社区都有理想，还有的年轻人跟我说，别跟哥谈理想，哥早就戒了，我说你戒的有点早。 对于这样的青年是跟利益相关的，所以我们要根据青年关注的问题去切入，才能真正的把握住他思想上的一些动态。而且我们确实也注意到，青年的思想状况，他的谱系是多元的，我们不能一概而论，不同的青年不一样。比如我们做的返乡青年，像农二代，在国企工作的那些青年对党史的认可度，对没有共产党就没有新中国的认可度很高，但是这样的状况可能已经不能原原本本的搬到某些青年上，他对于很多意识形态的认识是多元化的。我们必须认识这样一个社会现实，当代的青年他处于一个中国历史上最复杂的时期，各种思潮，民粹主义、自由主义、新儒家、新左派等等，都在围绕着他，在发挥作用。所以你能发现青年价值观的这种波长变得非常短，原来的波长是长的且相对稳定，现在波长变得很短，无疑让青年们形成稳定的对事物的认识或者说价值观这样的可能性在降低。所以这是我们要认识到的。 我刚才说的是青年对国家的态度转换很快。比如说碰到重大节点的时候他可能表现的很左，可能有的时候他表现的就不那么的左，年轻人会把爱国和爱党有的时候分的很清楚，有的时候就分不清楚。这种状态确实是多元并存。还有一个是互联网，这个千年未有之工具，它直接导致中国的大变局，使得知识的平权化迅速的出现。原来老师和学生的关系非常的明显，我是有知识的一方，所以我有话语的解释权，现在不是。现在我给学生讲课的时候，他举的例子有的我都没有听说过，所以对我们的知识权威形成很大的威胁。我们林林总总能够感受到青年对权威人群有咄咄逼人的抢班夺权。在某些行业，最明显的就是IT业，信息产业，有大量原创作品的产生，大量APP的作品，金融行业，有多少千万富翁都是年轻人。我们所谓的体制内的人可能是最脆弱的。 包括我们的媒体，可能还在为这样的一种东西进行渲染等等，其实也反映出年轻人这样一种变化。再往深了说，年轻人这样的一种变化，跟他的成长经历有关系。我们确实不能说现在十年是一代人，我们原来给过一个判断说五年就是一代人。去年和前年是这样的判断，今年不是，两年、三年就是一代人。变化太大了，因为年轻人的时间感在改变，我们这批人是70年代和80初这批人，那个时候中国社会虽然改革开放了，但是那个时候的变革80年代是相对慢的，90年代以后，尤其近20年发展特别快。小时候对时间的认识就不一样，现在年轻人小学毕业以后，过两年可能小学都没了，这么一个变化，对时间的改变，更容易让人做出放弃或者改变的决定，你跟时间的心理契约在改变。而且那个时候70年代、80初的人是看电视剧长大的，主角一定是收获最多的，背景一定是非常好的，但是现在年轻人是网络的一代，强调及时反馈的机制，使年轻人的频率变得更短。所以你看85后、90后正式进入职场，你跟90后谈话你不能说你跟我一块创业吧，5年以后我的公司上市了你就是千万富翁，他说你别忽悠我，5年后你在哪儿我都不知道，你就告诉我我一个月能拿多少钱。 他们的距离感也在变，现在有APP的技术，这个技术的出现为年轻人提供了无限的舞台和可能，他使得人们潜意识的东西爆发出来了。而且在网上年轻人的观念跟老人是不同的，它是一个平层化的东西，一个年轻人可能因为一个俏皮的话直接跟网络大V叫板。但他会把网上他的感觉推移到现实生活中去，这就不一样。对于很多的90后、95后来讲，虚拟的世界就是他真实的世界，他不认为是一个假的世界，跟他的现实生活是一样的，是两个并行的世界。 中国年轻人对主流意识形态消极接受、被动认可 廉思：1980年以来我们国家实行一项政策叫做计划生育政策，1999年我们实行扩招政策，这两个政策同时出现影响了一代人的价值。到80年代一个家庭只生一个孩子，到了1998年、1999年好不容易考大学了，社会上好多人考不上，他在社会中建立他对社会的认识，是通过严格的规章制度来形成的，学校不是，结果又扩招了，大部分人进入学校，所以他的社会化时点又延后了4年或6年。所以大学里是宽容是包容的，你到社会中去是集体主义，学习是个人的。又导致了你的社会化过程在延缓，这一路下来你都被所有人在关注，所以关注不再是一个稀缺的资源，而是迅速过剩了，一个人在家庭里原来是一个以老年人为核心的时代，听父母的话，现在每个家庭都一个孩子，爷爷奶奶姥姥姥爷都关注你，他会把这种角色推演到职业当中去，就会产生了一种“你为什么不点赞”的情绪需求。我干这个事领导怎么没关注过我。我们做过一个职场的调查，如果老板做出一项让你满意或者让你感到高兴的改变是什么，排第一的不是加薪，而是他们要受到更多的关注。能看出距离感、时间感的改变对年轻人价值观的影响，当然也影响了他的政治的判断。 我们在做宣传工作的时候就会出现一个状况，感觉年轻人不像原来那么好把控了，年轻人对主流意识形态是消极接受和被动认可，而不会主动传播。你问他拥护中国共产党吗?拥护。听说过社会主义核心价值吗?听说过，挺好，出现一种叫被动认可但不主动传播的现象。我们的文化产品整体是很粗糙的，非常粗糙，美国我们认为也宣传他的意识形态，美国好莱坞大片就是他意识形态的最佳宣传，但你看美国是怎么宣传的，做的很细，很到位，很精准。美国的宣传，我们经常开玩笑，《美国队长》那部电影，他那身衣服就是意识形态，美国的意识形态，穿着美国的国旗。前几年有一部电影叫《复仇者联盟》，集合了所有美国的英雄，蜘蛛侠、绿巨人。领导者是一个最差的美国队长，为什么他当头?很明显不是他能力强就当头，是他穿的那身衣服决定了他必须当领导者。美国人通过这样的宣传告诉年轻人，它在有意的引导年轻人。 我们认为价值观是多元的，中国的价值观有自己的理论自信、制度自信，西方有西方的，但是表现形式在价值观的推销和技术上是有差别的，美国的技术是强的。在这种情况下价值观可能没有差别之分，但技术有强弱之分，导致技术强的价值也强，因为他会宣传，你不会。而且美国现在对电影的配置，我看过他们的研究资料，已经细到了百分之多少电影要出现一个笑点，因为是高度工业化，所以对年轻人的心理需求非常的精准。导致年轻人对我们的主动宣传相对是有排斥心理的。我们经常打个比方，美国是爱情片里面插播主旋律，我们是主旋律里面插播爱情片，能一样吗?你怎么做到润物细无声，这才是我们今后跟年轻人去交流的一个特别重要的方面。 做年轻人的思想工作要实现时代化的转变 主持人：刚才廉老师其实是讲了一个核心观点，那就是，主流意识形态对青年人的说服力正在减弱这么一个趋势;还提到，在主流意识形态里，有不少东西本身是好的，但是它没有一个很好的形式去展现。在这一块我想问您，您有没有一些更细节性的建议。 廉思：其实我个人认为，我的一个总的感觉其实就是对年轻人做意识形态的宣传，我们得了解年轻人喜欢什么样的文化产品，满足年轻人求知的需求。电影大片、流行歌曲满足年轻人的视听盛宴，大部分唱的都是感情，恋爱的事，比如你看陌陌、人人网满足年轻人社交的需求。它都是满足年轻人一定的需求，但就出现一个悖论，年轻人天生是反叛的是叛逆的，他没有被你教育、被你规范的需求，但是任何一个国家，一定要在一个人年轻的时候对他引导和规范，这代表着一个国家社会管理是不是成熟的标志，要把他纳入到你的体系，成为社会的建设力量，而不是破坏力量。但是青年人本身没有这个需求，被你要求，被你规制，被你教育，所以我们一定要了解我们给年轻人做工作，我们的主产品一定是满足青年人需求的，而我们的宣传和意识形态是副产品。有的时候我们要降低意识形态的作用，把意识形态的作用隐性化，反而会突出意识形态的效果。 管仲说把税藏在价格里，使人们体会不到，即“取之于无形、使人不怒”。我们做年轻人的思想工作，就是要做到“用之于无形，使人不厌”。具体从策略上来说，比如说个人要实现几个转变，一个叫做时代化的转变。你跟年轻人谈一些我们中国传统的核心价值体系的东西，你要有转变，中央可以提12个词、24个字，你给年轻人死记硬背，那不行，我们给年轻人要有时代化的转变。比如看看美国是怎么做的，拍史诗性的浪漫性的，为什么要拍西部片，大的背景是美国的五、六十年代垮掉的一代，在这样的状况下出现了许多负面的思潮，那个时候美国极需要振奋美国年轻人的精神，也就是冒险、奋斗。这几年美国在做什么，从911以后，美国明显在做反恐片，连超人都回来了。蜘蛛侠有一句话叫做“权利越大责任也越大”，像《变形金刚3》中变形金刚站在埃及金字塔上，世界警察的感觉特别强烈，所以他的时代话语在转换。不是直接告诉你，你要讲责任，你要创新，而是用这样的形式用时代的话语来告诉你。但是改革开放30多年了，我们中国发生了这么翻天覆地的变化，但是我们的宣传话语体系呢，变化并不大，还是逻辑的推理与演绎。所有的理论推导都是概念性的，年轻人接受起来当然困难，他不喜欢，所以你要实现一个转化就很了不得。所以这里面我们需要探索新的艺术形式和艺术载体。 比如说我们中国人都重视家庭观念，80年代家庭观念是我奋斗，我挣钱，现在年轻人的家庭观念有变化了，年轻人会说你别跟我说你去挣钱了，我需要的是你更多的陪伴。同样是家庭观念内涵也在变化，但是我们的作品没有反映出这种变化。我们经常叫做小人物讲大故事，大人物讲小故事，老人物讲新故事。你讲习大大去吃包子，就比讲他开会更能引起年轻人的喜欢。动漫节上还出现了领导人的卡通漫画，年轻人很喜欢。大人物要讲小故事，看看习总还给彭丽媛打伞，就很感人。好多美国电影都是屌丝，一旦成为英雄就拯救地球了，他宣传的是每个人都可以做到，你也可以做到。 我们过去的一些故事，像雷锋，你怎么来看待他，近几年有很多对雷锋的质疑，雷锋有很多摆拍的照片。比如说雷锋还能买皮衣服，挺有钱啊，还能骑摩托车。原来我们做过一个雷锋的座谈会，学生提出这样的问题，雷锋日记里面写，雷锋扔手榴弹扔的不好，自从读了毛泽东选集，扔手榴弹一下扔远了，学生说我们在毛泽东选集中没有看到有关扔手榴弹的阐述。怎么看待这些问题。还有包括雷锋的几次捐款，年轻人对他有怀疑，我们针对年轻人的特点也跟着年轻人变。雷锋本人是个很纠结的人，他一个很普通的年轻人，他也想做但是没有办法，最后我们叫做一件皮衣的烦恼。包括扔手榴弹的事，他这个人很有哲学思想，他是从毛泽东选集里看到了一些辩证法，知道怎么去运用它。雷锋开始是不愿意记者采访他，记者说你摆拍照片，后来军队的人说这是首长的任务必须采访你，他才同意的。 雷锋也是在那个大的时代背景下非常向上的青年。我们把这些事情全都呈现出来以后，学生说雷锋不远，雷锋我们定义是阳光帅气、真诚友善的邻家大男孩，雷锋不是大官，就是一个普通人。所以雷锋做好事他不觉得是高尚的，他觉得是快乐的，所以要把老人物讲出新故事来，年轻人才会喜欢。 那我们怎么宣传雷锋精神，你还扶老太太过街吗?老太太都被扶的绕三环好几圈了，你得加入时尚的内容、公益的内容、环保的内容，你得有新内涵，所以老人物要讲新故事。大道理不如小故事，小故事不如小经历，老人物要讲出新味道，年轻人才能真正的去喜欢，愿意去了解。这一点我们觉得是很重要的。因为说实话从目前全世界大的情况来看，年轻人的这样反叛心理，从我们目前对国际青年的一些研究来看，这样的心理其实不是在减少，而是在增强。 英国青年骚乱，有一部分年轻人，大家都很奇怪，一条街除了书店没被抢，其他都被抢了，很多年轻人到一个超市里就为了抢几罐奶粉，我们说英国青年出现了青年病，贬低自己的国家和民族，赞扬别的国家和民族。这是英国青年的一个状态。英国这样老牌的资本主义国家，甚至在二战中都没有被击倒，那为什么现在反而青年问题解决不好。法国更不用说，一个法国官员曾跟我说，法国五月风暴，每到五月份青年人烧汽车、烧国旗，都成节日了，年轻人就是这样的表达自己。世界上很多国家都没有处理好年轻人的问题，青年人对自己国家的主流意识形态反叛的情绪，内心的排斥心理其实是在增加的。 包括去年有一本书叫《权威的终结》，讲的一个理念，现在天主教会都很难招到年轻的神父了。天主教会教义太古板了，他不愿意来，连神父都招不到了。所以你可以看到青年人这样的意识是在增强的，这让我们在做思想政治工作的时候更深入到青年的细微之处。我们的组织渠道也在拓展，党团、班级或者是街道这样的组织行不行，我们是不是可以通过其他的渠道去做，比如青年社会组织，青年之间根据兴趣爱好结成不同的团体，我们是不是可以根据这样不同团体的渠道去深入青年，去做他们的思想政治工作。 城乡二元结构增加了中国青年问题的复杂性 主持人：有一个网友也意识到，世界上不单单是中国的青年压力大，其他国家的青年人压力也大，日本、台湾的青年有各式各样的压力。底层青年出现的困境有可能是全球性的问题。他还问中国社会底层青年所面临的问题，与其他地区相比有没有特别之处。 廉思：特别之处在于，一个是中国大的背景是城乡二元结构，造成了中国处理很多问题的高度复杂性。城市青年、农村青年，还有洄游青年，这就创造了无限的可能，也给我们的社会管理造成了很多的难题和难点。刚才咱们谈到聚集村，原来我们的概念聚集村就是一个贫民窟，是不好的。我们自己反思，在城中村出现了新的落脚的人，这些人都是大学毕业的人，或者是从外地来到北京打工的，他们步入城市是困难的，在这里暂时的歇脚，所以我们不能把它看作是一个贫民窟，它是城乡转换，或者是底层向中层的转换器，它是一个发动机，没有它城市的活力就不在了。这个世界的历史绝大多数是由漂泊的无根之人创造出来的，这样的年轻人有1.5个亿。1.5亿的人，平均的户数是3户，爸爸、妈妈，还有一个老人的牵挂，4.5亿人的牵挂。 当然还有一些，比如说像中国青年家国情怀的意识也跟其他国家不一样，这可能是从我们国家五四运动而来的。这跟年轻人他所理解的国家的关系跟他个人的关系有很强烈的相关性。我们所说的蚁族青年，他参与的几个比较大的社会运动，你说他没有特别多的经济诉求，不像有些群体，农民工是讨薪，2005年北京出现了抵制日本入常，2008年抵制家乐福，包括918，蚁族大部分人还是因为民族尊严与国家外交受挫的时候，他们这种家国情怀表现的更明显。这里我们要进行有效的引导，好的引导。所以中国的社会结构和历史传统，都和西方国家有很大区别。这是我们在分析中国青年问题的时候要特别着重注意的，跟西方有很大的区别。 5.4亿青年正站在中国转型的十字路口上 主持人：您前边讲了不少青年遇到的困境，包括由此带来的一些对社会的不满情绪。据您的判断，以目前的这种状况来讲，很多青年人的生活和思想状态是有问题的，而且问题是不小的，那么，我的问题是，这样一个群体对中国的政治和社会稳定的冲击在将来会出现什么样的变化和影响? 廉思：我们可以给出的一个感觉，首先是国家对青年人的定位是合格建设者和可靠接班人，这是两个层次的问题，建设者是一个层次，接班人是一个层次。绝大部分的年轻人我觉得还是一个合格的建设者，会成为建设国家的主力军。当然我们说现在网络的舆论，媒体很发达，青年发声的机会更多，而且现在由于我们社会发展的壮大，所以也可以预见到一个趋势，未来体制外青年群体会发力。现在这样的诉求还是零零星星的，但是未来会越来越多的出现这样体制外的相对固定化的有利益诉求的青年群体，当然这些群体有可能是由于兴趣爱好结合在一起的，但他们都有一定的发声的能力。这样肯定会对中国政治的进程产生影响，但这样对进程的影响会导致什么结果，我们还不好完全的做出判断。因为从整体青年的运动发展来看，它确实存在多元的可能性。在有些国家成为了建设性的力量，有些国家成为了破坏性的力量，但是有一点我们可以看到，中国初步统计15岁到19岁的青年是5.4个亿，这5.4个亿青年的群体，他的影响力实际上是任何国家都没有处理过的，没有面对过的。 欧洲在1493年到1905年400年间，欧洲一共向世界上输出了据说几千万的青年，青年也成就了当时欧洲的文艺复兴，大航海、发现新大陆，当然也包括两次世界大战。有学者这么说，青年人口过剩，当然也有它建设性的一个方面。这么大的群体中国历史上没有，世界上任何国家都没有，可以说是前无古人的，所以你如何引导他发挥作用。并且他的层次是多元化的，是不同的群体，分化又很明显。现在我们确实也感受到社会的共识机制难以达成也影响到青年，因为代际的影响是很明显的。 前几年有一个帖子非常有意思，我奋斗了18年才跟你喝咖啡，尽管喝的是同一杯咖啡但是喝的味道是不一样的。对于这样的利益判断，分析之间的博弈和角力也会存在多元的现象，所以我们说引导这样庞大的青年群体，使它成为国家的建设者，应该是很难也很重大的课题。这是一个世界性的大课题，就叫做5.4亿青年站在中国转型的十字路口。把这个问题解决好了，不仅是中国对自己国家的贡献，也是对世界的贡献。当然说它的影响的走向，从微博到微信，这样的网络化的工具应该是年轻人最先使用的，由于知识技术和年轻人这样紧密的结合，这是任何历史时代所没有的，也使得我们青年的价值观更加多元，更加多变。青年的发声能力更强。所以说后移时代向前移时代的转化是必然的，年轻人这样的价值判断跟以前的年代完全不一样，但说具体的，它会往哪个方面发展我们要拭目以待，根据具体的情况做出判断。 一个国家进入稳定状态 阶层出现固化是必然趋势 主持人：刚才我们花了比较大的篇幅聊青年人的困境，也是切题的布局。下面几个问题想让您谈谈造成这种困境的一些基本的因素。我看到有不少人关注这个问题，有学者在分析这个问题的时候提出了阶层固化的概念，刚才您也提到了阶层断裂这样的概念。也就是说，他们认为出身、家庭这种因素越来越成为青年人发展的主要因素。如果你也认为存在这种阶层固化、阶层断裂的现象的话，那么根据您的研究，造成这些现象的原因是什么? 廉思：我是这么来看待这个问题的。首先阶层固化来说，这是世界上各个国家现在都面临的问题。中国历史上有过社会流动特别快的时期，文化大革命时期，改革开放初期。但是，一个国家他进入了稳定状态以后，阶层出现固化是一个必然趋势，所谓固化为什么会出现，就是处于每一个社会阶层的人，他一定对自己的发展有一个心理预判，预判就会相对的固化下来。 现在在美国我们也不能承认是有固化的，日本这样的固化可能会更加明显，爸爸、爷爷是总理，孙子还是总理。爸爸、爷爷是议员，孙子还是议员，这种现象是有的。但是从中国的角度来说，他的平等感是强于西方人，这源于在隋唐时代我们就开创了科举制。什么是中国梦，中国梦比美国梦早多了，中国自隋唐就有了。所以中国人的平等观念是根深蒂固的，这样的观念使他对自己的未来有期许，再加上我们前30年社会剧烈的流动，它的流动还是很快的。改革开放初期，广东电子表拿到北京卖钱一下子就可以成为富翁。这是社会相对发展稳定下来以后，有其必然的因素在里面。 现在的调查表明，在大城市出现了知识不匹配的情况。大家都问我们，廉老师都说知识能改变命运，为什么知识没能改变我的命运?中国还没有完全进入知识时代，为什么有知识的人却被抛在了时代的后面?四年前我用一袋钱换了一堆书，四年后同样一堆书换不来一袋钱。我们明显的感觉到年轻人短程的流动还是有的，这些年轻人在北京进不了体制内，回到家乡以后确实都进入到了国企，进入到事业单位了，知识仍然能发挥作用。所以我们得出一个新的结论，知识它的价值，不光取决于知识本身的含量，它还取决于知识它的地理空间位置能不能发挥作用。 我认为，以后长途的流动会越来越少，短途的流动会越来越多，你想一夜暴富不可能，大学毕业以后先到省城发展，然后再往上走，它有一定的必然性。但是我们也确实出现了一些令人感到情况严峻的危机，潜在的危机。比如说，这几年在我们的高等教育的遴选机制上确实出现了问题，当然现在国家也注意到这个问题，中西部、边远地区加强了高等教育学生的遴选，但是前几年这种情况已经形成了。比如说最典型的就是自主招生的考试，1999年扩招开始，由考知识到考能力的变化，势必造成强者更强，弱者更弱的效应。农村的学生告诉我们，廉老师，我们考的大部分都是课外的知识，我们的县中学连课外的书都很少，老师不让我们读，因为在自主招生考试里还有一些是英文的对话，我们有的时候看到北大的学生或者清华的学生说这正好是我们大学聊的课题，县城里面哪有这种好的英文老师。所以，你会发现1999年，尤其是2002年、2003年以后这10年间有一批县一中在衰弱，你的经济资源、社会资源在转化的过程中，你的经济资源和社会子资源很容易的转化成知识资源。韦伯说过一句话，他说高等教育是把那些注定要在人群中显赫的人给识别出来。我们中国有句话叫有教无类，平等的教育。所以目前来看，由考知识到考能力的变化，考课外题，包括高考的语文实体，都是以城市为背景的，农村的学生吸收是很困难的。比如考五线谱他怎么能知道呢。 包括历史、地理考试，很多时候都出现这样的状况，我们不是说改革不可以，但是改革的时候一定要明白严复说的那句话，”须知中国不灭,旧法可损益，必不可叛”。我们目前的高等教育没有这种筛选机制。我们的很多农村孩子，让他的青年期可能经历的时间更长。我们去年研究的青年住房问题，很多事业单位，或者公务员的住房问题并不比一般的年轻人好到哪里去，大家同样有抱怨。这是我们没有想到的，青年公务员对于现在的自身发展也有很多不满意的地方，包括待遇。大学里我都是最优秀的，结果他到了民企比我挣的还多。这样的阶层流动既有它的必然因素的考虑，社会发展到稳定阶段都会变慢下来，另外这里面出现了一些很不好的因素。所以我们说纵向流动的加强，加强高等教育从各个社会阶层选拔出精英这样的机制，大学应该成为保守社会德行的底线，而不能再成为社会利益分配的工具。高等教育它应该是一个社会公平的平衡器，而不是社会分化的加剧器。 北京市的青年住房问题，去年是699万大学毕业生，号称史上最难就业年，今年是727万大学毕业生，号称史上更难就业年。去年到了7月份，史上最难就业年，变成了史上最难就业季，进而变成了史上最难租房季。很多人5月份不租，一直等到7月份。后来我们发现北京住房的总供应量是够的，但不匹配，因为很多都是大户型，年轻人喜欢小户型，他喜欢30平米我有一个相对的独立空间，我住了4年的大学宿舍能给我一个独立的空间，我们政府是不是在青年的基本保障方面要做好。比如说青年公寓的建设，包括真正的能不能有一些准入门槛比较好的青年的公寓等等。这些其实都是我们要去思考的。我们要真正的切合青年的需求，包括很多农民工说，说廉老师我们特别需要职业的培训，职业的发展，我们是不是也可以提供一些免费的职业培训。因为对农民工来说以后可能落脚到大城市也不太可能，他更想回到老家。 有的时候问开饭馆的或者理发的，说在北京干活为了什么，说以后要在北京买房吗?北京房子太贵了，买不起，学到手艺是回家开一个店。我们各项政策实际上的目的是让所有年轻人生存的有尊严，大部分的年轻人发展有希望。你要给年轻人一个看得见的未来，这个未来不能太远，他才会往上走。 中国教育最大的问题在于让每个人都成为精英 主持人：刚才您不仅仅是讲了阶层固化，其实也给出了一些我们可做的事情，为将来指出了出路。您刚才更多的是从政府的层面来讲，可以怎么做减少青年的压力，让他们不至于对未来太迷惘，有太多的焦虑。但是我也注意到一位网友说，青年人出路在于自身，所以我就想问您，对于那些正生活在或者正在奋斗的底层青年们有什么样的建议。 廉思：在《蚁族》那本书后面，我留了一个邮箱，有一个小姑娘就写信问我，廉老师我们是逃离北上广还是坚守北上广。这本书出版到现在已经5年了，统计了一下收到了一万多封信。很多年轻人跟我们分享了他们奋斗的历程，我记得很清楚，我们收到一封信，也是一个小姑娘，她是在广州一个重点大学毕业的，回到了家乡工作，家乡是县级市，广东的县级市很有钱，爸妈将她安排在一个事业单位工作，她说很安逸，有车接送，但是我不想20多岁的时候就看到60岁的生活了。我在广东读了大学，大家都去追梦了我也想去追梦，我跟家里吵了无数次，家里终于同意我到大城市去闯一闯，但是很不幸的是我春节期间看了你的书《蚁族》，我不敢去了，害怕了。说廉老师，你告诉我，我是该在大城市做蚁族，还是在小城市做贵族。 还有一个年轻人，去年收到他的信。夫妻俩创业，都是农村的，工作十几年赞了几十万，一直想买个房子，但是他们觉得不甘心，交个房子首付不如用几十万自己创业，搏一个未来。创业压力很大，男的给我来信是凌晨，写道，晚上睡不着觉，我知道你也帮不了我什么，我就想排解一下。 怎么办?有成功的也有不成功的，有回到家乡做的很好的。原来我们做返乡青年调查，到河北清河县调查，它是产羊毛的，很多世界的大品牌都用他们的羊毛做原材料。中国人挣的是10美元的人工费，人家挣的是贴标费。年轻人他们回乡要创自己的品牌，不能天天跟老爸一样，他们会用微信做宣传，有创业成功的。也有回去发现很不好的，因为中国越往基层越是关系社会。蚁族最缺的就是关系和资源，回去之后发展更受阻滞。首先要对自己有一个评估，盲目的探索、坚守还是逃离没有意义，要根据个人的状况来看，还要根据自己的发展状况去定位、去比较、去琢磨，然后才能确定你自己人生的方向。而且你在选择行业的时候，包括你自己创业的时候，也要经过多方面的考虑，自己去斟酌和打磨。 一个人他有坚韧与坚毅的精神，再加上坚持，包括他对世界的热爱，终归会成功的。你要有远大的目标，但是你要学会把它量化成具体的，如果你的目标是乔布斯，你会发现你奋斗5年以后是离自己的梦想很远。我不建议我们一定要把奋斗和成功结合起来，因为奋斗的哲学太简单了，奋斗必然意味着成功，如果我们把成功夸大到极致的程度，如果奋斗最后的结果没有导致成功，无疑会增加一个年轻人的心理落差和社会不公平感。 改革开放发展到今天，我们明白了一个现实，现在的社会是努力奋斗不一定成功，但是不努力不奋斗一定不成功，有知识未必能改变命运，但是没有知识一定不能改变命运。一个人除了奋斗努力以外还有很多成功的因素，比如机遇、天分。所以我们一定要让年轻人把奋斗和成功剥离开来，我的感觉是奋斗它不会给你带来效益最大化的结果，但是可以给你带来风险最小化的效果。我奋斗不一定能够成功，但是我可以增强自己抵抗风险的能力，使自己变得更踏实、更稳定，这是我们可以做的。这一点我们要跟年轻人讲清楚，让他的心态更平和。 我觉得中国的教育最大的问题就在于他让每个人都成为精英，而没有教育每个人应该如何做一个普通人和一个公民。我们对社会顶层年轻人的调查，他们也活的很累，他们也不开心。我们的精英就是这样的教育，就是成败的教育，我们没有教会一个人如何用平和的状态成为一个社会的普通人，成为一个社会的公民，我们对成功的定义理解的太肤浅了。乔布斯都这么有钱了，为什么生这么重的病得癌症，还在做苹果的研发，因为他热爱。这种奋斗是源自于他内心的热爱和追求，一种他内心的道德修炼和内心的追求和修炼，这一点是很多人没有理解的。 我们年轻人的奋斗都是为了成功，但是这两者之间往往没有必然的关系。这一点是我们最强调的。 寄望后人通过我们的青年研究窥见中国转型 主持人：问最后一个问题，刚才其实前面也讲了一些，还是回到思想政治教育课这个角度，一定程度上青年人是被动式的参与，但国家定位真正的把青年定位为国家的未来，还是要提供主动性的平台和参与的渠道。中国在这方面做的还不是很够，不知道在这一块您有什么样的相应的看法。最后是关于您的学术研究，我知道您做的研究是比较实证的研究，包括您讲的例子，有很多的小故事。不知道在同行里面有没有人去质疑您研究的学术性。 廉思：这两个问题都非常好。第一个就是你说的渠道太窄的问题，确实要看出来，中国的决策层怎么来定义青年，是不是把青年定义成真正的有生力量。诺贝尔奖的高产是在45岁之前，青年人是创造历史的重要力量之一，我们必须重新定位，来看待青年。青年的作用也取决于我们现代人如何去对待他，从长远的观点来看，这个世界是属于年轻人的，任何掌权者或者决策层只不过替下一代人来代管，你管的不好年轻人当然不满意，他要起来，因为你让年轻人安分是有前提条件的，前人栽树后人乘凉，年轻人相信你，你留给他的世界是更好的。 但是如果他觉得你把蛋糕都分完了，到我这儿我连汤都喝不到，我的上升空间都没有了，我当然不满意，我就要爆发。华尔街青年运动中提出的口号，你们有背景的人占了我们99%的财富，我跟你一个学校毕业，我不比你差，只不过就是你的爸爸比我爸爸强。社会对青年开放的程度，渠道放开的程度，其实决定了一个社会的活力，是社会活力重要的评价指标。现在我们的社会由固态中国向流动中国的变化，你不让年轻人进入实体平台发言，他会有虚拟的平台发言。我们一定要让青年多去发声，这一点我们的渠道是窄的，我们的政治参与的渠道，利益诉求的渠道，都是有待加强的。 比如说按流入地，如行使自己的政治权利。你说我户口不在这儿，但我生活在这儿4、5年了，这个社区是我的，我有权决定选谁。这些东西都是有很多的困难。包括我们很多的青年组织，比如我们的人大代表，包括青联，我们有多少真正的底层青年精英在里面。像您所说的要让农民工代表、蚁族代表去发声，真正的替他们这个群体去发声。我们的统战部门可能要吸引更多的年轻人进来。青年参与社会的状况是衡量一个社会它的创新力和活跃度的重要指标。 第二，一直有人在质疑我。社会学有人在质疑，说如何来看待这样的人类学的方法，因为我们的方法是社会学和人类学组合的。有句话说理论是抽象的，现实是具体的，但是中国恰恰相反，中国现实是抽象的，理论是具体的。你看这个现象特别的具体，实际上它是抽象的，理论只能说明它是一个方法。比如看这个表，你看这面是这样，背面是这样的，表是真实存在的，我们的社会生活是完整的，但是我们不能用不同的专业去切割这样的完整。所以我们为什么要做这样的人类学的访谈，不太学术，其实我们是把这样的故事呈现出来，实际上是让更有理论深入的人去解读，或者读出不一样的东西来。可能我们的解读是一个方面，别人的解读又是另外一个东西。社会研究没有完全的客观性，但是我们只能经常的去记述这样的过程，而不加入我们的感情色彩，这是我们有一些留白的考虑。 我们这几年也更多的是在一个一个的青年群体中在做，可能我们还要做新一代的海归群体，慢慢的我们能拼出一幅中国青年的群像图来。在中国现在特别缺乏的是经验性的研究，实证性的研究，有助于加强对中国根本现状的认识。别说到我们作古以后，或者到了几十年上百年以后，后人看21世纪的中国怎么只剩下一些观点，事实是什么，不知道。我们希望能做出一些成果，作为中国青年的野史，通过这些小的切片能窥见到中国转型的变化。这是我们做的事情。 主持人：我们期待您的相关研究能够出现在我们读者的面前，也希望您的这些研究成果对我们国家青年的工作能够产生更大的作用。","categories":[{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"青年","slug":"青年","permalink":"http://spcablast.club/tags/%E9%9D%92%E5%B9%B4/"},{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"}],"author":"YP"},{"title":"指针系列一","slug":"c预言解惑-指针","date":"2022-11-07T16:00:00.000Z","updated":"2022-12-20T01:35:51.416Z","comments":true,"path":"2022/11/08/c预言解惑-指针/","link":"","permalink":"http://spcablast.club/2022/11/08/c%E9%A2%84%E8%A8%80%E8%A7%A3%E6%83%91-%E6%8C%87%E9%92%88/","excerpt":"","text":"指针一从c语言开始#####为什么用指针先提变量，变量三要素：变量名，变量类型，变量地址 变量类型：数据类型 int float double …存储类型: auto extern static register 变量的地址： 赋了值的变量在哪儿、static变量存在.data区,未赋值的全局变量存在.bss区，变量声明不分配空间，定义的时候分配空间 #####左值和右值：比如a[10],在 1a[0] = a[2] 中，a[0]作为变量，将要给该地址赋值，他是左值，a[2]取了该地址的值，作为右值左值是一个具体的变量，右值一定是一个具体类型的值，所以有些可以既可以作为左值，也可以作为右值，但有些只能作为右值。 #####引入和&amp;运算符变量存在内存中某个一个地址，想取该地址内存放的值，引入运算符，而&amp;用来取这个变量在内存中的==首地址==； 123456789int a = 56; //地址为0x0012ff7c（1）int addr = 0x0012ff7c; //将值设置为上一个变量的地址（2）// &amp;a, 返回的是存储地址，与addr的值相等// *addr不可用，因为编译器不知道 addar是地址，会把他当整数// *(int *)addr返回的是65，将addr强制转换成int *// 同理// int addr = (int*)&amp;a;// 可以达到同样的效果 由此，为了简化操作，我们引入指针变量，用T *表示这是一个T类型的数据的首地址，这样就可以直接将T类型的变量b的地址给T类型的指针变量赋值，可以实现 1int * addr = &amp;a; 而不用 1int addr = 0x0012ff7c; #####指针操作1、根据(*). 和功能相同的-&gt;，因为写起来简单2、指针移动，因为指针指的是数据的首地址，所以可以加一减一，这个1是4字节还是8字节还是多少，具体看他指向的数据类型的大小。指针声明的时候就得初始化，不然他会随机分配一个地址，很恐怖。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"http://spcablast.club/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://spcablast.club/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://spcablast.club/tags/c%E8%AF%AD%E8%A8%80/"}],"author":"YP"},{"title":"热知识（持续更新）","slug":"热知识","date":"2022-10-07T16:00:00.000Z","updated":"2022-12-29T05:20:05.988Z","comments":true,"path":"2022/10/08/热知识/","link":"","permalink":"http://spcablast.club/2022/10/08/%E7%83%AD%E7%9F%A5%E8%AF%86/","excerpt":"","text":"心理学家Eder（1978）在一项儿童友谊关系的长期研究中发现，男孩子通过玩耍交朋友时往往是一群人一起玩，而女孩子是一对一对地玩；对成年人来说，男性之间的关系发展往往取决于他们是否参加了共同的活动，如一起踢足球等；而成年女性要想成为朋友，一起聊聊天就有可能。Wright（1982）把男性交友的倾向称为面对面（face to face）方式，而把成年女性交友的方式叫做肩并肩（side by side）方式。 《社会心理学第三版第七章第二节》 皮肤拥有很多隐含着各种信息的指示色，甚至蓝色也属于皮肤色谱之一，它反映的是血液循环减弱而产生的体寒，或是由肺病、血栓（Thrombose）导致的血液性缺氧，缺氧会阻碍血液循环，使得血液无法及时流回心脏。蓝色的静脉血属于正常现象，它会从心脏流到肺部被人体重新回收利用。有一种青紫色的皮肤病叫作发绀（Zyanose），其希腊语本意为“蓝色”；皮肤发黑通常是由于老旧的血液堆积在一起，但也有可能是组织坏死，医学上称之为坏疽（Nekrose）。《皮肤的秘密》 从事科学研究的人，一定要坚信任何事情的发生，决不会是无缘无故的。 一般而言，套套逻辑并不是「四足动物有四只脚」那么简单，那么一目了然。空泛而没有内容的，而又不可能错的「理论」多的是，然而很多时就是大学博士也不易察觉。 在经济学上，一个不可或缺的基本假设是：每个人的任何行为都是为自己争取最大利益。但一个人抽烟或跳楼，对自己的身体是有害的。假若我们说抽烟或跳楼的行为，是因为「争取个人最大利益」，那就是套套逻辑了。在那个假设下，任何行为都算在其内，以「争取个人利益」来「解释」抽烟或跳楼，不可能错，因为假设的本身是一般地包括了人的所有行为。但如果所有人的行为都是定义地、空泛地被解释了，那么整个经济学就没有什么内容。 举另一个例子。有一位经济学者，试图以事实考证，私营企业的生产成本是否那企业所能做到的最低成本。但根据经济学的定义，所有私营企业，为了要图私利，必定会尽可能减低生产成本。于是，这位学者所试图的考证是套套逻辑，不可能错，但也没有内容，因为定义本身不容许有可以减低生产成本而又故意不减低的行为。 套套逻辑有一点很可取的特色：它有极大的一般性。假若我们能把范围加以约束、收窄，有时可以促成一个有内容的－－可能错的－－理论，其解释能力之强，令人拍案叫绝。 为什么音阶是八度，是为什么是十二平均律 十二平均律是指八度的音程按波长比例平均分成十二等份，每一等份称为一个半音（小二度）。一个大二度则是两等份，称为全音。将一个八度分成12等份有着惊人的一些巧合。这是因为它的纯五度音程的两个音的波长比（即1/2的7/12次方）约为0.6674，与2/3，约为0.6667，非常接近。 由于波长与弦长之间存在正比关系，因此波长关系可以转化为弦的长短关系。所以即使在16世纪，那个西方物理学才刚刚起步，还没有发现机械波的时代，中国明朝皇族世子朱载堉就利用他精湛的数学计算能力，发现了这一近似值规律，这也是一件十分伟大和令人赞叹的事。-百度百科2022-03-19 ####标题：震惊！人类竟能用这个部位呼吸，你绝对想不到论文题目：#####Mammalian enteral ventilation ameliorates respiratory failure发布时间：2021 年 5 月 14 日DOI：https ://doi.org/10.1016/j.medj.2021.04.004论文链接根据日本科学家2021年的一项实验表明，哺乳动物可以使用直肠进行呼吸，这个神奇的想法是从泥鳅身上学到的，泥鳅进化出了独特的肠道呼吸机制，可以在广泛 的缺氧环境下生存。于是，于是啊，很快啊，他们通过直肠内通气实验了哺乳动物的肠道呼吸能力。实验对象有小鼠和猪，结果十分amazing啊，在其呼吸衰竭之后直肠内通O2气体和含氧液体都可以改善存活率和全身O2水平，缓解呼吸衰竭。20220921 呼吸对静脉压的影响：胸膜腔内压通常低于大气压，是为负压，故胸腔内大静脉的跨壁压较大，常处于充盈扩张状态。吸气时，胸腔容积增大，胸膜腔负压增大， 使胸腔内的大静脉和右心房更加扩张从而有利于外周静脉回流至右心房，呼气时，胸膜腔负压减小，则静脉回心血量相应减少。因此，呼吸运动对静脉回流也起着“泵”的作用，称为呼吸泵。《生理学第八版》 这么说深呼吸还能促进血液循环，把肢端的静脉血吸回来？ 短路血管：血管床中的小静脉和小动脉之间的直接吻合支。他们主要分布在手指、足趾、耳廓等处的皮肤中，当短路血管开放时，小动脉内的血液可不经毛细血管直接进入小静脉，在功能上与体温调节有关。《生理学第八版》 当短路血管开放时,皮肤血流量增加，皮肤温度升高，散热量增加，相反则减少散热量。另外短路血管开放会相对减少组织对血氧的摄取，某些条件下可能造成组织缺氧 皮肤创伤愈合过程皮肤创伤分：表皮层创伤、皮肤和皮下组织断裂并出现伤口、肌肉肌腱神经骨骼断裂以皮肤手术切口为例，叙述创伤愈合的基本过程如下：1、伤口早期变化伤口局部不同程度组织坏死和血管断裂出血，数小时内出现炎症反应，充血，局部红肿。血液和渗出液中的纤维蛋白凝固形成凝块，有的凝块表面干燥形成痂皮，凝块及痂皮起着保护伤口的作用。2、伤口收缩23日后边缘的整块皮肤及皮下组织向中心移动，于是伤口迅速缩小，直到14天后左右停止。伤口收缩的意义在于缩小创面。伤口收缩是伤口边缘新生的肌成纤维细胞的牵拉作用引起的，而与胶原无关。因为伤口收缩的时间恰好是肌成纤维细胞增生的时间。3、肉芽组织增生和瘢痕形成大约从第三天开始从伤口底部和边缘长出肉芽组织填平伤口。毛细血管大约以每日延长0.1到0.6mm的速度增长。其方向大多垂直于创面。肉芽组织中并无神经，所以没有感觉。第56日起纤维细胞产生胶原纤维，其后一周胶原纤维形成甚为活跃，以后逐渐慢下来。随着胶原纤维越来越多，出现瘢痕形成过程，大约在伤后一个月瘢痕完全形成。可能由于局部张力的原因，瘢痕中的胶原纤维始终与皮肤平面平行。4、表皮及其他组织再生创伤发生24小时内，伤口边缘的基地细胞即开始增生，并在凝块下面向伤口中心迁移，形成单层上皮，覆盖于肉芽组织的表面。当这些细胞相遇时，他们停止迁移，并增生分化成鳞状上皮。若伤口过大（大于20cm）再生表皮难以覆盖伤口，往往需要植皮 。皮肤附属器（毛囊汗腺皮脂腺）如遭完全破坏，则不能完全再生，而出现瘢痕修复。肌腱断裂之后，刚开始也是瘢痕修复，随着功能锻炼而不断改建，胶原纤维可按原来肌腱方向排列，达到完全再生。《病理学第八版》 那这么说挑断手筋脚筋还可以练回来啊，不够严谨，还是截肢吧20220923 胡萝卜是被子植物门、双子叶植物纲、伞形目、伞形科、胡萝卜属萝卜是被子植物门、双子叶植物纲、罂粟目、十字花科、萝卜属所以胡萝卜不是萝卜20220926 千叶豆腐是豆制品但是不是豆腐千页豆腐是素食新产品，以大豆分离蛋白和水为主要原料，食用植物油、淀粉等为辅料，添加或不添加稳定剂和凝固剂、增稠剂，经斩拌乳化、调味、蒸煮、冷却、切块或再速冻等全部或部分工艺制成的大豆蛋白制品。虽然属于豆制品产品，但不是豆腐及豆腐制品，其生产原料、生产工艺、产品理化指标、内部组织结构、产品口感和营养成分与豆腐有本质的区别。大豆分离蛋白大豆分离蛋白是在低温条件下将豆粕（除去油和水溶性非蛋白成分）放入碱性溶液中浸提，然后沉淀、洗涤、干燥得到蛋白含量大于 90%的蛋白粉，其结构和性质基本代替纯的大豆蛋白。 [6] 大豆分离蛋白氨基酸种类有近20种，并含有人体必需氨基酸。其营养丰富，不含胆固醇，是植物蛋白中为数不多的可替代动物蛋白的品种之一。所以如果世界末日了，只需要吃大豆分离蛋白和饭就行了，活下去的方式又增加了20221008 交通学有“当斯定律”，1962年提出，分析高峰期交通拥堵以及交通拥堵与交通平衡理论之间的关系时提出。定律内容：都市区通勤高速公路上高峰期交通拥堵的提高可满足最大的道路容量。说人话就是新增的道路设施会诱发新的交通量，交通需求总是倾向于超过交通供给。结论就是光修路没用，除非全是路，够用就行，再加政策。20221215 喉发育因素（变声期喉的结构变化）1、喉的位置在变声期后，喉的位置由第五颈椎下降至第六颈椎下缘的平面，咽喉腔拉长，声带距鼻咽顶壁距离增大，此时声音粗厚低沉。2、喉前庭变化随着喉的发育，会厌由卷曲状“婴儿型”变得舒展平坦，喉咽管腔共鸣作用增大，也是音调变粗变低，但音响较洪亮之原因。3、喉神经肌肉的变化喉软骨支架的变化伴随或带动神经支配的喉内外肌发育。如发育迟缓或不正常，可导致变声障碍。20221220 来自百度百科","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"摘选","slug":"摘选","permalink":"http://spcablast.club/tags/%E6%91%98%E9%80%89/"}],"author":"YP"},{"title":"好用的小工具（持续更新）","slug":"好用的小工具","date":"2022-09-25T16:00:00.000Z","updated":"2022-12-20T01:35:51.417Z","comments":true,"path":"2022/09/26/好用的小工具/","link":"","permalink":"http://spcablast.club/2022/09/26/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"话不多说直接上网站 网址 内容 https://codetop.cc/home 按面试出现的频率排序力扣题 https://tool.chinaz.com/dns/?type=1&amp;host=aka.ms&amp;ip= 根据域名查ip地址 https://zh.z-lib.org/ 数字图书馆（谁用谁知道） 2022-03-18 https://www.allhistory.com/ 我觉得拿来搜相关内容挺好的，人或者事或者物 2022-09-23 使用示例： 这张图片是我搜索康德得到的结果，可以看到他和其他人的关系有：影响/被影响，批判/被批判，评价/被评价，甚至还有埋葬于，这样就可以简单地了解与他相关的历史人物有哪些，然后去挑感兴趣的查查。 2022-09-26来一个软件，可以下载youtube上的视频：Gihosoft TubeGet直接复制youtube某个视频的网址，贴到软件里就可以下载，含内购，免费版只能每天下载5个视频 2022-10-08","categories":[{"name":"工具","slug":"工具","permalink":"http://spcablast.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://spcablast.club/tags/%E7%BD%91%E7%AB%99/"}],"author":"YP"},{"title":"Boost中Signal的使用","slug":"Boost中Signal的使用","date":"2022-04-14T16:00:00.000Z","updated":"2022-12-20T01:35:51.415Z","comments":true,"path":"2022/04/15/Boost中Signal的使用/","link":"","permalink":"http://spcablast.club/2022/04/15/Boost%E4%B8%ADSignal%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Boost中Signal的使用参考链接 说实话没完全看懂，贴个链接先，再看看","categories":[{"name":"Boost","slug":"Boost","permalink":"http://spcablast.club/categories/Boost/"}],"tags":[{"name":"Signal","slug":"Signal","permalink":"http://spcablast.club/tags/Signal/"}],"author":"YP"},{"title":"Dailycode","slug":"20220407","date":"2022-04-06T16:00:00.000Z","updated":"2022-04-07T15:11:07.238Z","comments":true,"path":"2022/04/07/20220407/","link":"","permalink":"http://spcablast.club/2022/04/07/20220407/","excerpt":"","text":"200. 岛屿数量难度中等1647收藏分享切换为英文接收动态反馈 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 1234567输入：grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 示例 2： 1234567输入：grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col)&#123; int rows = grid.size(); int cols = grid[0].size(); grid[row][col] = '0'; if(row + 1 &lt; rows &amp;&amp; grid[row+1][col] == '1') dfs(grid, row+1,col); if(row - 1 &gt;= 0 &amp;&amp; grid[row - 1][col] == '1') dfs(grid, row - 1,col); if(col + 1 &lt; cols &amp;&amp; grid[row][col + 1] == '1') dfs(grid, row,col + 1); if(col - 1 &gt;= 0 &amp;&amp; grid[row][col - 1] == '1') dfs(grid, row,col - 1); &#125; int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; // 先得有一个判断是岛的方法 // 以一个1为起点搜，直到相邻的没有1 // 那这样就得标记每个点有没有搜过 // 还得有一个搜索算法 int rows = grid.size(); if(!rows) return 0; int cols = grid[0].size(); int ans = 0; for(int i = 0; i&lt; rows; ++i)&#123; for(int j = 0; j&lt; cols; ++j)&#123; if(grid[i][j] == '1')&#123; ++ans; dfs(grid, i , j); &#125; &#125; &#125; return ans; &#125;&#125;; 232. 用栈实现队列难度简单614收藏分享切换为英文接收动态反馈 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 1： 12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue &#x3D; new MyQueue();myQueue.push(1); &#x2F;&#x2F; queue is: [1]myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); &#x2F;&#x2F; return 1myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]myQueue.empty(); &#x2F;&#x2F; return false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class MyQueue &#123; // 逆序 stack&lt;int&gt; stac1; // 正常栈 stack&lt;int&gt; stac2; int size;public: MyQueue() &#123; size = 0; &#125; void push(int x) &#123; stac2.push(x); size++; while(!stac1.empty())&#123; stac1.pop(); &#125; stack&lt;int&gt; temp = stac2; while(!temp.empty())&#123; int val = temp.top(); temp.pop(); stac1.push(val); &#125; &#125; int pop() &#123; if(size)&#123; int ans = stac1.top(); stac1.pop(); while(!stac2.empty())&#123; stac2.pop(); &#125; stack&lt;int&gt; temp = stac1; while(!temp.empty())&#123; int val = temp.top(); temp.pop(); stac2.push(val); &#125; size--; return ans; &#125;else return 0;//ans; &#125; int peek() &#123; return stac1.top(); &#125; bool empty() &#123; return size==0; &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"http://spcablast.club/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}],"author":"YP"},{"title":"心理学定义和一种分类","slug":"人格-Personality","date":"2022-04-05T16:00:00.000Z","updated":"2022-04-06T01:18:39.166Z","comments":true,"path":"2022/04/06/人格-Personality/","link":"","permalink":"http://spcablast.club/2022/04/06/%E4%BA%BA%E6%A0%BC-Personality/","excerpt":"","text":"心理学 定义","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://spcablast.club/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}],"author":"YP"},{"title":"Dailycode","slug":"20220406","date":"2022-04-04T16:00:00.000Z","updated":"2022-12-20T01:35:51.415Z","comments":true,"path":"2022/04/05/20220406/","link":"","permalink":"http://spcablast.club/2022/04/05/20220406/","excerpt":"","text":"","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220405","date":"2022-04-04T16:00:00.000Z","updated":"2022-12-20T01:35:51.414Z","comments":true,"path":"2022/04/05/20220405/","link":"","permalink":"http://spcablast.club/2022/04/05/20220405/","excerpt":"","text":"23. 合并K个升序链表难度困难1872 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2： 12输入：lists &#x3D; []输出：[] 示例 3： 12输入：lists = [[]]输出：[] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* merge2(ListNode* l, ListNode* r)&#123; if(!l || !r) return l ?l:r; ListNode pre, *start = &amp;pre,*lptr = l, *rptr = r; while(lptr &amp;&amp; rptr)&#123; if(lptr-&gt;val &lt; rptr-&gt;val)&#123; start-&gt;next = lptr; lptr = lptr-&gt;next; &#125;else&#123; start-&gt;next = rptr; rptr = rptr-&gt;next; &#125; start = start-&gt;next; &#125; start-&gt;next = (lptr?lptr:rptr); return pre.next; &#125; // 普通方法 // ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // // 好像有点长 // ListNode* ans = nullptr; // for(int i = 0; i&lt; lists.size(); ++i)&#123; // ans = merge2(ans, lists[i]); // &#125; // return ans; // &#125; // 归并 // ListNode* merger2to1(vector&lt;ListNode*&gt;&amp; lists, int start, int last)&#123; // if(start == last)&#123; // return lists[start]; // &#125; // else if(start &gt; last)&#123; // return nullptr; // &#125; // return merge2(merger2to1(lists, start, (start+last)/2), // merger2to1(lists, (start+last)/2 + 1, last)); // &#125; // ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // return merger2to1(lists,0,lists.size()-1); // &#125; struct stature&#123; int val; ListNode* ptr; bool operator &lt; (const stature&amp; compare) const &#123; return val &gt; compare.val; &#125; &#125;; priority_queue&lt;stature&gt; que; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; for(ListNode* cur : lists)&#123; if(cur)que.push(&#123;cur-&gt;val, cur&#125;); &#125; ListNode start, * pre = &amp;start; while(!que.empty())&#123; auto cur = que.top(); que.pop(); pre-&gt;next = cur.ptr; pre = pre-&gt;next; if(cur.ptr-&gt;next)&#123; cur.ptr = cur.ptr-&gt;next; que.push(&#123;cur.ptr-&gt;val, cur.ptr&#125;); &#125; &#125; return start.next; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"}],"author":"YP"},{"title":"Dailycode","slug":"20220404","date":"2022-04-03T16:00:00.000Z","updated":"2022-12-20T01:35:51.414Z","comments":true,"path":"2022/04/04/20220404/","link":"","permalink":"http://spcablast.club/2022/04/04/20220404/","excerpt":"","text":"143. 重排链表难度中等858 给定一个单链表 L 的头节点 head ，单链表 L 表示为： 1L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为： 1L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 12输入：head &#x3D; [1,2,3,4]输出：[1,4,2,3] 示例 2： 12输入：head &#x3D; [1,2,3,4,5]输出：[1,5,2,4,3] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: void putforward(ListNode* former, ListNode* later)&#123; later-&gt;next = former-&gt;next; former-&gt;next = later; &#125; void reorderList(ListNode* head) &#123; // 假如我用一个vector把他们都存起来再按规则拿出来，是不是算走捷径呢 // 正常应该用什么方法呢，按规则，普通方法应该是n方的， // 啊，我想到了，先遍历一遍，获得总长度，来一个标志位，放到链表中间 ListNode* mid = head; ListNode* beginode = head; int len = 0; while(mid)&#123; mid = mid-&gt;next; len++; &#125; mid = head; len = len%2 == 0? len / 2 - 1 : len / 2; int circle = len; while(circle --)&#123; mid = mid-&gt;next; &#125; circle = len; ListNode* startofmid = mid; while(circle--)&#123; // 获得最后一个节点 while(mid-&gt;next-&gt;next)&#123; mid = mid-&gt;next; &#125; putforward(beginode, mid-&gt;next); beginode = beginode-&gt;next-&gt;next; mid-&gt;next = nullptr; mid = head; &#125; &#125;&#125;; 876. 链表的中间结点难度简单533 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* fast = head; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 206. 反转链表难度简单2409 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head &#x3D; [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; // vector&lt;int&gt; list; // int cnt = 0; // ListNode* left = head; // ListNode* right = head; // while(left)&#123; // list.push_back(left-&gt;val); // left = left-&gt;next; // cnt++; // &#125; // while(right)&#123; // right-&gt;val = list[cnt-1]; // cnt--; // right = right-&gt;next; // &#125; // return head; // low // 来个一次遍历就能实现链表反转 ListNode* pre = nullptr; ListNode* cur = head; while(cur)&#123; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"}],"author":"YP"},{"title":"《架构整洁之道》","slug":"架构","date":"2022-04-03T16:00:00.000Z","updated":"2022-12-20T01:35:51.418Z","comments":true,"path":"2022/04/04/架构/","link":"","permalink":"http://spcablast.club/2022/04/04/%E6%9E%B6%E6%9E%84/","excerpt":"","text":"《正经程序员不得学学架构》引言： 普通程序员是编写代码的人。编写代码的方式有很多，只要能让程序跑起来，能正确地处理业务流程和对数据进行计算，就可以说“会编写代码”。 使用各种各样的手段和技术不断提高代码的易读性、可扩展性、可维护性和重用性。我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。 渐渐地，他们发现，问题的多少和系统的复杂度呈正比，而且不仅是线性正比，还可能呈级数正比，此时就越来越难做技术决定。但是有一些资深的工程师开始站出来挑战这些问题，有的基于业务分析给出平衡的方案，有的开始尝试设计更高级的技术，有的开始设计更灵活的系统，有的则开始简化和轻量化整个系统……这些高智商、经验足、不怕难的工程师们引领着整个行业前行。他们就是架构师&gt; 软件架构设计的目标： 这是一个写了50多年代码的优秀老程序员写的书，看看就行了，毕竟没经验体会不到，就像小时候背书，学过了，以后才能明白。 话不多说，先看目录 第1章 设计与架构究竟是什么 第2章 两个价值维度 第3章 编程范式总览 第4章 结构化编程 第5章 面向对象编程 第6章 函数式编程 第7章 SRP：单一职责原则 第8章 OCP：开闭原则 第9章 LSP：里氏替换原则 第10章 ISP：接口隔离原则 第11章 DIP：依赖反转原则 第12章 组件 第13章 组件聚合 第14章 组件耦合 第15章 什么是软件架构 第16章 独立性 第17章 划分边界 第18章 边界剖析 第19章 策略与层次 第20章 业务逻辑 第21章 尖叫的软件架构 第22章 整洁架构 第23章 展示器和谦卑对象 第24章 不完全边界 第25章 层次与边界 第26章 Main组件 第27章 服务：宏观与微观 第28章 测试边界 第29章 整洁的嵌入式架构 第30章 数据库只是实现细节 第31章 Web是实现细节 第32章 应用程序框架是实现细节 第33章 案例分析：视频销售网站 第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式； ​ 第1部分：概述 第1、2章 第2～4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的； ​ 第2部分：从基础构件开始： 第3、4、5章 编程范式 ​ 第3部分：设计原则 第7、8、9、10、11章 SOLID原则 ​ 第4部分：组件构建原则 第12、13、14章 软件开发与组件复用 第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来； ​ 第5部分 软件架构 第15到29章 感觉像是UML（ 好家伙，铺垫了半本书，虽 然前面的半本都像是我觉得你会但是你告诉我你不会） 第6部分讲述具体实现细节； ​ 第6部分 实现细节 第30、31、32章 数据库，界面，程序框架","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://spcablast.club/tags/%E6%80%BB%E7%BB%93/"}],"author":"YP"},{"title":"Dailycode","slug":"20220331","date":"2022-03-30T16:00:00.000Z","updated":"2022-12-20T01:35:51.414Z","comments":true,"path":"2022/03/31/20220331/","link":"","permalink":"http://spcablast.club/2022/03/31/20220331/","excerpt":"","text":"236. 二叉树的最近公共祖先难度中等1657 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 123输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 123输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 12输入：root = [1,2], p = 1, q = 2输出：1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: vector&lt;TreeNode*&gt; pap; vector&lt;TreeNode*&gt; paq; public: void dfs(TreeNode* root, TreeNode* p, TreeNode* q, vector&lt;TreeNode*&gt;&amp; ans)&#123; if(root == NULL)&#123; return; &#125;else&#123; ans.push_back(root); &#125; if(root == p)&#123; pap = ans; &#125;else if(root == q)&#123; paq = ans; &#125; dfs(root-&gt;left,p,q, ans); dfs(root-&gt;right,p,q, ans); ans.pop_back(); &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 我用两个存储空间分别存他们的父节点，按照深度存，从上到下， // 两相比较，按顺序遍历到第一个不一样的 // 深度优先遍历找父节点序列 if(!root) return NULL; vector&lt;TreeNode*&gt; ans; dfs(root, p, q, ans); int m = pap.size(), n = paq.size(); TreeNode* pre = root; for(int i = 0; i &lt; min(m,n); ++i)&#123; if(paq[i] != pap[i])&#123; return pre; &#125;else&#123; pre = paq[i]; &#125; &#125; return pre; &#125;&#125;; 88. 合并两个有序数组难度简单1366 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 1234输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 1234输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 12345输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 123456789101112class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; // std::memcpy(nums1.begin()+m, nums2.begin(), 4*n)); // 认真的吗，不用自己写排序 for(int i = 0; i&lt; n; ++i)&#123; nums1[m+i] = nums2[i]; &#125; sort(nums1.begin(), nums1.end()); return; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220328","date":"2022-03-27T16:00:00.000Z","updated":"2022-03-28T14:53:50.606Z","comments":true,"path":"2022/03/28/20220328/","link":"","permalink":"http://spcablast.club/2022/03/28/20220328/","excerpt":"","text":"103. 二叉树的锯齿形层序遍历难度中等608收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例 1： 12输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]] 示例 2： 12输入：root &#x3D; [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(!root)&#123; return ans; &#125; queue&lt;TreeNode*&gt; list; int falg = 0; list.push(root); while(!list.empty())&#123; // 从左到右 deque&lt;int&gt; temp; int _size = list.size(); for(int i = 0; i&lt; _size; ++i)&#123; auto cur = list.front(); list.pop(); if(falg%2 == 0)&#123; temp.push_back(cur-&gt;val); &#125; if(falg%2 == 1)&#123; temp.push_front(cur-&gt;val); &#125; if(cur-&gt;left)&#123; list.push(cur-&gt;left); &#125; if(cur-&gt;right)&#123; list.push(cur-&gt;right); &#125; &#125; ans.push_back(vector(temp.begin(), temp.end())); falg++; &#125; return ans; &#125;&#125;; 21. 合并两个有序链表难度简单2300收藏分享切换为英文接收动态反馈 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 12输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 &#x3D; [], l2 &#x3D; []输出：[] 示例 3： 12输入：l1 = [], l2 = [0]输出：[0] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; &#x2F;&#x2F; 遍历就完事儿了，边界条件还挺多 &#x2F;&#x2F; if(!list1 &amp;&amp; !list2) return nullptr; &#x2F;&#x2F; if(!list1) return list2; &#x2F;&#x2F; if(!list2) return list1; &#x2F;&#x2F; ListNode* first &#x3D; list1; &#x2F;&#x2F; ListNode* secend &#x3D; list2; &#x2F;&#x2F; int flag &#x3D; 0; &#x2F;&#x2F; ListNode* firstpre; &#x2F;&#x2F; while(first)&#123; &#x2F;&#x2F; while(secend)&#123; &#x2F;&#x2F; if(secend-&gt;val &lt;&#x3D; first-&gt;val)&#123; &#x2F;&#x2F; ListNode* temp &#x3D; secend; &#x2F;&#x2F; secend &#x3D; secend-&gt;next; &#x2F;&#x2F; temp-&gt;next &#x3D; first; &#x2F;&#x2F; if(flag)&#123; &#x2F;&#x2F; firstpre-&gt;next &#x3D; temp; &#x2F;&#x2F; firstpre &#x3D; firstpre-&gt;next; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125;else&#123; &#x2F;&#x2F; firstpre &#x3D; first; &#x2F;&#x2F; if(!flag)&#123; &#x2F;&#x2F; flag &#x3D; 1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; first&#x3D; first-&gt;next; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(secend)&#123; &#x2F;&#x2F; first-&gt;next &#x3D; secend; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(list2-&gt;val &lt;&#x3D; list1-&gt;val)&#123; &#x2F;&#x2F; return list2; &#x2F;&#x2F; &#125;else&#123; &#x2F;&#x2F; return list1; &#x2F;&#x2F; &#125; ListNode* pre &#x3D; new ListNode(-1); ListNode* prev &#x3D; pre; while(list1 &amp;&amp; list2)&#123; if(list1-&gt;val &lt;&#x3D; list2-&gt;val)&#123; pre-&gt;next &#x3D; list1; list1 &#x3D; list1-&gt;next; &#125;else&#123; pre-&gt;next &#x3D; list2; list2 &#x3D; list2-&gt;next; &#125; pre &#x3D; pre-&gt;next; &#125; pre-&gt;next &#x3D; list1?list1:list2; return prev-&gt;next; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"双指针","slug":"双指针","permalink":"http://spcablast.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"YP"},{"title":"Dailycode","slug":"20220327","date":"2022-03-26T16:00:00.000Z","updated":"2022-03-27T15:24:51.193Z","comments":true,"path":"2022/03/27/20220327/","link":"","permalink":"http://spcablast.club/2022/03/27/20220327/","excerpt":"","text":"15. 三数之和难度中等4540收藏分享切换为英文接收动态反馈 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，*使得 *a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 示例 2： 12输入：nums &#x3D; []输出：[] 示例 3： 12输入：nums &#x3D; [0]输出：[] 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; //先排序？ sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; for(int i = 0; i&lt; nums.size();i++)&#123; if(i &gt; 0 &amp;&amp; (nums[i] == nums[i - 1]))&#123; continue; &#125; int k = nums.size() - 1; int target = -nums[i]; for(int j = i + 1; j &lt;nums.size(); j++)&#123; if(j &gt; i+1 &amp;&amp; nums[j] == nums[j - 1])&#123; continue; &#125; while(j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target)&#123; k--; &#125; if(j == k)&#123; break; &#125; if(nums[j] + nums[k] == target)&#123; ans.push_back(&#123;nums[i], nums[j], nums[k]&#125;); &#125; &#125; &#125; return ans; &#125;&#125;; 141. 环形链表难度简单1437收藏分享切换为英文接收动态反馈 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; // unordered_set&lt;ListNode*&gt; cnt; // while(head)&#123; // if(cnt.count(head)) return true; // cnt.insert(head); // head = head-&gt;next; // &#125; // return false; if(head == NULL || head-&gt;next == NULL) return false; ListNode* slow = head; ListNode* fast = head-&gt;next; while(slow != fast)&#123; //只需要判断fast是不是空就行了，因为他走得快 if(fast == NULL || fast-&gt;next == NULL) return false; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return true; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"双指针","slug":"双指针","permalink":"http://spcablast.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"YP"},{"title":"testmysite","slug":"testmysite","date":"2022-03-26T02:43:32.000Z","updated":"2022-03-26T02:43:32.654Z","comments":true,"path":"2022/03/26/testmysite/","link":"","permalink":"http://spcablast.club/2022/03/26/testmysite/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"阅读","slug":"阅读","date":"2022-03-26T02:15:49.318Z","updated":"2022-03-03T00:30:53.503Z","comments":true,"path":"2022/03/26/阅读/","link":"","permalink":"http://spcablast.club/2022/03/26/%E9%98%85%E8%AF%BB/","excerpt":"","text":"阅读要不要先说自己的啊，好像前言说过了，那就 话不多说，直接引用 看书：看看而已，那些字都认得，句子也没有不通的，但是就是不知道它什么意思。 不知道什么意思有一个原因是我们积累不够，也有tobecontinue…","categories":[],"tags":[]},{"title":"报的错","slug":"报的错","date":"2022-03-26T02:15:49.313Z","updated":"2022-03-18T00:50:53.571Z","comments":true,"path":"2022/03/26/报的错/","link":"","permalink":"http://spcablast.club/2022/03/26/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###无限更新的报错VS: ###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。 dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错 Hexo: 报错： kex_exchange_identification: read: Connection reset by peerConnection reset by 20.205.243.166 port 22 本次原因：端口22被占用了，甚至没找到是谁占的，气人","categories":[],"tags":[]},{"title":"心理学部分","slug":"心理学部分","date":"2022-03-26T02:15:49.312Z","updated":"2022-02-16T11:00:20.305Z","comments":true,"path":"2022/03/26/心理学部分/","link":"","permalink":"http://spcablast.club/2022/03/26/%E5%BF%83%E7%90%86%E5%AD%A6%E9%83%A8%E5%88%86/","excerpt":"","text":"心理学 定义 开局先打个比方，我们不能准确的制约一个人体的每个原子的引力的相互作用的方程，但是对于所有实用的目的，一个人与地球之间的引力只需寥寥几个数值；类似的，我们不能解制约复杂的原子和分子行为的方程，但我们发明了一种称为化学的有效理论[1]，在未解释相互作用的每个细节的情形下，它提供化学反应中原子和分子如何行为的解释。 由此类推到人的情况中，因为我们不能确定我们行为的方程，所以我们利用人拥有自由意志的有效理论。研究我们的意志以及所引起的行为的是心理学。（可以适度的成功预言行为） 以上两段来自《大设计》，想说明心理学的定义，有一个我们无法具体理解的事物，但是我们能根据现象总结出来一个规律并用此预测这个事物的发展，这个事物是人的行为，这个用来预测他的模型叫心理学。 刚发现一件事，当我通过阅读理解一个文本的时候，我已经把这个文本转成我自己能理解的内容了，于是我认为他是易于理解的，但是对于他人来说，可能不是的。所以要与他人分享一个文本的时候，最好加上自己的观点，否则他人从这个文本中理解到的大概率与你不同。 又及，文本太长可能会降低读者的阅读兴趣。比如我用了500多字写了个引言 心理学全家福 好的，显然心理学有一大堆的分支，想了解一个事物必然逃不过了解他的发展史，就像俩人聊天总逃不过聊过去的经历。 本书认为冯特是“心理学之父”，因为他尝试用科学的方法观察感觉、表象、情感对人产生的影响，给心理学开了个好头。 显然，本书是想让心理学往科学靠一靠的 结构主义心理学 机能主义心理学 行为主义心理学 格式塔心理学 精神分析心理学 人本主义心理学 ##### ##### [1] 有效理论：一种被创造来模拟某种被观察的现象，而不用仔细的描述所有的基本过程","categories":[],"tags":[]},{"title":"typora测试","slug":"typora测试","date":"2022-03-26T02:15:49.308Z","updated":"2022-02-18T07:53:43.528Z","comments":true,"path":"2022/03/26/typora测试/","link":"","permalink":"http://spcablast.club/2022/03/26/typora%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Typora测试下载安装由于正式版收费，先下个老版本用用看下载地址 使用感受基础文字编辑功能： 写MarkDown语法也行，用自带的快捷方式也能达到一样的效果，整挺好，平时用到的功能都在 显示和外观： 字体和主题是相关的; github主题和Pixyll主题还行，就是字间距看着有点宽 下了个CatFish主题，用着不错下载地址 主题的修改： 文件-&gt;偏好设置-&gt;外观-&gt;打开主题文件夹; 这样就跳转到C:\\Users\\\\AppData\\Roaming\\Typora\\themes文件夹下，打开主题名.css文件，修改对应内容就行; 下载好的主题丢这个文件夹，再重启软件，主题就能用了 主题下载： 在打开主题文件夹旁边还有一个获取主题，他会使用浏览器跳转到http://theme.typora.io/，但是我加载不出来，科学上网也不行，很神秘; 不如直接在github上搜typra-themes","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2022-03-26T02:15:49.304Z","updated":"2022-12-20T01:35:51.415Z","comments":true,"path":"2022/03/26/Markdown_test/","link":"","permalink":"http://spcablast.club/2022/03/26/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;使用路过图床","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-26T01:52:01.402Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2022/03/26/hello-world/","link":"","permalink":"http://spcablast.club/2022/03/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Dailycode","slug":"20220326","date":"2022-03-25T16:00:00.000Z","updated":"2022-03-26T15:30:14.317Z","comments":true,"path":"2022/03/26/20220326/","link":"","permalink":"http://spcablast.club/2022/03/26/20220326/","excerpt":"","text":"912. 排序数组难度中等506收藏分享切换为英文接收动态反馈 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 12输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5] 示例 2： 12输入：nums &#x3D; [5,1,1,2,0,0]输出：[0,0,1,1,2,5] 提示： 1 &lt;= nums.length &lt;= 5 * 104 -5 * 104 &lt;= nums[i] &lt;= 5 * 104 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: // 各种排序 // 1.0 冒泡, 好的超时了，不愧是n方 // vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; // int len = nums.size(); // for(int i = 0; i&lt; len; ++i)&#123; // for(int j = i; j&lt; len; ++j)&#123; // if(nums[j] &lt; nums[i])&#123; // swap(nums[i], nums[j]); // &#125; // &#125; // &#125; // return nums; // &#125; // 1.1快排 // 需要一个函数，从k到l，比第一个数小的放左边，比他大的放右边 // int _sort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; // int flag = nums[end]; // int i = start - 1, j = 0; // for(j = start; j&lt; end; ++j)&#123; // if(nums[j] &gt;= flag)&#123; // &#125; // else&#123; // i++; // swap(nums[i], nums[j]); // &#125; // &#125; // swap(nums[i+1], nums[end]); // return i+1; // &#125; // // 随机挑一个座位标志能提高速度吗 // int randpick(vector&lt;int&gt;&amp; nums, int start, int end)&#123; // int i = rand() % (end - start + 1) + start; // swap(nums[end], nums[i]); // return _sort(nums, start, end); // &#125; // void dfs(vector&lt;int&gt;&amp; nums, int start, int end)&#123; // if(start &gt;= end) return; // int pos = randpick(nums, start, end); // // 小于的继续排 // dfs(nums, start, pos - 1); // // 大于的继续排 // dfs(nums, pos + 1, end); // &#125; // vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; // int len = nums.size(); // srand((unsigned)time(NULL)); // dfs(nums, 0, len - 1); // return nums; // &#125; &#125;; 215. 数组中的第K个最大元素难度中等1563收藏分享切换为英文接收动态反馈 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4输出: 4 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123; int q = randomPartition(a, l, r); if (q == index) &#123; return a[q]; &#125; else &#123; return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index); &#125; &#125; inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123; int i = rand() % (r - l + 1) + l; swap(a[i], a[r]); return partition(a, l, r); &#125; inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123; int x = a[r], i = l - 1; for (int j = l; j &lt; r; ++j) &#123; if (a[j] &lt;= x) &#123; swap(a[++i], a[j]); &#125; &#125; swap(a[i + 1], a[r]); return i + 1; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; srand(time(0)); return quickSelect(nums, 0, nums.size() - 1, nums.size() - k); &#125;&#125;; 地址","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"排序","slug":"排序","permalink":"http://spcablast.club/tags/%E6%8E%92%E5%BA%8F/"}],"author":"YP"},{"title":"Dailycode","slug":"20220323","date":"2022-03-22T16:00:00.000Z","updated":"2022-03-23T15:51:57.542Z","comments":true,"path":"2022/03/23/20220323/","link":"","permalink":"http://spcablast.club/2022/03/23/20220323/","excerpt":"","text":"146. LRU 缓存难度中等2043 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例： 1234567891011121314151617输入[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091typedef struct MyListNode&#123; int key,val; MyListNode* next; MyListNode* pre; MyListNode():key(0), val(0), next(nullptr), pre(nullptr)&#123;&#125; MyListNode(int x, int y):key(x), val(y), next(nullptr), pre(nullptr)&#123;&#125; &#125;myListNode;class LRUCache &#123;private: unordered_map&lt;int, MyListNode*&gt; m_map; myListNode* head; myListNode* tail; int capacity; int size;public: // 得有一个双向链表，插入放最后，更新了值之后拿出来放最后 // 一个指针指头，一个指针指尾，那是不是要一个头节点和一个尾节点 LRUCache(int capacity) &#123; size = 0; this-&gt;capacity = capacity; head = new myListNode(); tail = new myListNode(); head-&gt;next = tail; tail-&gt;pre = head; &#125; int get(int key) &#123; // 查询，没有返回-1， if(!m_map.count(key))&#123; return -1; &#125; // 有返回值,且调整优先级，放到队列末尾 myListNode* node = m_map[key]; MoveToTail(node); return node-&gt;val; &#125; void put(int key, int value) &#123; // 查询 ，没有直接插入到末尾 if(!m_map.count(key))&#123; myListNode *node = new myListNode(key, value); m_map[key] = node; ToTail(node); ++size; if(size &gt; capacity )&#123; MyListNode* node = decline(); m_map.erase(node-&gt;key); size--; delete node; &#125; &#125; // 修改节点值 else&#123; myListNode* node = m_map[key]; node-&gt;val = value; MoveToTail(node); &#125; &#125; void MoveToTail(myListNode* node)&#123; node-&gt;pre-&gt;next = node-&gt;next; node-&gt;next-&gt;pre = node-&gt;pre; ToTail(node); &#125; void ToTail(myListNode* node)&#123; tail-&gt;pre-&gt;next = node; node-&gt;pre = tail-&gt;pre; node-&gt;next = tail; tail-&gt;pre = node; &#125; void removeNode(myListNode* node)&#123; node-&gt;pre-&gt;next = node-&gt;next; node-&gt;next-&gt;pre = node-&gt;pre; &#125; myListNode* decline()&#123; myListNode* node = head-&gt;next; removeNode(node); return node; &#125; &#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"}],"author":"YP"},{"title":"Dailycode","slug":"20220319","date":"2022-03-18T16:00:00.000Z","updated":"2022-03-19T04:27:02.857Z","comments":true,"path":"2022/03/19/20220319/","link":"","permalink":"http://spcablast.club/2022/03/19/20220319/","excerpt":"","text":"3. 无重复字符的最长子串难度中等7147 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; //我觉得我行了，直接滑动窗口 if(s.size() == 0) return 0; int left = 0, right = 0; int len = s.size(); int t = 0, ans = 0, ret = 0; map&lt;char, int &gt; cnt; while(right &lt; len)&#123; //往右进一步 int c = s[right] - 'a'; cnt[c]++; ans++; if(cnt[c] &gt;= 2)&#123; &#125;else&#123; ret = max(ret, ans); &#125; while(cnt[c] &gt;= 2)&#123; ans--; cnt[s[left] - 'a']--; left++; &#125; right++; &#125; return ret; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://spcablast.club/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"YP"},{"title":"Dailycode","slug":"20220317","date":"2022-03-16T16:00:00.000Z","updated":"2022-03-17T13:24:34.928Z","comments":true,"path":"2022/03/17/20220317/","link":"","permalink":"http://spcablast.club/2022/03/17/20220317/","excerpt":"","text":"206. 反转链表难度简单2363 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; vector&lt;int&gt; list; int cnt = 0; ListNode* left = head; ListNode* right = head; while(left)&#123; list.push_back(left-&gt;val); left = left-&gt;next; cnt++; &#125; while(right)&#123; right-&gt;val = list[cnt-1]; cnt--; right = right-&gt;next; &#125; return head; &#125;&#125;; 25. K 个一组翻转链表难度困难1530 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶： 你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 12输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[2,1,4,3,5] 示例 2： 12输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; vector&lt;vector&lt;int&gt;&gt; list; int cnt = 0, total = 0; ListNode* left = head; ListNode* right = head; vector&lt;int&gt; temp; while(left)&#123; if(cnt &lt; k)&#123; temp.push_back(left-&gt;val); left = left-&gt;next; cnt++; total++; &#125; if(cnt == k)&#123; list.push_back(temp); temp.clear(); cnt = 0; &#125; &#125; int i = total - cnt; float index = 0; int numofvector = (i / k) ; int cicle = 0 ; while(cicle &lt; numofvector)&#123; index = ceil(i/k); for(int j = 0; j &lt; k; j++)&#123; right-&gt;val = list[cicle][k - j - 1]; //right-&gt;val = cnt; right = right-&gt;next; &#125; cicle++; &#125; return head; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"}],"author":"YP"},{"title":"Dailycode","slug":"20220316","date":"2022-03-15T16:00:00.000Z","updated":"2022-03-16T11:38:29.930Z","comments":true,"path":"2022/03/16/20220316/","link":"","permalink":"http://spcablast.club/2022/03/16/20220316/","excerpt":"","text":"给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。 如果 h 有多种可能的值，h 指数 是其中最大的那个。 示例 1： 输入：citations = [3,0,6,1,5]输出：3解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。示例 2： 输入：citations = [1,3,1]输出：1 1234567891011121314151617class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; &#x2F;&#x2F;做题先阅读理解 &#x2F;&#x2F;有n个数，其中h个数的值大于h，剩余的值小于h &#x2F;&#x2F;那我是不是排个序，欸先排 int ans &#x3D; 0, cnt &#x3D; 0; cnt &#x3D; citations.size(); sort(citations.begin(),citations.end());&#x2F;&#x2F;从小到大 for(int i &#x3D; 0 ; i &lt; cnt; ++i)&#123; if(citations[i] &gt;&#x3D; (cnt - i))&#123; ans &#x3D; max(cnt - i, ans); &#125; &#125; return ans; &#125;&#125;; 134. 加油站难度中等858 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; // int totol, ans = -1, index; // int num0fgas = gas.size(); // for(int i = 0; i &lt; num0fgas; i++)&#123;//初始点 // totol = 0; // int startindex = i; // int cnt = gas.size(); // index = 0; // while(cnt--)&#123; // totol += gas[startindex % num0fgas]; // totol -= cost[startindex % num0fgas]; // if(totol &lt; 0)&#123; // break; // &#125; // startindex++; // index++; // &#125; // if(totol &gt;= 0 &amp;&amp; index == num0fgas)&#123; // ans = i; // &#125; // &#125; // return ans; //我觉得我写的没问题啊，这不和题解一样，怎么超时了 int n = gas.size(); int i = 0; while (i &lt; n) &#123; int sumOfGas = 0, sumOfCost = 0; int cnt = 0; while (cnt &lt; n) &#123; int j = (i + cnt) % n; sumOfGas += gas[j]; sumOfCost += cost[j]; if (sumOfCost &gt; sumOfGas) &#123; break; &#125; cnt++; &#125; if (cnt == n) &#123; return i; &#125; else &#123; i = i + cnt + 1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"《热风》随感录二十五","slug":"热风（一）","date":"2022-03-15T16:00:00.000Z","updated":"2022-03-16T09:38:13.062Z","comments":true,"path":"2022/03/16/热风（一）/","link":"","permalink":"http://spcablast.club/2022/03/16/%E7%83%AD%E9%A3%8E%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"我一直从前曾见严又陵在一本什么书上发过议论，书名和原文都忘记了。大意是：“在北京道上，看见许多孩子，辗转于车轮、马足之间，很怕把他们碰死了，又想起他们将来怎样得了，很是害怕。”其实别的地方，也都如此，不过车马多少不同罢了。现在到了北京，这情形还未改变，我也时时发起这样的忧虑；一面又佩服严又陵究竟是“做”过赫胥黎《天演论》的，的确与众不同：是一个十九世纪末年中国感觉锐敏的人。穷人的孩子蓬头垢面的在街上转，阔人的孩子妖形妖势娇声娇气的在家里转。转得大了，都昏天黑地的在社会上转，同他们的父亲一样，或者还不如。所以看十来岁的孩子，便可以逆料二十年后中国的情形；看二十多岁的青年，——他们大抵有了孩子，尊为爹爹了，——便可以推测他儿子、孙子，晓得五十年后七十年后中国的情形。中国的孩子，只要生，不管他好不好，只要多，不管他才不才。生他的人，不负教他的责任。虽然“人口众多”这一句话，很可以闭了眼睛自负，然而这许多人口，便只在尘土中辗转，小的时候，不把他当人，大了以后，也做不了人。 已经2022，大家不生了，好 感觉最近“原生家庭”的话题比较多，年轻的一代意识到了家庭教育的重要性，这种情况在下一代应该能大为改善。现代心理学的一门分支- 家庭治疗 也发展的挺好。 中国娶妻早是福气，儿子多也是福气。所有小孩，只是他父母福气的材料，并非将来的“人”的萌芽，所以随便辗转，没人管他，因为无论如何，数目和材料的资格，总还存在。即使偶尔送进学堂，然而社会和家庭的习惯，尊长和伴侣的脾气，却多与教育反背，仍然使他与新时代不合。大了以后，幸而生存，也不过“仍旧贯如之何”，照例是制造孩子的家伙，不是“人”的父亲，他生了孩子，便仍然不是“人”的萌芽。最看不起女人的奥国人华宁该尔（Otto Weininger）曾把女人分成两大类：一是“母妇”，一是“娼妇”。照这分法，男人便也可以分作“父男”和“嫖男”两类了。但这父男一类，却又可以分成两种：其一是孩子之父，其一是“人”之父，第一种只会生，不会教，还带点嫖男的气息。第二种是生了孩子，还要想怎样教育，才能使这生下来的孩子，将来成一个完全的人。前清末年，某省初开师范学堂的时候，有一位老先生听了，很为诧异，便发愤说：“师何以还须受教，如此看来，还该有父范学堂了！”这位老先生，便以为父的资格，只要能生。能生这件事，自然便会，何须受教呢。却不知中国现在，正须父范学堂；这位先生便须编入初等第一年级。因为我们中国所多的是孩子之父；所以以后是只要“人”之父！","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"鲁迅全集","slug":"鲁迅全集","permalink":"http://spcablast.club/tags/%E9%B2%81%E8%BF%85%E5%85%A8%E9%9B%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20220315","date":"2022-03-14T16:00:00.000Z","updated":"2022-03-16T11:04:28.794Z","comments":true,"path":"2022/03/15/20220315/","link":"","permalink":"http://spcablast.club/2022/03/15/20220315/","excerpt":"","text":"2044. 统计按位或能得到最大值的子集数目难度中等94 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]（下标从 0 开始）。 示例 1： 12345输入：nums &#x3D; [3,1]输出：2解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：- [3]- [3,1] 示例 2： 123输入：nums &#x3D; [2,2,2]输出：7解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 &#x3D; 7 个子集。 示例 3： 123456789输入：nums &#x3D; [3,2,1,5]输出：6解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：- [3,5]- [3,1,5]- [3,2,5]- [3,2,1,5]- [2,5]- [2,1,5] 12345678910111213141516171819202122232425262728class Solution &#123;private: int ans; int cnt; vector&lt;int&gt; m_nums;public: int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) &#123; ans = INT_MIN; cnt = 0; m_nums = nums; dfs(0, 0); return cnt; &#125; void dfs(int pos, int orresult)&#123; if(pos == m_nums.size())&#123; if(orresult &gt; ans)&#123; ans = orresult; cnt = 1; &#125; else if(orresult == ans)&#123; cnt++; &#125; return; &#125; dfs(pos + 1, orresult | m_nums[pos]); dfs(pos + 1, orresult); &#125;&#125;; 26. 删除有序数组中的重复项难度简单2512 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums &#x3D; [...]; &#x2F;&#x2F; 输入数组int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; 长度正确的期望答案int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用assert k &#x3D;&#x3D; expectedNums.length;for (int i &#x3D; 0; i &lt; k; i++) &#123; assert nums[i] &#x3D;&#x3D; expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 1234567891011121314151617class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;阿巴阿巴阿巴阿巴 if(nums.size() &#x3D;&#x3D; 0) return 0; int slow &#x3D; 1; int fast &#x3D; 1; while(fast &lt; nums.size())&#123; if(nums[fast] !&#x3D; nums[fast - 1])&#123; nums[slow] &#x3D; nums[fast]; slow++; &#125; fast++; &#125; return slow; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"双指针","slug":"双指针","permalink":"http://spcablast.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"YP"},{"title":"Dailycode","slug":"20220314","date":"2022-03-13T16:00:00.000Z","updated":"2022-03-14T12:53:11.417Z","comments":true,"path":"2022/03/14/20220314/","link":"","permalink":"http://spcablast.club/2022/03/14/20220314/","excerpt":"","text":"599. 两个列表的最小索引总和难度简单195 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 示例 1: 123输入: list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]输出: [\"Shogun\"]解释: 他们唯一共同喜爱的餐厅是“Shogun”。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123; map&lt;string, int&gt; map1, map2; for(int i = 0; i&lt; list1.size(); i++)&#123; map1[list1[i]] = i; &#125; int minans = INT_MAX; vector&lt;string&gt; ans; for(int i = 0; i&lt; list2.size(); i++)&#123; if(map1.count(list2[i]) &gt; 0)&#123; if(minans &gt; map1[list2[i]] + i)&#123; ans.resize(0); minans = map1[list2[i]] + i; ans.push_back(list2[i]); &#125; else if(minans == map1[list2[i]] + i)&#123; ans.push_back(list2[i]); &#125; &#125; &#125; return ans; &#125;&#125;; 289. 生命游戏难度中等410 根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。 示例 1： 12输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]] 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; copy; int neighbors[3] = &#123;0, 1, -1&#125;;public: //我感觉会超时 int cellnum(int x, int y)&#123; int ret = 0; //不是当前点 for(int i = 0; i&lt; 3; i++)&#123; for(int j = 0; j&lt; 3; j++)&#123; if(!(neighbors[i] == 0 &amp;&amp; neighbors[j] == 0) )&#123; if((neighbors[i] + x &gt;= 0 &amp;&amp; neighbors[i] + x &lt; copy.size())&amp;&amp; (neighbors[j] + y &gt;= 0 &amp;&amp; neighbors[j] + y &lt; copy[0].size())&amp;&amp; copy[neighbors[i] + x][neighbors[j] + y] == 1)&#123; ret++; &#125; &#125; &#125; &#125; return ret; &#125; void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; for(int i = 0; i &lt; board.size() ; i++)&#123; vector&lt;int&gt; temp; for(int j = 0; j&lt; board[0].size(); j++)&#123; temp.push_back(board[i][j]); &#125; copy.push_back(temp); temp.clear(); &#125; for(int i = 0; i&lt;board.size() ; i++)&#123; for(int j = 0; j&lt;board[0].size(); j++)&#123; int ans = cellnum(i,j); if(ans == 3 &amp;&amp; board[i][j] == 0 )&#123; board[i][j] = 1; &#125; else if((ans &lt; 2 || ans &gt; 3)&amp;&amp; board[i][j])&#123; board[i][j] = 0; &#125; &#125; &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"《青年在选择职业时的考虑》","slug":"青年在选择职业时候的考虑","date":"2022-03-13T16:00:00.000Z","updated":"2022-03-14T13:06:04.275Z","comments":true,"path":"2022/03/14/青年在选择职业时候的考虑/","link":"","permalink":"http://spcablast.club/2022/03/14/%E9%9D%92%E5%B9%B4%E5%9C%A8%E9%80%89%E6%8B%A9%E8%81%8C%E4%B8%9A%E6%97%B6%E5%80%99%E7%9A%84%E8%80%83%E8%99%91/","excerpt":"","text":"自然本身给动物规定了它应该遵循的活动范围，动物也就安分地在这个范围内活动，不试图越出这个范围，甚至不考虑有其他什么范围的存在。神也给人指定了共同的目标──使人类和他自己趋于高尚，但是，神要人自己去寻找可以达到这个目标的手段；神让人在社会上选择一个最适合于他、最能使他和社会都得到提高的地位。 能有这样的选择是人比其他生物远为优越的地方，但是这同时也是可能毁灭人的一生、破坏他的一切计划并使他陷于不幸的行为。因此，认真地考虑这种选择──这无疑是开始走上生活道路而又不愿拿自己最重要的事业去碰运气的青年的首要责任。 每个人眼前都有一个目标，这个目标至少在他本人看来是伟大的，而且如果最深刻的信念，即内心深处的声音，认为这个目标是伟大的，那他实际上也是伟大的，因为神决不会使世人完全没有引导；神总是轻声而坚定地作启示。 但是，这声音很容易被淹没；我们认为是灵感的东西可能须臾而生，同样可能须臾而逝。也许，我们的幻想由然而生，我们的感情激动起来，我们的眼前浮想联翩，我们狂热地追求我们以为是神本身给我们指出的目标；但是，我们梦寐以求的东西很快就使我们厌恶──于是我们的整个存在也就毁灭了。 因此，我们应当认真考虑：所选择的职业是不是真正使我们受到鼓舞？我们的内心是不是同意？我们受到的鼓舞是不是一种迷误？我们认为是神的召唤的东西是不是一种自欺？但是，不找出鼓舞的来源本身，我们怎么能认清这些呢？ 伟大的东西是光辉的，光辉则引起虚荣心，而虚荣心容易给人鼓舞或者是一种我们觉得是鼓舞的东西；但是，被名利弄得鬼迷心窍的人，理智已无法支配他，于是他一头栽进那不可抗拒的欲念驱使他去的地方；他已经不再自己选择他在社会上的地位，而听任偶然机会和幻想去决定它。 我们的使命绝不是求得一个最足以炫耀的职业，因为它不是那种使我们长期从事而始终不会感到厌倦、始终不会松动、始终不会情绪低落的职业，相反，我们很快就会觉得，我们的愿望没有得到满足，我们理想没有实现，我们就将怨天尤人。 但是，不只是虚荣心能够引起对这种或那种职业突然的热情。也许，我们自己也会用幻想把这种职业美化，把它美化成人生所能提供的至高无上的东西。我们没有仔细分析它，没有衡量它的全部份量，即它让我们承担的重大责任；我们只是从远处观察它，然而从远处观察是靠不住的。 在这里，我们自己的理智不能给我们充当顾问，因为它既不是依靠经验，也不是依靠深入的观察，而是被感情欺骗，受幻想蒙蔽。然而，我们的目光应该投向哪里呢？在我们丧失理智的地方，谁来支持我们呢？ 是我们的父母， 他们走过了漫长的生活道路， 饱尝了人世的辛酸。──我们的心这样提醒我们。 如果我们通过冷静的研究，认清所选择的职业的全部份量，了解它的困难以后，我们仍然对它充满热情，我们仍然爱它。觉得自己适合它，那时我们就应该选择它，那时我们既不会受热情的欺骗，也不会仓促从事。 但是，我们并不能总是能够选择我们自认为适合的职业；我们在社会上的关系，还在我们有能力对它们起决定性影响以前就已经在某种程度上开始确立了。 我们的体质常常威胁我们，可是任何人也不敢藐视它的权利。 诚然，我们能够超越体质的限制，但这么一来，我们也就垮得更快；在这种情况下，我们就是冒险把大厦筑在松软的废墟上，我们的一生也就变成一场精神原则和肉体原则之间的不幸的斗争。但是，一个不能克服自身相互斗争的因素的人，又怎能抗拒生活的猛烈冲击，怎能安静地从事活动呢？然而只有从安静中才能产生伟大壮丽的事业，安静是唯一生长出成熟果实的土壤。 尽管我们由于体质不适合我们的职业，不能持久地工作，而且工作起来也很少乐趣，但是，为了恪尽职守而牺牲自己幸福的思想激励着我们不顾体弱去努力工作。如果我们选择了能力不能胜任的职业，那么我们决不能把它做好，我们很快就会自愧无能，并对自己说，我们是无用的人，是不能完成自己使命的社会成员。由此产生的必然结果就是妄自菲薄。还有比这更痛苦的感情吗？还有比这更难于靠外界的赐予来补偿的感情吗？妄自菲薄是一条毒蛇，它永远啮噬着我们心灵，吮吸着其中滋润生命的血液，注入厌世和绝望的毒液。 如果我们错误地估计了自己的能力，以为能够胜任经过周密考虑而选定的职业，那么这种错误将使我们受到惩罚。即使不受到外界指责，我们也会感到比外界指责更为可怕的痛苦。 如果我们把这一切都考虑过了，如果我们生活的条件容许我们选择任何一种职业；那么我们就可以选择一种能使我们最有尊严的职业；选择一种建立在我们深信其正确的思想上的职业；选择一种能给我们提供广阔场所来为人类进行活动、接近共同目标（对于这个目标来说，一切职业只不过是手段）即完美境地的职业。 尊严就是最能使人高尚起来、使他的活动和他的一切努力具有崇高品质的东西，就是使他无可非议、受到众人钦佩并高出于众人之上的东西。 但是，能给人以尊严的只有这样的职业，在从事这种职业时我们不是作为奴隶般的工具，而是在自己的领域内独立地进行创造；这种职业不需要有不体面的行动（哪怕只是表面上不体面的行动），甚至最优秀的人物也会怀着崇高的自豪感去从事它。最合乎这些要求的职业，并不一定是最高的职业，但总是最可取的职业。 但是，正如有失尊严的职业会贬低我们一样，那种建立在我们后来认为是错误的思想上的职业也一定使我们感到压抑。 这里，我们除了自我欺骗，别无解救办法，而以自我欺骗来解救又是多么糟糕！ 那些不是干预生活本身，而是从事抽象真理研究的职业，对于还没有坚定的原则和牢固、不可动摇的信念的青年是最危险的。同时，如果这些职业在我们心里深深地扎下了根，如果我们能够为它们的支配思想牺牲生命、竭尽全力，这些职业看来似乎还是最高尚的。 这些职业能够使才能适合的人幸福，但也必定使那些不经考虑、凭一时冲动就仓促从事的人毁灭。 相反，重视作为我们职业的基础的思想，会使我们在社会上占有较高的地位，提高我们本身的尊严，使我们的行为不可动摇。 一个选择了自己所珍视的职业的人，一想到他可能不称职时就会战战兢兢──这种人单是因为他在社会上所居地位是高尚的，他也就会使自己的行为保持高尚。 在选择职业时，我们应该遵循的主要指针是人类的幸福和我们自身的完美。不应认为，这两种利益是敌对的，互相冲突的，一种利益必须消灭另一种的；人类的天性本来就是这样的：人们只有为同时代人的完美、为他们的幸福而工作，才能使自己也达到完美。 如果一个人只为自己劳动，他也许能够成为著名的学者、大哲人、卓越诗人，然而他永远不能成为完美无疵的伟大人物。 历史承认那些为共同目标劳动因而自己变得高尚的人是伟大人物；经验赞美那些为大多数人带来幸福的人是最幸福的人；宗教本身也教诲我们，人人敬仰的理想人物，就曾为人类牺牲了自己──有谁敢否定这类教诲呢？ 如果我们选择了最能为人类福利而劳动的职业，那么，重担就不能把我们压倒，因为这是为大家而献身；那时我们所感到的就不是可怜的、有限的、自私的乐趣，我们的幸福将属于千百万人，我们的事业将默默地、但是永恒发挥作用地存在下去，面对我们的骨灰，高尚的人们将洒下热泪。 卡尔·马克思写于1835年8月12日 我：","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"马克思选集","slug":"马克思选集","permalink":"http://spcablast.club/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E9%80%89%E9%9B%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20220311","date":"2022-03-10T16:00:00.000Z","updated":"2022-03-11T13:00:07.849Z","comments":true,"path":"2022/03/11/20220311/","link":"","permalink":"http://spcablast.club/2022/03/11/20220311/","excerpt":"","text":"2049. 统计最高分的节点数目难度中等94 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 示例 1: 123456789输入：parents = [-1,2,0,2,0]输出：3解释：- 节点 0 的分数为：3 * 1 = 3- 节点 1 的分数为：4 = 4- 节点 2 的分数为：1 * 1 * 2 = 2- 节点 3 的分数为：4 = 4- 节点 4 的分数为：4 = 4最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: long max = 0; vector&lt;vector&lt;int&gt;&gt; child; int cnt = 0; int ans = 0; int dfs(int start)&#123; int size = cnt - 1; long socre = 1; for(int chi : child[start])&#123; int t = dfs(chi); socre *= t;//分数累乘 size -= t;//除了左右子树还剩多少节点数量 &#125; if(start != 0)&#123; socre *= size; &#125; if(socre == max)&#123; ans++; &#125; else if( socre &gt; max)&#123; max = socre; ans = 1; &#125; return cnt - size; &#125; int countHighestScoreNodes(vector&lt;int&gt;&amp; parents) &#123; //星号，星号，阅读理解题，看题看半天，爬 //节点的分数是节点子数大小的乘积 //所以先需要获取所有节点字数大小， //把所有节点分数存在map里，然后看最大的数量是几就行了 //怎么判断取走一个节点，去掉他相关节点之后剩了几棵树呢，那我是不是还得维护一个数组，存每一个节点的左右子数大小， cnt = parents.size(); child.resize(cnt); for(int i = 0; i&lt; cnt; i++)&#123; if(parents[i] != -1)&#123; child[parents[i]].push_back(i); &#125; &#125; dfs(0); return ans; &#125;&#125;; 144. 二叉树的前序遍历难度简单753 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 12输入：root &#x3D; [1,null,2,3]输出：[1,2,3] 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void dfs(TreeNode* root,vector&lt;int&gt; &amp; ans)&#123; if(root == nullptr) return; ans.push_back(root-&gt;val); dfs(root-&gt;left,ans); dfs(root-&gt;right,ans); &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; dfs(root, ans); return ans; &#125; &#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220310","date":"2022-03-09T16:00:00.000Z","updated":"2022-03-10T12:26:07.671Z","comments":true,"path":"2022/03/10/20220310/","link":"","permalink":"http://spcablast.club/2022/03/10/20220310/","excerpt":"","text":"93. 复原 IP 地址难度中等820 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和&quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#39;.&#39; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1： 12输入：s = \"25525511135\"输出：[\"255.255.11.135\",\"255.255.111.35\"] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; private: vector&lt;string&gt; ans; vector&lt;int&gt; ip;public: void dfs(string s, int seg, int startid)&#123; //已经四段，且到头了，存答案 if(seg == 4)&#123; if(startid == s.size())&#123; string temp; for(int i = 0; i&lt; 4; i++)&#123; temp += to_string(ip[i]); if(i!=3)&#123; temp += (\".\"); &#125; &#125; ans.push_back(move(temp)); &#125; return; &#125; //到头了就返回 if(startid == s.size())&#123; return; &#125; if(s[startid] == '0')&#123; ip[seg] = 0; dfs(s, seg+1, startid + 1); &#125; int add = 0; for(int endid = startid; endid &lt; s.size(); endid++)&#123; add = add*10 + (s[endid] - '0'); if(add &gt; 0 &amp;&amp; add &lt;= 0xFF)&#123; ip[seg] = add; dfs(s, seg+1, endid + 1); &#125; else &#123; break; &#125; &#125; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; //任意的，四位以上的字符串都能拿来试试啊 //缩小一下范围 //能不能用插入法，把四个点按顺序放进去 //先取4个数，一直到12个数，排列组合 //我想到了，滑动窗口，窗口大小从4到12，循环就完事儿了 //啊，不行 //来回溯吧 ip.resize(4); dfs(s, 0, 0); return ans; &#125;&#125;; 202. 快乐数难度简单846 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 12345678910111213141516171819202122class Solution &#123;public: bool isHappy(int n) &#123; int cicle = 9000; while(cicle--)&#123; if(n == 1)&#123; return true; &#125; else&#123; int temp = 0; int clo = n; while(clo)&#123; temp += (clo%10) * (clo%10); clo /= 10; &#125; n = temp; &#125; &#125; return false; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220309","date":"2022-03-08T16:00:00.000Z","updated":"2022-03-09T14:00:33.124Z","comments":true,"path":"2022/03/09/20220309/","link":"","permalink":"http://spcablast.club/2022/03/09/20220309/","excerpt":"","text":"43. 字符串相乘难度中等853 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。 示例 1: 12输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;输出: &quot;56088&quot; 提示： 1 &lt;= num1.length, num2.length &lt;= 200 num1 和 num2 只能由数字组成。 num1 和 num2 都不包含任何前导零，除了数字0本身。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == \"0\" || num2 == \"0\")&#123; return \"0\"; &#125; //然后用加法 string ans = \"0\"; int m = num1.size(), n = num2.size(); for (int i = n - 1; i &gt;= 0; i--) &#123; string curr; int add = 0; for (int j = n - 1; j &gt; i; j--) &#123; curr.push_back(0); &#125; int y = num2.at(i) - '0'; for (int j = m - 1; j &gt;= 0; j--) &#123; int x = num1.at(j) - '0'; int product = x * y + add; curr.push_back(product % 10); add = product / 10; &#125; while (add != 0) &#123; curr.push_back(add % 10); add /= 10; &#125; reverse(curr.begin(), curr.end()); for (auto &amp;c : curr) &#123; c += '0'; &#125; ans = addStrings(ans, curr); &#125; return ans; &#125; string addStrings(string num1, string num2) &#123; string ans; int addflag = 0; int m = num1.size() - 1, n = num2.size() - 1; while(m &gt;= 0 || n &gt;= 0)&#123; int temp; if(m &gt;= 0 &amp;&amp; n &gt;= 0)&#123; temp = num2[n] - '0' + num1[m] - '0' + addflag; &#125; else if(m &gt;= 0)&#123; temp = num1[m] - '0' + addflag; &#125; else if(n &gt;= 0)&#123; temp = num2[n] - '0' + addflag; &#125; if(temp &gt;= 10)&#123; addflag = 1; &#125; else addflag = 0; ans.push_back(temp % 10 + '0'); m--; n--; &#125; if(addflag) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 415. 字符串相加难度简单514 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。 示例 1： 12输入：num1 = \"11\", num2 = \"123\"输出：\"134\" 123456789101112131415161718192021222324252627282930class Solution &#123;public: string addStrings(string num1, string num2) &#123; string ans; int addflag = 0; int m = num1.size() - 1, n = num2.size() - 1; while(m &gt;= 0 || n &gt;= 0)&#123; int temp; if(m &gt;= 0 &amp;&amp; n &gt;= 0)&#123; temp = num2[n] - '0' + num1[m] - '0' + addflag; &#125; else if(m &gt;= 0)&#123; temp = num1[m] - '0' + addflag; &#125; else if(n &gt;= 0)&#123; temp = num2[n] - '0' + addflag; &#125; if(temp &gt;= 10)&#123; addflag = 1; &#125; else addflag = 0; ans.push_back(temp % 10 + '0'); m--; n--; &#125; if(addflag) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220308","date":"2022-03-07T16:00:00.000Z","updated":"2022-03-09T13:59:14.987Z","comments":true,"path":"2022/03/08/20220308/","link":"","permalink":"http://spcablast.club/2022/03/08/20220308/","excerpt":"","text":"504. 七进制数难度简单157 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。 示例 1: 12输入: num &#x3D; 100输出: &quot;202&quot; 示例 2: 12输入: num &#x3D; -7输出: &quot;-10&quot; 提示： -107 &lt;= num &lt;= 107 12345678910111213141516171819class Solution &#123;public: string convertToBase7(int num) &#123; if(num == 0) return \"0\"; string s; bool neg = false; if(num &lt; 0) neg = true; int temp = 0; num = abs(num); while(num)&#123; temp = num%7; s.push_back(temp + '0'); num/=7; &#125; if(neg) s.push_back('-'); reverse(s.begin(), s.end()); return s; &#125;&#125;; 395. 至少有 K 个重复字符的最长子串难度中等648 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 123输入：s &#x3D; &quot;aaabb&quot;, k &#x3D; 3输出：3解释：最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。 示例 2： 123输入：s = \"ababbc\", k = 2输出：5解释：最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int longestSubstring(string s, int k) &#123; //用一个数组，和s长度一样，每一位表示前边的算不算 int ret = 0; int n = s.length(); //分别计算1个字母到26个字母重复三次的结果，返回最大值 for (int t = 1; t &lt;= 26; t++) &#123; //滑动窗口 int l = 0, r = 0; //字母计数 vector&lt;int&gt; cnt(26, 0); //窗口内字母种类 int tot = 0; //窗口内没有达到三个的字母种类数量 int less = 0; //往右滑到头 while (r &lt; n) &#123; cnt[s[r] - 'a']++; //说明有个字母刚进窗口，tot加一，未达到3的字母加一 if (cnt[s[r] - 'a'] == 1) &#123; tot++; less++; &#125; //说明有一个重复到了k次，less可以减了 if (cnt[s[r] - 'a'] == k) &#123; less--; &#125; //窗口的字母种类比预设的多，左边往右 while (tot &gt; t) &#123; cnt[s[l] - 'a']--; //有一个字母从k+到了k- if (cnt[s[l] - 'a'] == k - 1) &#123; less++; &#125; //有一个字母一个都没了 if (cnt[s[l] - 'a'] == 0) &#123; tot--; less--; &#125; l++; &#125; //窗口的字母都到了k个 if (less == 0) &#123; ret = max(ret, r - l + 1); &#125; r++; &#125; &#125; return ret; // 作者：LeetCode-Solution // 链接：https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/zhi-shao-you-kge-zhong-fu-zi-fu-de-zui-c-o6ww/ &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220306","date":"2022-03-05T16:00:00.000Z","updated":"2022-03-06T12:42:39.097Z","comments":true,"path":"2022/03/06/20220306/","link":"","permalink":"http://spcablast.club/2022/03/06/20220306/","excerpt":"","text":"2100. 适合打劫银行的日子难度中等89 你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。 如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子： 第 i 天前和后都分别至少有 time 天。 第 i 天前连续 time 天警卫数目都是非递增的。 第 i 天后连续 time 天警卫数目都是非递减的。 更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]. 请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。 示例 1： 123456输入：security = [5,3,3,3,5,6,2], time = 2输出：[2,3]解释：第 2 天，我们有 security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4] 。第 3 天，我们有 security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5] 。没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: // int _time; // bool isacc(int endidex, vector&lt;int&gt;&amp; security)&#123; // for(int i = endidex - _time + 1; i&lt;= endidex; i++)&#123; // if(security[i] &lt; security[i+1])&#123; // return false; // &#125; // &#125; // return true; // &#125; // bool isdec(int startidex, vector&lt;int&gt;&amp; security)&#123; // for(int i = startidex; i&lt;= startidex + _time - 1; i++)&#123; // if(security[i] &gt; security[i + 1])&#123; // return false; // &#125; // &#125; // return true; // &#125; vector&lt;int&gt; goodDaysToRobBank(vector&lt;int&gt;&amp; security, int time) &#123; // _time = time; // vector&lt;int&gt; ans; // if(security.size() &lt; time*2) return ans; // for(int i = time; i&lt; security.size() - time; i++)&#123; // if(isacc(i - 1, security) &amp;&amp; isdec(i , security)) ans.push_back(i); // &#125; // return ans; // &#125; //超时了，黑脸.jpg int n = security.size(); vector&lt;int&gt; left(n); vector&lt;int&gt; right(n); for (int i = 1; i &lt; n; i++) &#123; if (security[i] &lt;= security[i - 1]) &#123; left[i] = left[i - 1] + 1; &#125; if (security[n - i - 1] &lt;= security[n - i]) &#123; right[n - i - 1] = right[n - i] + 1; &#125; &#125; vector&lt;int&gt; ans; for (int i = time; i &lt; n - time; i++) &#123; if (left[i] &gt;= time &amp;&amp; right[i] &gt;= time) &#123; ans.emplace_back(i); &#125; &#125; return ans; &#125;&#125;; 231. 2 的幂难度简单466 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 123输入：n &#x3D; 1输出：true解释：20 &#x3D; 1 示例 2： 123输入：n = 16输出：true解释：24 = 16 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220305","date":"2022-03-04T16:00:00.000Z","updated":"2022-03-05T06:15:18.081Z","comments":true,"path":"2022/03/05/20220305/","link":"","permalink":"http://spcablast.club/2022/03/05/20220305/","excerpt":"","text":"521. 最长特殊序列 Ⅰ难度简单155 给你两个字符串 a 和 b，请返回 这两个字符串中 *最长的特殊序列*** 。如果不存在，则返回 -1 。 「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。 字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。 例如，&quot;abc&quot; 是 &quot;aebdc&quot; 的子序列，因为删除 &quot;a***e***b***d\\***c&quot; 中斜体加粗的字符可以得到 &quot;abc&quot; 。 &quot;aebdc&quot; 的子序列还包括 &quot;aebdc&quot; 、 &quot;aeb&quot; 和 &quot;&quot; (空字符串)。 示例 1： 123输入: a = \"aba\", b = \"cdc\"输出: 3解释: 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。 阅读理解失败了，这题有毒 123456789101112131415161718class Solution &#123;public: int findLUSlength(string a, string b) &#123; //我只要一个字母一个字母比过去就行了，在b里找a第一个出现的 if(a.size() == 0 || b.size() ==0)&#123; return max(a.size(), b.size()); &#125; int len = 0 , bindex = 0, ans; while(len &lt; a.size() &amp;&amp; bindex &lt; b.size())&#123; // while(b[bindex] != a[len] &amp;&amp; bindex &lt; b.size())&#123; bindex++; &#125; len++; &#125; return a == b ? -1 : max(a.size(), b.size()); &#125;&#125;; 2145. 统计隐藏数组数目难度中等12 给你一个下标从 0 开始且长度为 n 的整数数组 differences ，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值 。更正式的表述为：我们将隐藏数组记作 hidden ，那么 differences[i] = hidden[i + 1] - hidden[i] 。 同时给你两个整数 lower 和 upper ，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。 比方说， 1differences &#x3D; [1, -3, 4] ， 1lower &#x3D; 1 ， 1upper &#x3D; 6 ，那么隐藏数组是一个长度为 14 且所有值都在 11 和 16 （包含两者）之间的数组。 [3, 4, 1, 5] 和 [4, 5, 2, 6] 都是符合要求的隐藏数组。 [5, 6, 3, 7] 不符合要求，因为它包含大于 6 的元素。 [1, 2, 3, 4] 不符合要求，因为相邻元素的差值不符合给定数据。 请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。 示例 1： 123456输入：differences &#x3D; [1,-3,4], lower &#x3D; 1, upper &#x3D; 6输出：2解释：符合要求的隐藏数组为：- [3, 4, 1, 5]- [4, 5, 2, 6]所以返回 2 。 12345678910111213141516171819class Solution &#123;public: int numberOfArrays(vector&lt;int&gt;&amp; differences, int lower, int upper) &#123; //我又有一个数组，给一个初始值，按顺序加数组的每一个元素，就是隐藏数组了， //那我只需要算出加完所有的之后，改变的量，就好了 int ans = 0, maxelement = 0, minelement = 0; for(int num : differences)&#123; ans += num; minelement = min(ans, minelement); maxelement = max(ans, maxelement); if(maxelement - minelement &gt; upper - lower)&#123; return 0; &#125; &#125; int temp = maxelement - minelement; return abs(upper - lower) - temp &gt;= 0 ? upper - lower - temp + 1: 0; //哎呀，我还得存一个最小的值 &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220303","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-03T13:00:16.625Z","comments":true,"path":"2022/03/03/20220303/","link":"","permalink":"http://spcablast.club/2022/03/03/20220303/","excerpt":"","text":"258. 各位相加难度简单 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。 示例 1: 123456输入: num &#x3D; 38输出: 2 解释: 各位相加的过程为：38 --&gt; 3 + 8 --&gt; 1111 --&gt; 1 + 1 --&gt; 2由于 2 是一位数，所以返回 2。 示例 1: 12输入: num &#x3D; 0输出: 0 123456789101112131415class Solution &#123;public: int addDigits(int num) &#123; int temp = 0; while(num / 10 != 0)&#123; while(num)&#123; temp += (num % 10); num /= 10; &#125; num = temp; temp = 0; &#125; return num; &#125;&#125;; 61. 旋转链表难度中等727 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 12输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2输出：[4,5,1,2,3] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; // //先连成环，再断开 // if(head-&gt;next == nullptr) return head; // int len = 1; // ListNode* temp = head; // ListNode* end = head; // while(temp-&gt;next)&#123; // len++; // temp = temp-&gt;next; // &#125; // temp-&gt;next = head; // if(k == len) return head; // else if(k &gt; len) k = k % len; // int cur = 0; // while(cur &lt; len - k - 1)&#123; // end = head-&gt;next; // cur++; // &#125; // ListNode* ans = end-&gt;next; // end-&gt;next = nullptr; // return ans; if (k == 0 || head == nullptr || head-&gt;next == nullptr) &#123; return head; &#125; int n = 1; ListNode* iter = head; while (iter-&gt;next != nullptr) &#123; iter = iter-&gt;next; n++; &#125; int add = n - k % n; if (add == n) &#123; return head; &#125; iter-&gt;next = head; while (add--) &#123; iter = iter-&gt;next; &#125; ListNode* ret = iter-&gt;next; iter-&gt;next = nullptr; return ret; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"}],"author":"YP"},{"title":"Dailycode","slug":"20220302","date":"2022-03-01T16:00:00.000Z","updated":"2022-03-03T11:09:40.480Z","comments":true,"path":"2022/03/02/20220302/","link":"","permalink":"http://spcablast.club/2022/03/02/20220302/","excerpt":"","text":"57. 插入区间难度中等557 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 12输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; //可以先找新区间左端应该插入的位置，再找右端应该在的位置，每前进一位加加， int flag = 0, left = newInterval[0], right = newInterval[1]; vector&lt;vector&lt;int&gt;&gt; ans; for(vector&lt;int&gt;&amp; temp : intervals)&#123; if(temp[0] &gt; right)&#123; if(!flag)&#123; ans.push_back(&#123;left,right&#125;); flag = 1; &#125; ans.push_back(temp); &#125; else if(temp[1] &lt; left)&#123; ans.push_back(temp); &#125; else&#123; left = min(left,temp[0]); right = max(right, temp[1]); &#125; &#125; if(!flag)&#123; ans.push_back(&#123;left,right&#125;); &#125; return ans; &#125;&#125;; 66. 加一难度简单930 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 123输入：digits &#x3D; [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。 示例 2： 123输入：digits &#x3D; [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。 示例 3： 12输入：digits &#x3D; [0]输出：[1] 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int n = digits.size(); while(n &amp;&amp; ++digits[--n] == 10) digits[n] = 0; if(digits[0] == 0) digits.insert(begin(digits), 1); return digits; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220301","date":"2022-02-28T16:00:00.000Z","updated":"2022-03-01T12:15:34.088Z","comments":true,"path":"2022/03/01/20220301/","link":"","permalink":"http://spcablast.club/2022/03/01/20220301/","excerpt":"","text":"6. Z 字形变换难度中等1556 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s &#x3D; &quot;A&quot;, numRows &#x3D; 1输出：&quot;A&quot; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string convert(string s, int numRows) &#123; //直接模拟 vector&lt;vector&lt;int&gt;&gt; ans(numRows, vector&lt;int&gt;()); int i = 0; int flag = 1; while(i &lt;= s.size() - 1)&#123; if(flag % 2 == 1)&#123; for(int j = 0; j&lt; numRows; j++)&#123; if(i &gt; s.size() - 1) break; ans[j].push_back(s[i]); i++; &#125; flag++; &#125; else&#123; for(int j = numRows - 2; j &gt; 0; j--)&#123; if(i &gt; s.size() - 1) break; ans[j].push_back(s[i]); i++; &#125; flag++; &#125; &#125; string ret; for(int l = 0; l&lt; numRows; l++)&#123; for(int j = 0; j&lt; ans[l].size() ; ++j)&#123; ret.push_back(ans[l][j]); &#125; &#125; return ret; &#125;&#125;; 27. 移除元素难度简单1194 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 12345678910111213141516171819202122232425262728class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; // int ans = 0, temp; // for(int i = 0; i &lt; nums.size() - ans; i++)&#123; // if(nums[i] == val)&#123; // ans++; // nums[i] = nums[nums.size() - ans - 1]; // if(nums[i] == val)&#123; // ans++; // i--; // &#125; // &#125; // &#125; // return ans; int left = 0, right = nums.size(); while(left &lt; right)&#123; if(nums[left] == val)&#123; nums[left] = nums[right - 1]; right -- ; &#125; else &#123; left++; &#125; &#125; return left; &#125;&#125;; 今日吐槽：该run了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220228","date":"2022-02-27T16:00:00.000Z","updated":"2022-03-01T00:39:22.616Z","comments":true,"path":"2022/02/28/20220228/","link":"","permalink":"http://spcablast.club/2022/02/28/20220228/","excerpt":"","text":"102. 二叉树的层序遍历难度中等1193 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 12输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root &#x3D; [1]输出：[[1]] 示例 3： 12输入：root &#x3D; []输出：[] 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: // void dfs(TreeNode* root, vector&lt;int&gt;&amp; ans)&#123; // if(!root) return; // ans.push_back(root-&gt;val); // dfs(root-&gt;left, ans); // dfs(root-&gt;right, ans); // &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; //层序遍历那就是，前序遍历，可以用dfs也可以用队列 vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; // dfs(root, ans); // return ans; //过分了，居然要分开来显示，白写了，会不会看题目啊， //那还是得队列 queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int n = q.size(); ans.push_back(vector&lt;int&gt; ()); for(int i = 0; i&lt;n; i++)&#123; auto node = q.front(); q.pop(); ans.back().push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return ans; &#125;&#125;; 110. 平衡二叉树难度简单900 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 12输入：root &#x3D; [3,9,20,null,null,15,7]输出：true 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: // int getHeight(TreeNode* root)&#123; // if(root == NULL) return 0; // return max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1; // &#125; // bool isBalanced(TreeNode* root) &#123; // if(root == NULL) return true; // return getHeight(root-&gt;left) - getHeight(root-&gt;right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;right) &amp;&amp; isBalanced(root-&gt;left); // &#125; //好呆啊，忘了取绝对值了，困了困了 int height(TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; return max(height(root-&gt;left), height(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if (root == NULL) &#123; return true; &#125; return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; &#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220227","date":"2022-02-26T16:00:00.000Z","updated":"2022-02-27T14:09:02.991Z","comments":true,"path":"2022/02/27/20220227/","link":"","permalink":"http://spcablast.club/2022/02/27/20220227/","excerpt":"","text":"553. 最优除法难度中等168 给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 / 3 / 4 。 但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。 示例： 123456789101112输入: [1000,100,10,2]输出: &quot;1000&#x2F;(100&#x2F;10&#x2F;2)&quot;解释:1000&#x2F;(100&#x2F;10&#x2F;2) &#x3D; 1000&#x2F;((100&#x2F;10)&#x2F;2) &#x3D; 200但是，以下加粗的括号 &quot;1000&#x2F;((100&#x2F;10)&#x2F;2)&quot; 是冗余的，因为他们并不影响操作的优先级，所以你需要返回 &quot;1000&#x2F;(100&#x2F;10&#x2F;2)&quot;。其他用例:1000&#x2F;(100&#x2F;10)&#x2F;2 &#x3D; 501000&#x2F;(100&#x2F;(10&#x2F;2)) &#x3D; 501000&#x2F;100&#x2F;10&#x2F;2 &#x3D; 0.51000&#x2F;100&#x2F;(10&#x2F;2) &#x3D; 2 说明: 输入数组的长度在 [1, 10] 之间。 数组中每个元素的大小都在 [2, 1000] 之间。 每个测试用例只有一个最优除法解。 1234567891011121314151617181920class Solution &#123;public: string optimalDivision(vector&lt;int&gt;&amp; nums) &#123; //那就是要让后边的数尽可能小，如果能小于1那就更赚 //惊了，因为都大于1，所以直接分子只能是nums[0]，分子凑成最小的，每除以一个大于一的数就变小，所以分母的顺序不影响结果 int n = nums.size(); if (n == 1) &#123; return to_string(nums[0]); &#125; if (n == 2) &#123; return to_string(nums[0]) + \"/\" + to_string(nums[1]); &#125; string res = to_string(nums[0]) + \"/(\" + to_string(nums[1]); for (int i = 2; i &lt; n; i++) &#123; res.append(\"/\" + to_string(nums[i])); &#125; res.append(\")\"); return res; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220226","date":"2022-02-25T16:00:00.000Z","updated":"2022-02-26T12:02:10.188Z","comments":true,"path":"2022/02/26/20220226/","link":"","permalink":"http://spcablast.club/2022/02/26/20220226/","excerpt":"","text":"2016. 增量元素之间的最大差值难度简单20 给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。 返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。 示例 1： 12345输入：nums &#x3D; [7,1,5,4]输出：4解释：最大差值出现在 i &#x3D; 1 且 j &#x3D; 2 时，nums[j] - nums[i] &#x3D; 5 - 1 &#x3D; 4 。注意，尽管 i &#x3D; 1 且 j &#x3D; 0 时 ，nums[j] - nums[i] &#x3D; 7 - 1 &#x3D; 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。 示例 2： 1234输入：nums &#x3D; [9,4,3,2]输出：-1解释：不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。 1234567891011121314151617181920class Solution &#123;public: int max(int l, vector&lt;int&gt; &amp; nums)&#123; int maxnum = INT_MIN; for(int i = l; i &lt; nums.size(); ++i)&#123; maxnum = maxnum &gt; nums[i] ? maxnum : nums[i]; &#125; return maxnum; &#125; int maximumDifference(vector&lt;int&gt;&amp; nums) &#123; int sizeofnum = nums.size(); int minnum = INT_MAX, maxnum = INT_MIN, ans = 0; for(int i = 0; i&lt; sizeofnum; i++)&#123; minnum = minnum &lt; nums[i] ? minnum : nums[i]; int temp = max(i, nums) - minnum; ans = ans &gt; temp? ans : temp; &#125; return ans &gt; 0? ans : -1; &#125;&#125;; 98. 验证二叉搜索树难度中等1429 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 12输入：root &#x3D; [2,1,3]输出：true 示例 2： 123输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool dfs(TreeNode* root, long int minroot, long int maxroot)&#123; //是叶子节点，返回true if(root == nullptr) return true; if(root-&gt;val &lt;= minroot || root-&gt;val &gt;= maxroot)&#123; return false; &#125; return dfs(root-&gt;left, minroot, root-&gt;val) &amp;&amp; dfs(root-&gt;right, root-&gt;val, maxroot); &#125; bool isValidBST(TreeNode* root) &#123; //左子树小于根节点 //右子数大于根节点 //左子数往左好判断，往右的话要大于当前根节点但是要小于历史根节点，历史根节点里取一个最小的，要小于这个最小的 //右子树同理，左要大于历史根节点里最大的,右要大于根节点 if(root == nullptr) return true; return dfs(root, LONG_MIN, LONG_MAX); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220224","date":"2022-02-23T16:00:00.000Z","updated":"2022-02-24T13:03:18.370Z","comments":true,"path":"2022/02/24/20220224/","link":"","permalink":"http://spcablast.club/2022/02/24/20220224/","excerpt":"","text":"97. 交错字符串难度中等639 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串： s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| &lt;= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ... 注意：a + b 意味着字符串 a 和 b 连接。 示例 1： 12输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;输出：true 示例 2： 12输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;输出：false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; //欸，想到一个好主意，只要统计每个字符的个数，对比一下，不就有了 // unordered_map&lt;char, int&gt; ab; // int cnt = 0; // for(char c: s1)&#123; // ++ab[c]; // ++cnt; // &#125; // for(char c: s2)&#123; // ++ab[c]; // ++cnt; // &#125; // for(char c:s3)&#123; // if(ab.count(c)&gt;0)&#123; // --ab[c]; // --cnt; // &#125; // else return false; // &#125; // return cnt == 0; //错了，海妖考虑顺序，啊我死了 //那我还有一个主意，c开始遍历，ab看谁的开头和他一样，一样就指针前进， // int pointA = 0; // int pointB = 0, len1 = s1.size(), len2 = s2.size(), cnt = 0; // for(char c : s3)&#123; // int temp = cnt; // if(pointA&lt;len1)&#123; // if(s1[pointA] == c)&#123; // pointA++; // cnt++; // continue; // &#125; // &#125; // if(pointB&lt;len2)&#123; // if(s2[pointB] == c)&#123; // pointB++; // cnt++; // continue; // &#125; // &#125; // if(temp == cnt) return false; // &#125; // return cnt == s3.size() -1; //也有问题，有先取还是先取b的问题，哈哈哈哈哈哈哈给爷丝 //看看题解 int m = s1.size() , n = s2.size() , t = s3.size() ; if(m+n!=t) return false; auto f = vector&lt;vector&lt;int&gt;&gt;(m+1, vector&lt;int&gt;(n+1,false)); f[0][0] = true; for(int i = 0; i&lt;=m; i++)&#123; for(int j = 0; j&lt;=n;j++)&#123; if(i&gt;0)&#123; f[i][j] |= (f[i-1][j] &amp;&amp; s1[i - 1] == s3[i+j-1] ); &#125; if(j&gt;0)&#123; f[i][j] |= (f[i][j-1] &amp;&amp; s2[j - 1] == s3[i+j-1] ); &#125; &#125; &#125; return f[m][n]; &#125;&#125;; 101. 对称二叉树难度简单1752 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 12输入：root &#x3D; [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root &#x3D; [1,2,2,null,3,null,3]输出：false 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool dfs(TreeNode* l, TreeNode* r)&#123; if(!l &amp;&amp; !r) return true; if(!l || !r) return false; if(l-&gt;val == r-&gt;val)&#123; return dfs(l-&gt;left, r-&gt;right) &amp;&amp; dfs(r-&gt;right, l-&gt;left); &#125; else return false; &#125; bool isSymmetric(TreeNode* root) &#123; //中序遍历就好了 return dfs(root, root); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20220223","date":"2022-02-22T16:00:00.000Z","updated":"2022-02-23T12:11:38.775Z","comments":true,"path":"2022/02/23/20220223/","link":"","permalink":"http://spcablast.club/2022/02/23/20220223/","excerpt":"","text":"917. 仅仅反转字母难度简单148 给你一个字符串 s ，根据下述规则反转字符串： 所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。 示例 1： 12输入：s &#x3D; &quot;ab-cd&quot;输出：&quot;dc-ba&quot; 示例 2： 12输入：s &#x3D; &quot;a-bC-dEf-ghIj&quot;输出：&quot;j-Ih-gfE-dCba&quot; 96. 不同的二叉搜索树难度中等1560 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 12输入：n &#x3D; 3输出：5 示例 2： 12输入：n &#x3D; 1输出：1 1234567891011121314151617181920212223242526class Solution &#123;public: int numTrees(int n) &#123; //这不得，动态规划 //假设我有一个数，1 //2个，1可以做子节点，2可以做子节点，有两种 //3个，2的两种都拿来做子节点，加上3作为他俩的子节点 //我靠，我来一遍，只有一个数是1中，2个数是1为根挂2，2为根挂1， //3个数是，1为根右边挂23，2为根左右挂13，3为根左边挂12 //所以来一个n，每一个作为根 //F(1) + F(2) + ... +F(n) //F(1) = G[0]*G[n-1]///特殊的，n = 3,G[3] = F[3] = G[0]*G[2] //F[2] = G[1]*G[n-2] //F[3] = G[2]*G[n-3] //F[4] = G[3]*G[n-4] vector&lt;int&gt; G(n+1); G[0] = 1; G[1] = 1; for(int i = 2; i&lt;= n; i++)&#123; for(int j = 1; j&lt;=i; j++)&#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220222","date":"2022-02-21T16:00:00.000Z","updated":"2022-02-24T11:52:33.094Z","comments":true,"path":"2022/02/22/20220222/","link":"","permalink":"http://spcablast.club/2022/02/22/20220222/","excerpt":"","text":"838. 推多米诺难度中等254 n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。 每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。 如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。 就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。 给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中： dominoes[i] = &#39;L&#39;，表示第 i 张多米诺骨牌被推向左侧， dominoes[i] = &#39;R&#39;，表示第 i 张多米诺骨牌被推向右侧， dominoes[i] = &#39;.&#39;，表示没有推动第 i 张多米诺骨牌。 返回表示最终状态的字符串。 示例 1： 123输入：dominoes &#x3D; &quot;RR.L&quot;输出：&quot;RR.L&quot;解释：第一张多米诺骨牌没有给第二张施加额外的力。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: string pushDominoes(string dominoes) &#123; //重点，同时推，一秒后启动下一个 //如果是 1 0 0 0 0 1，这样就在中间会和了， //如果是 1 0 0 0 0 0 1，不管奇数偶数都会在中间碰面，所以只需要列出所有的初始会往左往右的，同向的不用管，反向的找距离最近的，在中间会合 int n = dominoes.size(), i = 0; char left = 'L';//默认第一个是往左推 while (i &lt; n) &#123; int j = i; while (j &lt; n &amp;&amp; dominoes[j] == '.') &#123; // 找到一段连续的没有被推动的骨牌 j++; &#125; char right = j &lt; n ? dominoes[j] : 'R';//默认最后一个是往右推 if (left == right) &#123; // 方向相同，那么这些竖立骨牌也会倒向同一方向 while (i &lt; j) &#123; dominoes[i++] = right; &#125; &#125; else if (left == 'R' &amp;&amp; right == 'L') &#123; // 方向相对，那么就从两侧向中间倒 int k = j - 1; while (i &lt; k) &#123;//中间的.不用变 dominoes[i++] = 'R'; dominoes[k--] = 'L'; &#125; &#125; left = right; i = j + 1; &#125; return dominoes; &#125;&#125;; 1995. 统计特殊四元组难度简单103 给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ： nums[a] + nums[b] + nums[c] == nums[d] ，且 a &lt; b &lt; c &lt; d 示例 1： 123输入：nums &#x3D; [1,2,3,6]输出：1解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 &#x3D;&#x3D; 6 。 示例 2： 123输入：nums &#x3D; [3,3,6,4,5]输出：0解释：[3,3,6,4,5] 中不存在满足要求的四元组。 示例 3： 1234567输入：nums &#x3D; [1,1,1,3,5]输出：4解释：满足要求的 4 个四元组如下：- (0, 1, 2, 3): 1 + 1 + 1 &#x3D;&#x3D; 3- (0, 1, 3, 4): 1 + 1 + 3 &#x3D;&#x3D; 5- (0, 2, 3, 4): 1 + 1 + 3 &#x3D;&#x3D; 5- (1, 2, 3, 4): 1 + 1 + 3 &#x3D;&#x3D; 5 123456789101112131415161718192021222324class Solution &#123;public: int countQuadruplets(vector&lt;int&gt;&amp; nums) &#123; //三个三个得加起来，如果结果能在后边找到就结果加一 //好像太暴力了，能优化嘛 //首先最大值要在 //要不分几组，一个数，两个数的和， int n = nums.size(); int ans = 0; unordered_map&lt;int, int&gt; cnt; for(int b = n - 3;b &gt;= 1; --b )&#123;//从后往前遍历，可以让哈希表从小往大扩 for(int d = b + 2; d &lt; n; d++)&#123; ++cnt[nums[d] - nums[b + 1]];//存d - c &#125; for(int a = 0; a &lt; b; ++a)&#123; int sum = nums[a] + nums[b]; if(cnt.count(sum))&#123; ans+= cnt[sum]; &#125; &#125; &#125; return ans; &#125;&#125;; 今日吐槽：突然想起来为什么会有今日吐槽这个环节,是因为累了，我要是开开心心我就赶紧写完题溜了干好玩的事去了，","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220220","date":"2022-02-19T16:00:00.000Z","updated":"2022-02-20T14:52:44.481Z","comments":true,"path":"2022/02/20/20220220/","link":"","permalink":"http://spcablast.club/2022/02/20/20220220/","excerpt":"","text":"717. 1比特与2比特字符难度简单252 有两种特殊字符： 第一种字符可以用一个比特 0 来表示 第二种字符可以用两个比特(10 或 11)来表示、 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。 示例 1: 1234输入: bits &#x3D; [1, 0, 0]输出: true解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2: 1234输入: bits &#x3D; [1, 1, 1, 0]输出: false解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 12345678910111213141516class Solution &#123;public: bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) &#123; //只能00结尾呗 // 10 0 // 11 0 // 0 10 0x10,这个x得是0才会导致最后一位是两位 if(bits.size() &gt; 1)&#123; int n = bits.size(); for(int i = n-2; i&gt;=0; i--)&#123; if(bits[i] == 0) return (n - i - 1)%2 == 1; &#125; &#125; return bits.size() % 2 == 1; &#125;&#125;; 718. 最长重复子数组难度中等617 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例 1： 123输入：nums1 &#x3D; [1,2,3,2,1], nums2 &#x3D; [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1] 。 示例 2： 12输入：nums1 &#x3D; [0,0,0,0,0], nums2 &#x3D; [0,0,0,0,0]输出：5 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int GetMaxLen(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int start1, int start2, int len)&#123; //如果两个相等，就 int k = 0; int ret = 0; for(int i = 0; i&lt;len; i++)&#123; if(nums1[start1 + i] == nums2[start2 + i])&#123; k++; &#125; else&#123; k = 0; &#125; ret = max(ret, k); &#125; return ret; &#125; int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //啊，看起来要用滑动窗口啊 int m = nums1.size(), n = nums2.size(); int ret = 0; for(int i = 0; i &lt; m; i++)&#123; int minLen = min(m - i , n); int maxlen = GetMaxLen(nums1, nums2, i, 0, minLen); ret = max(maxlen, ret); &#125; for(int i = 0; i&lt; n; i++)&#123; int minLen = min(n - i, m ); int maxlen = GetMaxLen(nums1, nums2, 0 , i, minLen); ret = max(maxlen, ret); &#125; return ret; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"author":"YP"},{"title":"Dailycode","slug":"20220219","date":"2022-02-18T16:00:00.000Z","updated":"2022-02-19T15:05:11.705Z","comments":true,"path":"2022/02/19/20220219/","link":"","permalink":"http://spcablast.club/2022/02/19/20220219/","excerpt":"","text":"969. 煎饼排序难度中等238 给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。 一次煎饼翻转的执行过程如下： 选择一个整数 k ，1 &lt;= k &lt;= arr.length 反转子数组 arr[0...k-1]（下标从 0 开始） 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [**1**,**2**,**3**,4] 。 以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。 示例 1： 123456789输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 arr &#x3D; [3, 2, 4, 1]第一次翻转后（k &#x3D; 4）：arr &#x3D; [1, 4, 2, 3]第二次翻转后（k &#x3D; 2）：arr &#x3D; [4, 1, 2, 3]第三次翻转后（k &#x3D; 4）：arr &#x3D; [3, 2, 1, 4]第四次翻转后（k &#x3D; 3）：arr &#x3D; [1, 2, 3, 4]，此时已完成排序。 示例 2： 12345输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) &#123; //什么奇葩排序思路 //看起来像是用递归的思路， //先想办法把最大的翻转到最后面， //需要一个找最大值的方法 //还需要一个判断某一段是否有序的方法 vector&lt;int&gt; ret; for(int n = arr.size(); n&gt;1; n--)&#123; //找最大值的序号 int index = max_element(arr.begin(),arr.begin()+n) - arr.begin(); if(index == n-1) &#123; continue; &#125; //翻转序号加一这么长 reverse(arr.begin(),arr.begin() + index + 1); //翻转n的长度 reverse(arr.begin(),arr.begin() + n); //长度压入答案 ret.push_back(index + 1); //n压入答案 ret.push_back(n); &#125; return ret; &#125;&#125;; 976. 三角形的最大周长难度简单162 给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。 示例 1： 12输入：nums &#x3D; [2,1,2]输出：5 示例 2： 12输入：nums &#x3D; [1,2,1]输出：0 123456789101112131415class Solution &#123;public: int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123; //判断三个数能否组成三角形 //按顺序排列好这些数，从大到小取三个，取完判断 sort(nums.begin(), nums.end()); for (int i = (int)nums.size() - 1; i &gt;= 2; --i) &#123; //如果比他小的连续两个数加起来没他大，更小的就更不行了，所以直接后退一格 if (nums[i - 2] + nums[i - 1] &gt; nums[i]) &#123; return nums[i - 2] + nums[i - 1] + nums[i]; &#125; &#125; return 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"author":"YP"},{"title":"Dailycode","slug":"20220218","date":"2022-02-17T16:00:00.000Z","updated":"2022-02-19T14:15:18.734Z","comments":true,"path":"2022/02/18/20220218/","link":"","permalink":"http://spcablast.club/2022/02/18/20220218/","excerpt":"","text":"1791. 找出星型图的中心节点难度简单42 有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。 给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。 示例 1： 123输入：edges &#x3D; [[1,2],[2,3],[4,2]]输出：2解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。 示例 2： 12输入：edges &#x3D; [[1,2],[5,1],[1,3],[1,4]]输出：1 1234567891011121314151617class Solution &#123;public: int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; //那我只要找到一个数，他有大于1条边就是中心了 int ans = 0, n = edges.size()+1; vector&lt;int&gt; degree(n+1,0); for(auto &amp; edge : edges)&#123; degree[edge[0]]++; degree[edge[1]]++; &#125; for(int i = 1; ; i++)&#123; if(degree[i] == n-1) return i; &#125; &#125;&#125;; 1792. 最大平均通过率难度中等49 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。 给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。 请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。 示例 1： 123输入：classes &#x3D; [[1,2],[3,5],[2,2]], extraStudents &#x3D; 2输出：0.78333解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3&#x2F;4 + 3&#x2F;5 + 2&#x2F;2) &#x2F; 3 &#x3D; 0.78333 。 示例 2： 12输入：classes &#x3D; [[2,4],[3,9],[4,5],[2,10]], extraStudents &#x3D; 4输出：0.53485 提示： 1 &lt;= classes.length &lt;= 105 classes[i].length == 2 1 &lt;= passi &lt;= totali &lt;= 105 1 &lt;= extraStudents &lt;= 105 12345678910111213141516171819202122232425262728293031class Solution &#123;public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) &#123; //什么妖魔鬼怪，安排最大平均通过率，发好学生是吧 //有很多个分数，可以让分子分母各加一，目的是尽可能让分数大小增加 //找一个，让他增加是所有里面增加最大的，就加他，然后再找一次 //那么问题就变成了，找一个分数，看他分子分母加一之后增加的值是多少 //优先队列存数据 priority_queue&lt;tuple&lt;double, int,int&gt;&gt; _class; //计算分子分母加一之后和原来的差 auto diff = [](int x, int y) -&gt; double&#123; return (double)(x+1) / (y+1) - (double)x /y; &#125;; double ans = 0.0; //把每一个加一减原来的差存到优先队列里， for(const auto&amp; c:classes)&#123; int x = c[0]; int y = c[1]; ans += (double)x /y; _class.emplace(diff(x,y),x,y); &#125; for(int i = 0; i&lt;extraStudents;++i)&#123; auto [d, x, y] = _class.top(); _class.pop(); //把差加起来 ans+=d; _class.emplace(diff(x+1, y+1), x+1, y+1); &#125; return ans/classes.size(); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"author":"YP"},{"title":"Dailycode","slug":"20220217","date":"2022-02-16T16:00:00.000Z","updated":"2022-02-17T15:31:04.384Z","comments":true,"path":"2022/02/17/20220217/","link":"","permalink":"http://spcablast.club/2022/02/17/20220217/","excerpt":"","text":"骑士在棋盘上的概率在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。 象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。 骑士继续移动，直到它走了 k 步或离开了棋盘。 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。 示例 1： 输入: n = 3, k = 2, row = 0, column = 0输出: 0.0625解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。在每一个位置上，也有两种移动可以让骑士留在棋盘上。骑士留在棋盘上的总概率是0.0625。 123456789101112131415161718192021222324252627class Solution &#123;public: //移动有（1，2）（1，-2）；（2，1），（2，-1）；（-1，2）（-1，—2）；（-2，1），（-2，-2）八种 vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-2, -1&#125;, &#123;-2, 1&#125;, &#123;2, -1&#125;, &#123;2, 1&#125;, &#123;-1, -2&#125;, &#123;-1, 2&#125;, &#123;1, -2&#125;, &#123;1, 2&#125;&#125;; double knightProbability(int n, int k, int row, int column) &#123; //好家伙，dp看着不就是暴力硬解么 ，重点就在于设置dp[step][i][j],第step步，从i，j出发在棋盘的概率 vector&lt;vector&lt;vector&lt;double&gt;&gt;&gt; dp(k + 1, vector&lt;vector&lt;double&gt;&gt;(n, vector&lt;double&gt;(n))); for (int step = 0; step &lt;= k; step++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (step == 0) &#123; dp[step][i][j] = 1; &#125; else &#123; for (auto &amp; dir : dirs) &#123; int ni = i + dir[0], nj = j + dir[1]; if (ni &gt;= 0 &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; n) &#123; dp[step][i][j] += dp[step - 1][ni][nj] / 8; &#125; &#125; &#125; &#125; &#125; &#125; return dp[k][row][column]; &#125;&#125;; 交替位二进制数给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。 示例 1： 输入：n = 5输出：true解释：5 的二进制表示是：101 123456789101112class Solution &#123;public: bool hasAlternatingBits(int n) &#123; //取末位保存，右移一位，取末位比较，不同继续，相同返回false， while(n)&#123; int last = n%2; n /= 2; if(n%2 == last) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220216","date":"2022-02-15T16:00:00.000Z","updated":"2022-02-16T10:36:35.826Z","comments":true,"path":"2022/02/16/20220216/","link":"","permalink":"http://spcablast.club/2022/02/16/20220216/","excerpt":"","text":"###1721. 交换链表中的节点给你链表的头节点 head 和一个整数 k 。 交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。 示例 1： 输入：head = [1,2,3,4,5], k = 2输出：[1,4,3,2,5]示例 2： 输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5输出：[7,9,6,6,8,7,3,0,9,5] 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapNodes(ListNode* head, int k) &#123; //先判断能否调 //再用俩指针，一个指前边的，一个指后边的 ListNode* left = head; ListNode* right = head; k = k-1; while(k--)&#123; right = right-&gt;next;//right先去第k个 &#125; ListNode* temp = right; while(right-&gt;next)&#123; right = right-&gt;next; left = left-&gt;next; &#125; int tempVal = temp-&gt;val; temp-&gt;val = left-&gt;val; left-&gt;val = tempVal; return head; &#125;&#125;; 解码异或后的数组未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例 1： 输入：encoded = [1,2,3], first = 1输出：[1,0,2,1]解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]class Solution {public: vector decode(vector&amp; encoded, int first) { //把后边所有的数和第一个异或一下 int n = encoded.size() + 1; vector arr(n); arr[0] = first; for (int i = 1; i &lt; n; i++) { arr[i] = arr[i - 1] ^ encoded[i - 1]; } return arr; }};","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"快慢指针","slug":"快慢指针","permalink":"http://spcablast.club/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}],"author":"YP"},{"title":"Dailycode","slug":"20220212","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-12T16:17:32.730Z","comments":true,"path":"2022/02/12/20220212/","link":"","permalink":"http://spcablast.club/2022/02/12/20220212/","excerpt":"","text":"###108 将有序数组转换为二叉搜索树给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 1： 输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: // TreeNode* dfs(vector&lt;int&gt;&amp; nums)&#123; // if(nums.size() == 1)&#123; // TreeNode * root = new TreeNode(nums[0]); // return root; // &#125; // int mid = nums.size()/2; // TreeNode* root = new TreeNode(nums[mid]); // root-&gt;left = dfs(nums(0,mid-1)); // root-&gt;right = dfs(nums(mid+1, nums.size())); // return root; // &#125; TreeNode* dfs(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt; right) &#123; return nullptr; &#125; // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = dfs(nums, left, mid - 1); root-&gt;right = dfs(nums, mid + 1, right); return root; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; //直接取中间的值作为根节点，左边的中间做左子树，右边的做右子树，重复1操作 return dfs(nums, 0, nums.size()-1); &#125;&#125;; ###109. 有序链表转换二叉搜索树给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 ** 9 / **** / -10 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: //复用上一题的结果 TreeNode* dfs(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt; right) &#123; return nullptr; &#125; // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = dfs(nums, left, mid - 1); root-&gt;right = dfs(nums, mid + 1, right); return root; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; vector&lt;int&gt; nums; while(head)&#123; nums.push_back(head-&gt;val); head = head-&gt;next; &#125; return dfs(nums, 0, nums.size() - 1); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20220209","date":"2022-02-08T16:00:00.000Z","updated":"2022-02-09T06:50:40.714Z","comments":true,"path":"2022/02/09/20220209/","link":"","permalink":"http://spcablast.club/2022/02/09/20220209/","excerpt":"","text":"从中序与后序遍历序列构造二叉树给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int rootNum; unordered_map&lt;int, int&gt; postIndex; //取后序遍历的最后一个数，在中序里边找到，还得把后序的也分一下,把位置左右继续dfs TreeNode* dfs(int leftPos,int rightPos, vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder)&#123; if(leftPos &gt; rightPos)&#123; return nullptr; &#125; //获取根的值 int rootval = postorder[rootNum]; TreeNode* root = new TreeNode(rootval); //在inorder里面找根的位置，然后把他分两半 int index = postIndex[rootval]; //递归 rootNum--; root-&gt;right = dfs(index + 1, rightPos, inorder, postorder); root-&gt;left = dfs(leftPos , index - 1, inorder , postorder); return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; //我觉得能有好办法，简单快捷那种，找找规律，中序是左、中、右；后序是左、右、中 //那肯定是dfs，在后序里找根，在中序里找到根，分成两份，重复 //好了 rootNum = postorder.size() - 1; int tempIndex = 0; for(int val:inorder)&#123; postIndex[val] = tempIndex++; &#125; return dfs(0, postorder.size() - 1, inorder, postorder); &#125;&#125;; 二叉树的层序遍历 II给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]示例 2： 输入：root = [1]输出：[[1]]示例 3： 输入：root = []输出：[] 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; //我觉得队列就很合适 //直接来一个二维数组存结果 auto levelOrder = vector&lt;vector&lt;int&gt;&gt;(); if (!root) &#123; return levelOrder; &#125; //再来一个队列存根节点 queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; auto level = vector&lt;int&gt;(); int size = q.size(); for (int i = 0; i &lt; size; ++i) &#123; auto node = q.front(); q.pop(); level.push_back(node-&gt;val); if (node-&gt;left) &#123; q.push(node-&gt;left); &#125; if (node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; levelOrder.push_back(level); &#125; reverse(levelOrder.begin(), levelOrder.end()); return levelOrder; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220201","date":"2022-01-31T16:00:00.000Z","updated":"2022-02-01T13:24:46.882Z","comments":true,"path":"2022/02/01/20220201/","link":"","permalink":"http://spcablast.club/2022/02/01/20220201/","excerpt":"","text":"最长的美好子字符串当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，”abABB” 是美好字符串，因为 ‘A’ 和 ‘a’ 同时出现了，且 ‘B’ 和 ‘b’ 也同时出现了。然而，”abA” 不是美好字符串因为 ‘b’ 出现了，而 ‘B’ 没有出现。 给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。 示例 1： 输入：s = “YazaAay”输出：”aAa”解释：”aAa” 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 ‘a’ 和大写形式 ‘A’ 也同时出现了。“aAa” 是最长的美好子字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void dfs(const string &amp; s, int start, int end, int &amp; maxPos, int &amp; maxLen) &#123; //返回条件，长度为0 if (start &gt;= end) &#123; return; &#125; int lower = 0, upper = 0; //把出现的小写大写字母记录在一个整数里 for (int i = start; i &lt;= end; ++i) &#123; if (islower(s[i])) &#123; lower |= 1 &lt;&lt; (s[i] - 'a'); &#125; else &#123; upper |= 1 &lt;&lt; (s[i] - 'A'); &#125; &#125; //返回条件，这个字符串是题目要求的字符串 if (lower == upper) &#123; if (end - start + 1 &gt; maxLen) &#123; maxPos = start; maxLen = end - start + 1; &#125; return; &#125; //valid存有大写和有小写的位置 int valid = lower &amp; upper; int pos = start; while (pos &lt;= end) &#123; start = pos; //将字符根据只出现一次的字母的位置分割开来，然后去dfs while (pos &lt;= end &amp;&amp; valid &amp; (1 &lt;&lt; (tolower(s[pos]) - 'a'))) &#123; ++pos; &#125; dfs(s, start, pos - 1, maxPos, maxLen); ++pos; &#125; &#125; string longestNiceSubstring(string s) &#123; int maxPos = 0, maxLen = 0; dfs(s, 0, s.size() - 1, maxPos, maxLen); return s.substr(maxPos, maxLen); &#125;&#125;; 通过连接另一个数组的子数组得到一个数组给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。 你是否可以从 nums 中选出 n 个 不相交 的子数组，使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同，且如果 i &gt; 0 ，那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同） 如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。 如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是原数组中连续元素组成的一个序列。 示例 1： 输入：groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]输出：true解释：你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,3,-2,0] 。这两个子数组是不相交的，因为它们没有任何共同的元素。示例 2： 输入：groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]输出：false解释：选择子数组 [1,2,3,4,10,-2] 和 [1,2,3,4,10,-2] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。[10,-2] 必须出现在 [1,2,3,4] 之前。 1234567891011121314151617181920212223242526class Solution &#123;public: bool canChoose(vector&lt;vector&lt;int&gt;&gt;&amp; groups, vector&lt;int&gt;&amp; nums) &#123; //搁这阅读理解呢，题目让从数组nums里按顺序能不能依次找到二维数组里的每一行 int n = nums.size(); int i = 0; for (auto &amp; v: groups) &#123; bool find = false; while (i + v.size() &lt;= n) &#123; if (v == vector&lt;int&gt;(nums.begin()+i, nums.begin()+i+v.size())) &#123; i += v.size(); find = true; break; &#125; else i += 1; &#125; if (find == false) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220128","date":"2022-01-27T16:00:00.000Z","updated":"2022-01-27T21:13:16.102Z","comments":true,"path":"2022/01/28/20220128/","link":"","permalink":"http://spcablast.club/2022/01/28/20220128/","excerpt":"","text":"游戏中弱角色的数量你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj &gt; attacki 且 defensej &gt; defensei 。 返回 弱角色 的数量。 示例 1： 输入：properties = [[5,5],[6,3],[3,6]]输出：0解释：不存在攻击和防御都严格高于其他角色的角色。示例 2： 输入：properties = [[2,2],[3,3]]输出：1解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。示例 3： 输入：properties = [[1,5],[10,4],[4,3]]输出：1解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 12345678910111213141516171819class Solution &#123;public: int numberOfWeakCharacters(vector&lt;vector&lt;int&gt;&gt;&amp; properties) &#123; //哈，数组，先根据attack把两个数作为一个组合排序，然后遍历一次就有了 sort(properties.begin(), properties.end(), [](const vector&lt;int&gt; &amp; a, const vector&lt;int&gt; &amp; b) &#123; return a[0] == b[0] ? (a[1] &lt; b[1]) : (a[0] &gt; b[0]); &#125;); int maxDef = 0, ans = 0; for(vector&lt;int&gt; &amp; index : properties)&#123; if(index[1] &lt; maxDef)&#123; ans++; &#125; else&#123; maxDef = index[1]; &#125; &#125; return ans; &#125;&#125;; 反转单词前缀给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。 例如，如果 word = “abcdefd” 且 ch = “d” ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “dcbaefd” 。返回 结果字符串 。 示例 1： 输入：word = “abcdefd”, ch = “d”输出：”dcbaefd”解释：”d” 第一次出现在下标 3 。反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 “dcbaefd” 。 123456789101112131415161718192021class Solution &#123;public: string reversePrefix(string word, char ch) &#123; int flag = 0,find = 0; for(char c : word)&#123; if(c == ch)&#123; find = 1; flag++; break; &#125; else flag++; &#125; if(!find) return word; else &#123; reverse(word.begin(), word.begin() + flag); return word; &#125; //reverse(word.begin(), word.begin() + word.find(ch) + 1); //return word; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"vector排序","slug":"vector排序","permalink":"http://spcablast.club/tags/vector%E6%8E%92%E5%BA%8F/"}],"author":"YP"},{"title":"Dailycode","slug":"20220127","date":"2022-01-26T16:00:00.000Z","updated":"2022-01-27T20:40:13.478Z","comments":true,"path":"2022/01/27/20220127/","link":"","permalink":"http://spcablast.club/2022/01/27/20220127/","excerpt":"","text":"最后 K 个数的乘积请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法： add(int num) 将数字 num 添加到当前数字列表的最后面。2. getProduct(int k) 返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终 至少 包含 k 个数字。题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。 示例： 输入：[“ProductOfNumbers”,”add”,”add”,”add”,”add”,”add”,”getProduct”,”getProduct”,”getProduct”,”add”,”getProduct”][[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]] 输出：[null,null,null,null,null,null,20,40,0,null,32] 解释：ProductOfNumbers productOfNumbers = new ProductOfNumbers();productOfNumbers.add(3); // [3]productOfNumbers.add(0); // [3,0]productOfNumbers.add(2); // [3,0,2]productOfNumbers.add(5); // [3,0,2,5]productOfNumbers.add(4); // [3,0,2,5,4]productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40productOfNumbers.getProduct(4); // 返回 0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0productOfNumbers.add(8); // [3,0,2,5,4,8]productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 123456789101112131415161718192021222324class ProductOfNumbers &#123;public: vector&lt;int&gt; v; //这不用队列，就维持k的长度 ProductOfNumbers() &#123; v = vector(1,1); &#125; void add(int num) &#123; if(num == 0) v = vector(1,1);//这波是初始化 else v.push_back(num * v.back()); &#125; int getProduct(int k) &#123; return k &gt;= v.size() ? 0 : v.back() / v[v.size() - k -1] ; &#125;&#125;;/** * Your ProductOfNumbers object will be instantiated and called as such: * ProductOfNumbers* obj = new ProductOfNumbers(); * obj-&gt;add(num); * int param_2 = obj-&gt;getProduct(k); */ 根据数字二进制下 1 的数目排序给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例 1： 输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: //怎么知道一个数里1的个数？ int get2(int num)&#123; int res = 0; while(num)&#123; if(num%2 == 1)&#123; res++; &#125; num /= 2; &#125; return res; &#125; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; bit(10001, 0); for(int x : arr)&#123; bit[x] = get2(x); &#125; //这个排序好啊 sort(arr.begin(), arr.end(), [&amp;](int x, int y)&#123; if(bit[x] &lt; bit[y])&#123; return true; &#125; if(bit[x] &gt; bit[y])&#123; return false; &#125; return x &lt; y; &#125;); return arr; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"vector排序","slug":"vector排序","permalink":"http://spcablast.club/tags/vector%E6%8E%92%E5%BA%8F/"}],"author":"YP"},{"title":"前言","slug":"当然是前言啦","date":"2022-01-26T16:00:00.000Z","updated":"2022-02-16T11:03:36.829Z","comments":true,"path":"2022/01/27/当然是前言啦/","link":"","permalink":"http://spcablast.club/2022/01/27/%E5%BD%93%E7%84%B6%E6%98%AF%E5%89%8D%E8%A8%80%E5%95%A6/","excerpt":"","text":"前言 是大家都喜欢的前言部分，正所谓万事开头难，然后中间难，当然，可能就没有结尾了，因为太难啦~~~ 为什么这么说呢，因为有人做事前喜欢设想一切可能的困难，想出克服困难的办法，大部分时候我只能做到前半句。 本栏目的：理解这个世界，理解“人”，理解自己，是为了什么呢，为什么呢，目前可能是想知道“让人成为人”这句话什么意思吧 方式/途径：这件事必然是前人所做过的，同时今人也正在做的，所以康康前人留下的经验，康康今人的研究成果，去生活里感受、体会，大概就能有自己的答案了。 那么看第一步，阅读书籍或者观看影像资料，了解前人总结的经验。首先是资料的选取，我总看别人的东西，就感觉文章里是作者的结论，欸，还是不写推导过程的那种，就，丢人，看不懂；就看作者是写给同行看的，还是写给菜鸟看的，还是有新发现想和大家分享的。 看了，第二步，如果从逻辑上理解了一个观点/概念，只是逻辑上，还有下一步，在生活中体会，这个东西并不是我想出来的，不是我总结经验得到或根据整理的资料推导出来的，而是我跟着前人的推理过程复现出来的，缺少了一个关键步骤。 那么之后，由于人的局限性：一个人的时间是有限的，导致其能够学习的内容是有限的，从而对世界的认识也是有限的、带有偏见的。 世上所存在的一切，都有其形成的过程。习惯，忘却，冷漠，都是可怕的力量 阅读： 什么是哲学：（这是一个跳转） 什么是科学：（这是一个跳转） 心理学： （当然是下次一定啦","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[],"author":"YP"},{"title":"Dailycode","slug":"20220123","date":"2022-01-22T16:00:00.000Z","updated":"2022-01-23T13:58:16.206Z","comments":true,"path":"2022/01/23/20220123/","link":"","permalink":"http://spcablast.club/2022/01/23/20220123/","excerpt":"","text":"推文计数请你实现一个能够支持以下两种方法的推文计数类 TweetCounts： recordTweet(string tweetName, int time) 记录推文发布情况：用户 tweetName 在 time（以 秒 为单位）时刻发布了一条推文。2. getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) 返回从开始时间 startTime（以 秒 为单位）到结束时间 endTime（以 秒 为单位）内，每 分 minute，时 hour 或者 日 day （取决于 freq）内指定用户 tweetName 发布的推文总数。freq 的值始终为 分 minute，时 hour 或者 日 day 之一，表示获取指定用户 tweetName 发布推文次数的时间间隔。第一个时间间隔始终从 startTime 开始，因此时间间隔为 [startTime, startTime + delta1&gt;, [startTime + delta1, startTime + delta2&gt;, [startTime + delta2, startTime + delta3&gt;, … , [startTime + delta*i, min(startTime + delta(i+1), endTime + 1)&gt;，其中 i 和 delta（取决于 freq）都是非负整数。 示例： 输入：[“TweetCounts”,”recordTweet”,”recordTweet”,”recordTweet”,”getTweetCountsPerFrequency”,”getTweetCountsPerFrequency”,”recordTweet”,”getTweetCountsPerFrequency”][[],[“tweet3”,0],[“tweet3”,60],[“tweet3”,10],[“minute”,”tweet3”,0,59],[“minute”,”tweet3”,0,60],[“tweet3”,120],[“hour”,”tweet3”,0,210]] 输出：[null,null,null,null,[2],[2,1],null,[4]] 解释：TweetCounts tweetCounts = new TweetCounts();tweetCounts.recordTweet(“tweet3”, 0);tweetCounts.recordTweet(“tweet3”, 60);tweetCounts.recordTweet(“tweet3”, 10); // “tweet3” 发布推文的时间分别是 0, 10 和 60 。tweetCounts.getTweetCountsPerFrequency(“minute”, “tweet3”, 0, 59); // 返回 [2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60&gt; - &gt; 2 条推文。tweetCounts.getTweetCountsPerFrequency(“minute”, “tweet3”, 0, 60); // 返回 [2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔 1) [0,60&gt; - &gt; 2 条推文，和 2) [60,61&gt; - &gt; 1 条推文。tweetCounts.recordTweet(“tweet3”, 120); // “tweet3” 发布推文的时间分别是 0, 10, 60 和 120 。tweetCounts.getTweetCountsPerFrequency(“hour”, “tweet3”, 0, 210); // 返回 [4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211&gt; - &gt; 4 条推文。 123456789101112131415161718192021222324252627282930313233343536class TweetCounts &#123;public: unordered_map&lt;string, set&lt;int&gt;&gt; list; TweetCounts() &#123; &#125; void recordTweet(string tweetName, int time) &#123; list[tweetName].insert(time); &#125; vector&lt;int&gt; getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) &#123; //以 int length = 0; if(freq == \"minute\")&#123; length = 60; &#125; else if(freq == \"hour\")&#123; length = 60*60; &#125; else&#123; length = 60 * 60 * 24; &#125; vector&lt;int&gt; ans((endTime - startTime)/length +1); auto begin = list[tweetName].lower_bound(startTime);//查询上下界，时间为log(n)l auto end = list[tweetName].upper_bound(endTime); for(;begin != end; begin++)&#123; ++ans[(*begin - startTime)/length]; &#125; return ans; &#125;&#125;;/** * Your TweetCounts object will be instantiated and called as such: * TweetCounts* obj = new TweetCounts(); * obj-&gt;recordTweet(tweetName,time); * vector&lt;int&gt; param_2 = obj-&gt;getTweetCountsPerFrequency(freq,tweetName,startTime,endTime); */ 统计有序矩阵中的负数给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。 示例 1： 输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]输出：8解释：矩阵中共有 8 个负数。示例 2： 输入：grid = [[3,2],[1,0]]输出：0 123456789101112131415161718192021222324252627class Solution &#123;public: int findZero(vector&lt;int&gt; &amp; col)&#123; int left = 0, right = col.size() - 1, mid, pos = -1; while(left &lt;= right)&#123; mid = (left + right)/2; if(col[mid] &lt; 0)&#123; right = mid - 1; pos = mid; &#125; else&#123; left = mid + 1; &#125; &#125; if(pos != -1) return col.size() - pos; else return 0; &#125; int countNegatives(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //那这不如每个都二分，快的 //那这不如 int ans = 0; for(vector&lt;int&gt; col: grid)&#123; ans += findZero(col); &#125; return ans; &#125;&#125;; 今日吐槽：写个二分写了半天，血压，biu","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"二分","slug":"二分","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%88%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20220121","date":"2022-01-20T16:00:00.000Z","updated":"2022-01-21T12:33:08.401Z","comments":true,"path":"2022/01/21/20220121/","link":"","permalink":"http://spcablast.club/2022/01/21/20220121/","excerpt":"","text":"检查整数及其两倍数是否存在给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j0 &lt;= i, j &lt; arr.lengtharr[i] == 2 * arr[j] 示例 1： 输入：arr = [10,2,5,3]输出：true解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。 123456789101112131415161718class Solution &#123;public: bool checkIfExist(vector&lt;int&gt;&amp; arr) &#123; //2000个数，4000个存 int hash_set[4001] = &#123;0&#125;; int * point = hash_set + 2000; for(int num : arr)&#123; point[num]++; &#125; for(int num : arr)&#123; if(num != 0 &amp;&amp; point[2 * num] &gt;= 1) return true; if(num == 0 &amp;&amp; point[2 * num] &gt;= 2) return true; &#125; return false; &#125;&#125;; 制造字母异位词的最小步骤数给你两个长度相等的字符串 s 和 t。每一个步骤中，你可以选择将 t 中的 任一字符 替换为 另一个字符。 返回使 t 成为 s 的字母异位词的最小步骤数。 字母异位词 指字母相同，但排列不同（也可能相同）的字符串。 示例 1： 输出：s = “bab”, t = “aba”输出：1提示：用 ‘b’ 替换 t 中的第一个 ‘a’，t = “bba” 是 s 的一个字母异位词。示例 2： 输出：s = “leetcode”, t = “practice”输出：5提示：用合适的字符替换 t 中的 ‘p’, ‘r’, ‘a’, ‘i’ 和 ‘c’，使 t 变成 s 的字母异位词。 1234567891011121314151617class Solution &#123;public: int minSteps(string s, string t) &#123; //这阅读理解就是把一个单词里换掉几个字母能和另一个单词字母数量和字母一样？ int s_cnt[26] = &#123;0&#125;; int t_cnt[26] = &#123;0&#125;; for (char c : s) ++s_cnt[c - 'a']; for (char c : t) ++t_cnt[c - 'a']; int ans = 0; for (int i = 0; i != 26; ++i) if (s_cnt[i] &lt; t_cnt[i]) ans += t_cnt[i] - s_cnt[i]; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"数组计数","slug":"数组计数","permalink":"http://spcablast.club/tags/%E6%95%B0%E7%BB%84%E8%AE%A1%E6%95%B0/"}],"author":"YP"},{"title":"Dailycode","slug":"20220120","date":"2022-01-19T16:00:00.000Z","updated":"2022-01-20T11:36:44.483Z","comments":true,"path":"2022/01/20/20220120/","link":"","permalink":"http://spcablast.club/2022/01/20/20220120/","excerpt":"","text":"至少在两个数组中出现的值给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 与这三个数组都不同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。 示例 1： 输入：nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]输出：[3,2]解释：至少在两个数组中出现的所有值为： 3 ，在全部三个数组中都出现过。 2 ，在数组 nums1 和 nums2 中出现过。12345678910class Solution(object): def twoOutOfThree(self, nums1, nums2, nums3): \"\"\" :type nums1: List[int] :type nums2: List[int] :type nums3: List[int] :rtype: List[int] \"\"\" #简单的方式就是两个数组求交集，两两求交集吧，在结果里挑一个 return list((set(nums1) &amp; set(nums2)) | set(nums1) &amp; set(nums3) | set(nums2) &amp; set(nums3)) 石子游戏 IXAlice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。 Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。 示例 1： 输入：stones = [2,1]输出：true解释：游戏进行如下： 回合 1：Alice 可以移除任意一个石子。 回合 2：Bob 移除剩下的石子。已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。12345678910111213141516171819202122232425262728class Solution(object): def stoneGameIX(self, stones): \"\"\" :type stones: List[int] :rtype: bool \"\"\" #两个条件， #一是谁拿走一个，剩下的总和是2的倍数，这个人输 #二是最后如果一个不剩结束游戏，bob赢 #那么每次拿就得考虑自己不能使总和是3的倍数， #怎么做呢，先算个总和然后一个一个遍历吗，那就n方了 #如果开始总和是3的倍数，必须拿走一个不是3的倍数的数字，另一个人也是 #如果开始总和不是3的倍数，那就得拿走7，-2，-3， -5，只能拿总和%3，自己%3不同的数 #所以有三个数组，%3 == 0，%3 == 1， %3 == 2 #不对，只要两个数组，%3 = 总和%3，和%3 ！= 总和%3 cnt0 = cnt1 = cnt2 = 0 for val in stones: typ = val % 3 if typ == 0: cnt0 += 1 elif typ == 1: cnt1 += 1 else: cnt2 += 1 if cnt0 % 2 == 0: return cnt1 &gt;= 1 and cnt2 &gt;= 1 return cnt1 - cnt2 &gt; 2 or cnt2 - cnt1 &gt; 2 #对不起，打扰了，我只能说，甘拜下风","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"python","slug":"python","permalink":"http://spcablast.club/tags/python/"}],"author":"YP"},{"title":"Dailycode","slug":"20220119","date":"2022-01-18T16:00:00.000Z","updated":"2022-01-19T14:48:31.616Z","comments":true,"path":"2022/01/19/20220119/","link":"","permalink":"http://spcablast.club/2022/01/19/20220119/","excerpt":"","text":"存在重复元素 II给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,1], k = 3输出：true 1234567891011121314class Solution(object): def containsNearbyDuplicate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" #用一个map，左边是数组里的数，右边是他们的index，只需要看右边是不是大于2就能得出有没有重复的，然后在右边找差值的最小就行了 pos = &#123;&#125; for i, num in enumerate(nums):#enumrate(nums),返回[(1,1),(2,2),(3,3),(4,1)] if num in pos and i - pos[num] &lt;= k: return True pos[num] = i#两级反转，把序号和里边的值倒过来了 return False 存在重复元素 III给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。 如果存在则返回 true，不存在返回 false。 示例 1： 输入：nums = [1,2,3,1], k = 3, t = 0输出：true示例 2： 输入：nums = [1,0,1,1], k = 1, t = 2输出：true 12345678910111213141516171819202122from sortedcontainers import SortedListclass Solution(object): def containsNearbyAlmostDuplicate(self, nums, k, t): \"\"\" :type nums: List[int] :type k: int :type t: int :rtype: bool \"\"\" #不如先排序，排完序就好算了，不行，排完序就丢了序号，那可以连序号一起，存到map里排序，c++可以有，python肯定也有 #使用一个滑动窗口，窗口大小为k，在窗口中使用红黑树保证有序且插入排序耗时短 window = SortedList() for i in range(len(nums)): if i &gt; k: window.remove(nums[i - 1 - k]) window.add(nums[i]) idx = bisect.bisect_left(window, nums[i]) if idx &gt; 0 and abs(window[idx] - window[idx-1]) &lt;= t: return True if idx &lt; len(window) - 1 and abs(window[idx+1] - window[idx]) &lt;= t: return True return False 今日吐槽：我的脑子能开高性能模式，但是开一会儿就头疼了，好疼啊","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"python","slug":"python","permalink":"http://spcablast.club/tags/python/"}],"author":"YP"},{"title":"Dailycode","slug":"20220118","date":"2022-01-17T16:00:00.000Z","updated":"2022-01-18T10:49:44.361Z","comments":true,"path":"2022/01/18/20220118/","link":"","permalink":"http://spcablast.club/2022/01/18/20220118/","excerpt":"","text":"最小时间差给定一个 24 小时制（小时:分钟 “HH:MM”）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。 示例 1： 输入：timePoints = [“23:59”,”00:00”]输出：1示例 2： 输入：timePoints = [“00:00”,”23:59”,”00:00”]输出：0 12345678910111213141516171819202122232425class Solution &#123;public: int getMinite(string&amp; s)&#123; return (((s[0] - '0')*10 + s[1] - '0') * 60 + (s[3] - '0')*10 + s[4] - '0'); &#125; int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123; //就是两个一列整数，找其中差最小的两个整数 //这不遍历？直接n方， //原来可以排序后遍历一遍就有了呀 //这个用pthon写方便一点 if(timePoints.size() &gt;= 1440)&#123; return 0; &#125; sort(timePoints.begin(), timePoints.end()); int ans = INT_MAX; int curTime = getMinite(timePoints[0]); int preTime = curTime; for(int i = 1;i &lt; timePoints.size(); ++i)&#123; int temp = getMinite(timePoints[i]); ans = min(ans, temp - preTime); preTime = temp; &#125; return min(ans, curTime + 1440 - preTime);//最小的时间加24小时减最大的时间 &#125;&#125;; 反转字符串 II给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 输入：s = “abcdefg”, k = 2输出：”bacdfeg” 12345678910111213class Solution(object): def reverseStr(self, s, k): \"\"\" :type s: str :type k: int :rtype: str \"\"\" #是不是直接俄用俩指针就行了，完了python没有指针 #整个啥 t = list(s) for i in range(0, len(t), 2*k): t[i:i + k] = reversed(t[i: i+k]) return \"\".join(t)","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"python","slug":"python","permalink":"http://spcablast.club/tags/python/"}],"author":"YP"},{"title":"Dailycode","slug":"20220117","date":"2022-01-16T16:00:00.000Z","updated":"2022-01-18T10:40:01.601Z","comments":true,"path":"2022/01/17/20220117/","link":"","permalink":"http://spcablast.club/2022/01/17/20220117/","excerpt":"","text":"统计元音字母序列的数目给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： 字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）每个元音 ‘a’ 后面都只能跟着 ‘e’每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’每个元音 ‘u’ 后面只能跟着 ‘a’由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 1输出：5解释：所有可能的字符串分别是：”a”, “e”, “i” , “o” 和 “u”。示例 2： 输入：n = 2输出：10解释：所有可能的字符串分别是：”ae”, “ea”, “ei”, “ia”, “ie”, “io”, “iu”, “oi”, “ou” 和 “ua”。示例 3： 输入：n = 5输出：68 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: //状态有五种，以a e i o u结尾 vector&lt;long long&gt; state; // a e i o u // 0 1 2 3 4 // 01 10 12 20 21 23 24 32 34 40 long long mod = 1e9 + 7;public: vector&lt;long long&gt; run(vector&lt;long long&gt;&amp; s) &#123;//run一次，长度加一，最初长度是1，是a e i o u //a可以由e, i, u后边接一个， //e可以由a, i后边接一个， //i可以由e, o后边接一个， //o可以由i后边接一个， //u可以由i，o后边接一个 vector&lt;long long&gt; s_(5); s_[0] = (s[1] + s[2] + s[4]) % mod; s_[1] = (s[0] + s[2]) % mod; s_[2] = (s[1] + s[3]) % mod; s_[3] = s[2] % mod; s_[4] = (s[2] + s[3]) % mod; return s_; &#125; int countVowelPermutation(int n) &#123; state = vector&lt;long long&gt;(5, 1); for (int i = 1; i &lt; n; i++) &#123;//n为1，state各为1 state = run(state); &#125; long long sum = 0; for (int i = 0; i &lt; 5; i++) &#123;//把五种结尾加起来就是结果 sum += state[i]; sum %= mod; &#125; return sum; &#125; //作者：wfnuser //链接：https://leetcode-cn.com/problems/count-vowels-permutation/solution/wei-rao-li-lun-zi-dong-ji-zhuang-tai-ji-9vf5d/&#125;; 分割平衡字符串在一个 平衡字符串 中，’L’ 和 ‘R’ 字符的数量是相同的。 给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 注意：分割得到的每个字符串都必须是平衡字符串，且分割得到的平衡字符串是原平衡字符串的连续子串。 返回可以通过分割得到的平衡字符串的 最大数量 。 示例 1： 输入：s = “RLRRLLRLRL”输出：4解释：s 可以分割为 “RL”、”RRLL”、”RL”、”RL” ，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。示例 2： 输入：s = “RLLLLRRRLR”输出：3解释：s 可以分割为 “RL”、”LLLRRR”、”LR” ，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。 12345678910111213141516171819202122class Solution &#123;public: int balancedStringSplit(string s) &#123; //为什么我看起来挺难的 //如果用一个计数，计算目前r的数量，l的数量，一旦相同且大于0就切割是不是就行了 //那就是双指针？好像不需要 int num_R = 0, num_L = 0; int ans = 0; for(char c : s)&#123; if(c == 'R')&#123; num_R++; &#125; else num_L++; if(num_R == num_L &amp;&amp; num_R != 0)&#123; ans++; num_R = 0; num_L = 0; &#125; &#125; return ans; &#125;&#125;; 今日吐槽：终于有力气和心情吐槽了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"自动机","slug":"自动机","permalink":"http://spcablast.club/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"author":"YP"},{"title":"Dailycode","slug":"20220116","date":"2022-01-15T16:00:00.000Z","updated":"2022-01-16T07:29:55.833Z","comments":true,"path":"2022/01/16/20220116/","link":"","permalink":"http://spcablast.club/2022/01/16/20220116/","excerpt":"","text":"链表随机节点给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例： 输入[“Solution”, “getRandom”, “getRandom”, “getRandom”, “getRandom”, “getRandom”][[[1, 2, 3]], [], [], [], [], []]输出[null, 1, 3, 2, 2, 3] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; arr; Solution(ListNode* head) &#123; //初始化 while(head)&#123; arr.push_back(head-&gt;val); head = head-&gt;next; &#125; &#125; int getRandom() &#123; return arr[rand() % arr.size()]; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */ 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 输入：ransomNote = “a”, magazine = “b”输出：false 12345678910111213141516class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; //经典判断一个字符串是不是另一个的子串， if(ransomNote.size() &gt; magazine.size()) return false; unordered_map&lt;char , int&gt; ans; for(char c : magazine)&#123; ans[c]++; &#125; for(char c : ransomNote)&#123; if(ans[c] &lt;= 0) return false; ans[c]--; &#125; return true; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"随机","slug":"随机","permalink":"http://spcablast.club/tags/%E9%9A%8F%E6%9C%BA/"}],"author":"YP"},{"title":"Dailycode","slug":"20220115","date":"2022-01-14T16:00:00.000Z","updated":"2022-01-15T09:56:56.965Z","comments":true,"path":"2022/01/15/20220115/","link":"","permalink":"http://spcablast.club/2022/01/15/20220115/","excerpt":"","text":"查找和最小的 K 对数字给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。 请找到和最小的 k 个数对 (u1,v1), (u2,v2) … (uk,vk) 。 示例 1: 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3输出: [1,2],[1,4],[1,6]解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool flag = true; vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; //啊，我看着意思就是先看两边谁更小，取出来，加另一边的，再看取出的那一列加另一边的下一个大还是现在这个加下一个大，重复 vector&lt;vector&lt;int&gt;&gt; ans; int n = nums1.size(), m = nums2.size(); if(m &lt; n)&#123; swap(nums1, nums2); swap(m, n); flag = false; &#125; //定义比较规则,返回是a序列的和是否大于b序列的和 auto cmp = [&amp;](const auto&amp; a, const auto&amp; b)&#123; return nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;; priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(cmp)&gt; q(cmp); for(int i = 0; i &lt; min(n,k); ++i)&#123; q.push(&#123;i,0&#125;); &#125; while(ans.size() &lt; k &amp;&amp; q.size())&#123; auto [a,b] = q.top(); q.pop(); flag ? ans.push_back(&#123;nums1[a], nums2[b]&#125;) : ans.push_back(&#123;nums2[b], nums1[a]&#125;); if(b + 1 &lt; m)&#123; q.push(&#123;a,b+1&#125;); &#125; &#125; return ans; &#125;&#125;; 希望我下次看到这道题还能会374. 猜数字大小猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num1：我选出的数字比你猜的数字大 pick &gt; num0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num返回我选出的数字。 示例 1： 输入：n = 10, pick = 6输出：6 123456789101112131415161718192021222324252627/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */class Solution &#123;public: int guessNumber(int n) &#123; int ans; int left = 0, right = n-1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2;//防溢出专用方法 if(guess(mid) == -1)&#123; right = mid -1; &#125; else if(guess(mid) == 1)&#123; left = mid +1; &#125; else return mid; &#125; return left; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"归并排序","slug":"归并排序","permalink":"http://spcablast.club/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"author":"YP"},{"title":"Dailycode","slug":"20220113","date":"2022-01-12T16:00:00.000Z","updated":"2022-01-13T12:03:53.997Z","comments":true,"path":"2022/01/13/20220113/","link":"","permalink":"http://spcablast.club/2022/01/13/20220113/","excerpt":"","text":"Fizz Buzz给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == “FizzBuzz” 如果 i 同时是 3 和 5 的倍数。answer[i] == “Fizz” 如果 i 是 3 的倍数。answer[i] == “Buzz” 如果 i 是 5 的倍数。answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 输入：n = 3输出：[“1”,”2”,”Fizz”] 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; ans; for(int i = 1; i &lt;= n; ++i)&#123; string temp; if (i % 3 == 0) &#123; temp+= \"Fizz\"; &#125; if (i % 5 == 0) &#123; temp += \"Buzz\"; &#125; if (temp.size() == 0) &#123; temp += to_string(i); &#125; ans.emplace_back(temp); &#125; return ans; &#125;&#125;; 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。示例 2： 输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; //看起来好难啊，这咋做 //正整数集合，分成两个和相等的子集，那么这个和肯定是1/2个整个集合， //找一个数组里面是否有一些数加起来会等于一个值 //该怎么找呢？暴力？先一个，再两个，必超时 //我看懂了，并大受震撼，居然是用动态规划做，先排除一些不可能的情况，比如总和为奇数，只有一个数，其中最大的数大于一半， int n = nums.size(); if (n &lt; 2) &#123; return false; &#125; int sum = accumulate(nums.begin(), nums.end(), 0); int maxNum = *max_element(nums.begin(), nums.end()); if (sum &amp; 1) &#123; return false; &#125; int target = sum / 2; if (maxNum &gt; target) &#123; return false; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(target + 1, 0));//n行，一半和的大小列，添加一个数，列减去这个数，列为零说明刚好能加到 for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = true; &#125; dp[0][nums[0]] = true; for (int i = 1; i &lt; n; i++) &#123; int num = nums[i]; for (int j = 1; j &lt;= target; j++) &#123; if (j &gt;= num) &#123; dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]; &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n - 1][target]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220111","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-13T11:47:46.369Z","comments":true,"path":"2022/01/11/20220111/","link":"","permalink":"http://spcablast.club/2022/01/11/20220111/","excerpt":"","text":"有效的回旋镖回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例 1： 输入：[[1,1],[2,3],[3,2]]输出：true 1234567class Solution &#123;public: //x1-x2/y1-y2 = x1-x3/y1-y3 bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; return (points[0][0]-points[1][0])*(points[2][1]-points[1][1]) != (points[2][0]-points[1][0])*(points[0][1]-points[1][1]); &#125;&#125;; 把二叉搜索树转换为累加树给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。注意：该题目与 538: https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ 相同 示例 1： 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]示例 2： 输入：root = [0,null,1]输出：[1,null,1] 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int sum = 0; TreeNode* bstToGst(TreeNode* root) &#123; //这意思就是要在每个节点所有的右子树里边找比节点大的数都加起来呗 if (root != nullptr) &#123; bstToGst(root-&gt;right); sum += root-&gt;val; root-&gt;val = sum; bstToGst(root-&gt;left); &#125; return root; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20220110","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-10T12:46:43.764Z","comments":true,"path":"2022/01/10/20220110/","link":"","permalink":"http://spcablast.club/2022/01/10/20220110/","excerpt":"","text":"最小高度树树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。 示例 1： 输入：n = 4, edges = [[1,0],[1,2],[1,3]]输出：[1]解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; //这岂不是列出来每个节点的邻接点数量，从最多的开始，把他当头，然后重复 //每次删除所有的叶子节点？最后剩下的就是答案？ if (n == 1) return &#123;0&#125;; vector&lt;int&gt; res; // 每个节点的度数 vector&lt;int&gt; degree(n); // 建立无向邻接图 vector&lt;vector&lt;int&gt;&gt; map(n); for (int i = 0; i &lt; edges.size(); i++) &#123; int v1 = edges[i][0]; int v2 = edges[i][1]; degree[v1]++; degree[v2]++; map[v1].push_back(v2); map[v2].push_back(v1); &#125; // 把度为1的节点入队 queue&lt;int&gt; q; for (int i = 0; i &lt; n; i++) &#123; if (degree[i] == 1) q.push(i); &#125; // BFS while (!q.empty()) &#123; // 清理当前层的节点 res.clear(); int size = q.size(); while (size--) &#123; int cur = q.front(); q.pop(); res.push_back(cur); // 减小对应度数 degree[cur]--; for (auto i : map[cur]) &#123; degree[i]--; if (degree[i] == 1) &#123; q.push(i); &#125; &#125; &#125; &#125; return res; //作者：carpe-diem-ew //[链接](https://leetcode-cn.com/problems/minimum-height-trees/solution/bfs-liang-duan-shao-xiang-qiu-zhong-dian-5mol/) //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; 剑指 Offer II 088. 爬楼梯的最少成本数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。 请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 12345678910111213class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //动态规划，起始点是-1，从-1支付0点走一步或两步，之后支付对应楼梯成本 vector&lt;int&gt; dp(cost.size()+1); dp[0] = 0; dp[1] = 0; for(int i = 2; i&lt;=cost.size();++i)&#123; dp[i] = min(cost[i-2] + dp[i-2],cost[i-1] + dp[i-1]); &#125; return dp[cost.size()]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"图","slug":"图","permalink":"http://spcablast.club/tags/%E5%9B%BE/"}],"author":"YP"},{"title":"Dailycode","slug":"20220107","date":"2022-01-06T16:00:00.000Z","updated":"2022-01-07T14:29:42.683Z","comments":true,"path":"2022/01/07/20220107/","link":"","permalink":"http://spcablast.club/2022/01/07/20220107/","excerpt":"","text":"最大网络秩n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。 两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。 整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。 给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。 1234567891011121314151617181920212223242526class Solution &#123;public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; //这是个无向图， //城市对的网络秩是两个点的边的数量，如果两个点互连，减一 //那这问题就转成在图里找两个点，他们的边最多，存一下，比一比 //暴力就来一个二维矩阵，n*n, //不暴力就来一个hash——map，没用， //来一个啥呢 int ans = 0; vector&lt;vector&lt;int&gt;&gt; adj(n);//邻接表存图 for (auto road : roads) adj[road[0]].emplace_back(road[1]), adj[road[1]].emplace_back(road[0]); for (int i = 0; i &lt; n; ++i) &#123; vector&lt;bool&gt; v(n);//存当前点连着哪些点 for (int j : adj[i]) &#123;//节点i和他连着的j ans = max(ans, (int)adj[i].size() + (int)adj[j].size() - 1); v[j] = true; &#125; for (int j = i + 1; j &lt; n; ++j)//节点i和剩下的节点j if (!v[j]) ans = max(ans, (int)adj[i].size() + (int)adj[j].size()); &#125; return ans; &#125;&#125;; 删除某些元素后的数组均值给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。 与 标准答案 误差在 10-5 的结果都被视为正确结果。 示例 1： 输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]输出：2.00000解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 12345678910111213class Solution &#123;public: double trimMean(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(),arr.end()); int start = arr.size()/20; int n = arr.size(); double ans = 0; for(int i = start; i &lt; n - start; ++i)&#123; ans +=arr [i]; &#125; return ans / (n - n / 10); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"图","slug":"图","permalink":"http://spcablast.club/tags/%E5%9B%BE/"},{"name":"多","slug":"多","permalink":"http://spcablast.club/tags/%E5%A4%9A/"}],"author":"YP"},{"title":"Dailycode","slug":"20220106","date":"2022-01-05T16:00:00.000Z","updated":"2022-01-06T12:35:11.909Z","comments":true,"path":"2022/01/06/20220106/","link":"","permalink":"http://spcablast.club/2022/01/06/20220106/","excerpt":"","text":"简化路径给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。 请注意，返回的 规范路径 必须遵循下述格式： 始终以斜杠 ‘/‘ 开头。两个目录名之间必须只有一个斜杠 ‘/‘ 。最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。返回简化后得到的 规范路径 。 示例 1： 输入：path = “/home/“输出：”/home”解释：注意，最后一个目录名后面没有斜杠。 1234567891011121314151617181920class Solution(object): def simplifyPath(self, path): \"\"\" :type path: str :rtype: str \"\"\" #用栈嘛，把规则写一写 #首先/入栈 #如果/后面有.. ./ ../ / 就去掉， # ... 还得留下， #如果最后一位是 / 也去掉 names = path.split(\"/\") stack = list() for name in names: if name == \"..\": if stack: stack.pop() elif name and name != \".\": stack.append(name) return \"/\" + \"/\".join(stack) 3 的幂给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x 示例 1： 输入：n = 27输出：true 12345678910111213141516class Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n == 0 : return False if n == 1 : return True while n!=1: if n%3 == 0: n/=3 else: return False return True 今日吐槽：好家伙，用python连if都不会写，哈哈哈","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"vector","slug":"vector","permalink":"http://spcablast.club/tags/vector/"}],"author":"YP"},{"title":"Dailycode","slug":"20220105","date":"2022-01-04T16:00:00.000Z","updated":"2022-01-05T12:50:42.687Z","comments":true,"path":"2022/01/05/20220105/","link":"","permalink":"http://spcablast.club/2022/01/05/20220105/","excerpt":"","text":"替换所有的问号给你一个仅包含小写英文字母和 ‘?’ 字符的字符串 s，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 ‘?’ 字符。 题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例 1： 输入：s = “?zs”输出：”azs”解释：该示例共有 25 种解决方案，从 “azs” 到 “yzs” 都是符合题目要求的。只有 “z” 是无效的修改，因为字符串 “zzs” 中有连续重复的两个 ‘z’ 。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string modifyString(string s) &#123; //补上什么呢，用一个数组，去掉左右，然后 int ans[26]; for(int i = 0;i&lt;26;++i)&#123; ans[i] = i; &#125; for(int i = 0;i&lt;s.size();++i)&#123; if(s[i] == '?')&#123; for(int j = 0; j &lt; 26; ++j)&#123; if(i == 0)&#123;//tou if(s[1] - 'a' == ans[j]) continue; else &#123; s[i] = 'a' + ans[j]; break; &#125; &#125; else if(i == s.size() -1)&#123;//wei if(s[s.size()-2] - 'a' == ans[j]) continue; else &#123; s[i] = 'a' + ans[j]; break; &#125; &#125; else&#123; if(s[i-1] - 'a' == ans[j] || s[i+1] - 'a' == ans[j]) continue; else s[i] = 'a' + ans[j]; &#125; &#125; &#125; &#125; return s; &#125;&#125;; 数的平方等于两数乘积的方法数给你两个整数数组 nums1 和 nums2 ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）： 类型 1：三元组 (i, j, k) ，如果 nums1[i]2 == nums2[j] * nums2[k] 其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; k &lt; nums2.length类型 2：三元组 (i, j, k) ，如果 nums2[i]2 == nums1[j] * nums1[k] 其中 0 &lt;= i &lt; nums2.length 且 0 &lt;= j &lt; k &lt; nums1.length 示例 1： 输入：nums1 = [7,4], nums2 = [5,2,8,9]输出：1解释：类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: // int getTriplets(const unordered_map&lt;int, int&gt;&amp; map1, const unordered_map&lt;int, int&gt;&amp; map2) &#123; // int triplets = 0; // for (const auto&amp; [num1, count1]: map1) &#123; // long long square = (long long)num1 * num1; // for (const auto&amp; [num2, count2]: map2) &#123; // if (square % num2 == 0 &amp;&amp; square / num2 &lt;= INT_MAX) &#123; // int num3 = square / num2; // if (num2 == num3) &#123; // int curTriplets = count1 * count2 * (count2 - 1) / 2; // triplets += curTriplets; // &#125; else if (num2 &lt; num3 &amp;&amp; map2.count(num3)) &#123; // int count3 = map2.at(num3); // int curTriplets = count1 * count2 * count3; // triplets += curTriplets; // &#125; // &#125; // &#125; // &#125; // return triplets; // &#125; int getTriplets(const unordered_map&lt;int,int&gt;&amp; map1, const unordered_map&lt;int, int&gt;&amp; map2)&#123; int ans = 0; for(const auto&amp; [num1, cnt1] : map1)&#123; long long sqrt1 = (long long)num1*num1;//少加了一个longlong溢出了 for(const auto&amp; [num2, cnt2] : map2)&#123; if(sqrt1 % num2 == 0 &amp;&amp; sqrt1 / num2 &lt;= INT_MAX)&#123; int num3 = sqrt1 / num2; if(num2 == num3)&#123; int temp = cnt1 * cnt2 * (cnt2 -1 ) /2;//排列组合 ans += temp; &#125; else if(num2 &lt; num3 &amp;&amp; map2.count(num3))&#123;//防止算两遍 int _num_num3 = map2.at(num3); int temp1 = cnt1 * cnt2 * _num_num3; ans += temp1; &#125; &#125; &#125; &#125; return ans; &#125; int numTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int, int&gt; map1, map2; for (int num: nums1) &#123; ++map1[num]; &#125; for (int num: nums2) &#123; ++map2[num]; &#125; return getTriplets(map1, map2) + getTriplets(map2, map1); &#125;&#125;; 今日吐槽：晚上睡少了，晚睡早起，等死吧，中午从11点半睡到1点，爽~开组会都不困，下午精神也很好，晚睡不如早睡，早早下班，该歇了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"YP"},{"title":"Dailycode","slug":"20220104","date":"2022-01-03T16:00:00.000Z","updated":"2022-01-04T14:19:52.445Z","comments":true,"path":"2022/01/04/20220104/","link":"","permalink":"http://spcablast.club/2022/01/04/20220104/","excerpt":"","text":"组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]示例 2： 输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 201 &lt;= k &lt;= n 1234567891011121314151617181920212223242526272829class Solution &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; void dfs(int start, int n, int k)&#123; //保存并返回条件 if(temp.size() == k) &#123; ans.push_back(temp); return; &#125; //返回条件 if(n - start + 1 + temp.size() &lt; k)&#123; return; &#125; //选start temp.push_back(start); dfs(start+1, n, k); //不选start temp.pop_back(); dfs(start + 1, n, k); &#125;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; //这，这不数学题吗，排列组合？C n k? //得找一个方案把所有结果列出来 //问题就在于怎么用代码复现取数的操作 dfs(1,n,k); return ans; &#125;&#125;; 相同的树给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3]输出：true 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public://靠，写完一看，忘了return true的条件，过了48/60的测试用例。。。。。。。。 bool dfs(TreeNode* p, TreeNode* q)&#123; if(p == nullptr &amp;&amp; q == nullptr) return true; else if(p == nullptr || q == nullptr) return false; else if(p-&gt;val != q-&gt;val) return false; else return dfs(p-&gt;left,q-&gt;left) &amp;&amp; dfs(p-&gt;right , q-&gt;right); &#125; bool isSameTree(TreeNode* p, TreeNode* q) &#123; bool ans = true; ans = dfs(p, q); return ans; &#125;&#125;; 今日吐槽：放假三天睡了个舒服，感觉和放假前几周完全不一样，正经人谁晚睡早起啊，当然是晚睡晚起啦，早睡早起也还行。就这个点，回去谁睡觉啊，虽然困了，那肯定也至少要11点以后了，除非9点跑路，九点下班就能11点前睡觉","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220103","date":"2022-01-02T16:00:00.000Z","updated":"2022-01-03T14:11:25.705Z","comments":true,"path":"2022/01/03/20220103/","link":"","permalink":"http://spcablast.club/2022/01/03/20220103/","excerpt":"","text":"一周中的第几天给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}。 示例 1： 输入：day = 31, month = 8, year = 2019输出：”Saturday” 12345678910111213class Solution &#123;public: string dayOfTheWeek(int day, int month, int year) &#123; vector&lt;string&gt; weeks&#123;\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;; vector&lt;int&gt; months&#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int days = 365*(year - 1970) + (year - 1969)/4;//四年一闰 for(int i = 0; i &lt; month - 1; ++i)&#123; days += months[i]; &#125; days += day; return weeks[(days + 3)%7]; &#125;&#125;; 删除一次得到子数组最大和给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。 注意，删除一个元素后，子数组 不能为空。 请看示例： 示例 1： 输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。 //不仅不会，而且不李姐 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int maximumSum(vector&lt;int&gt;&amp; arr) &#123; //靠，动态规划？ //得取一个连续子数组出来，去掉一个，和最大 //重点是去掉一个这个等于什么操作呢？ //数组和，那肯定是里面负数越少和越大 int n=arr.size(); bool flag=false;//表示数组里有无正数 int maxNum=INT_MIN;//存最大数 for(int i=0;i&lt;n;i++)&#123; if(arr[i]&gt;0)&#123; flag=true; break; &#125; maxNum=max(maxNum,arr[i]); &#125; if(flag==false)return maxNum; vector&lt;int&gt;pre(n+2),nex(n+2); int add=0; for(int i=1;i&lt;=n;i++)&#123;//记录从0到i的和的最大值 add+=arr[i-1]; if(add&lt;arr[i-1])add=arr[i-1]; pre[i]=add&gt;0?add:0; &#125; add=0; for(int i=n;i&gt;=1;i--)&#123;//记录从n到0的和的最大值 add+=arr[i-1]; if(add&lt;arr[i-1])add=arr[i-1]; nex[i]=add&gt;0?add:0; &#125; int ans=INT_MIN; for(int i=1;i&lt;=n;i++)&#123; ans=max(max(ans,pre[i-1] + nex[i+1] + arr[i-1]), pre[i-1] + nex[i+1]);//去掉i和不去掉i比较 &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20220102","date":"2022-01-01T16:00:00.000Z","updated":"2022-01-02T12:06:24.339Z","comments":true,"path":"2022/01/02/20220102/","link":"","permalink":"http://spcablast.club/2022/01/02/20220102/","excerpt":"","text":"消除游戏列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法： 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。给你整数 n ，返回 arr 最后剩下的数字。 示例 1： 输入：n = 9输出：6解释：arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]arr = [2, 4, 6, 8]arr = [2, 6]arr = [6] 123456789101112131415161718class Solution &#123;public: int lastRemaining(int n) &#123; int num=n;//记录剩下的数字数目 int l=1;//记录最小值 int r=n;//记录最大值 int d=0;//记录循环次数 int lift=1;//记录公差 while(num&gt;2)&#123; d++; if(num%2==1||num%2==0&amp;&amp;d%2==1)&#123;l+=lift;&#125;//从右到左 if(num%2==1||num%2==0&amp;&amp;d%2==0)&#123;r-=lift;&#125;//从左到右 num/=2; lift*=2; &#125; return num==2&amp;&amp;d%2==0?r:l; &#125;&#125;; 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢： 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 示例 1： 输入：s = “abc”, t = “ahbgdc”输出：true 12345678910111213141516class Solution &#123;public: bool isSubsequence(string s, string t) &#123; //那当然是一次循环建立一个hash表，数组都行，存哪些字母有，有几个啦 //不能改位置啊，打扰了 int n = s.length(), m = t.length(); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (s[i] == t[j]) &#123; i++; &#125; j++; &#125; return i == n; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20220101","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-02T12:06:11.152Z","comments":true,"path":"2022/01/01/20220101/","link":"","permalink":"http://spcablast.club/2022/01/01/20220101/","excerpt":"","text":"将一维数组转变成二维数组给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和 n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。 original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。 示例 2： 输入：original = [1,2,3], m = 1, n = 3输出：[[1,2,3]]解释：构造出的二维数组应该包含 1 行 3 列。将 original 中所有三个元素放入第一行中，构成要求的二维数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-1d-array-into-2d-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; construct2DArray(vector&lt;int&gt;&amp; original, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(m*n != original.size()) return ans; for(int i = 0; i&lt; m;++i)&#123; vector&lt;int&gt; temp; for(int j = 0; j&lt; n;j++)&#123; temp.push_back(original[i*n + j]); &#125; ans.push_back(temp); &#125; return ans; &#125;&#125;; 连接后等于目标字符串的字符串对给你一个 数字 字符串数组 nums 和一个 数字 字符串 target ，请你返回 nums[i] + nums[j] （两个字符串连接）结果等于 target 的下标 (i, j) （需满足 i != j）的数目。 示例 1： 输入：nums = [“777”,”7”,”77”,”77”], target = “7777”输出：4解释：符合要求的下标对包括： (0, 1)：”777” + “7” (1, 0)：”7” + “777” (2, 3)：”77” + “77” (3, 2)：”77” + “77” //有人在整活，但我不说是谁，7就完事儿了 12345678910111213141516171819202122232425262728class Solution &#123;public: int numOfPairs(vector&lt;string&gt;&amp; nums, string target) &#123; //这个乍一看，直接暴力， //仔细一想，还是想暴力 //hhh //想到个好主意，先把nums里面放到hash表里，避免有重复的 int result = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; stringstream ss; if (nums[i].size() &gt;= target.size()) &#123; continue; &#125; for (int j = 0; j &lt; nums.size(); j++) &#123; if (nums[j].size() + nums[i].size() != target.size() || j == i) &#123; continue; &#125; ss &lt;&lt; nums[i]; ss &lt;&lt; nums[j]; if (ss.str() == target) &#123; result++; &#125; ss.str(\"\"); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211231","date":"2021-12-30T16:00:00.000Z","updated":"2021-12-31T11:29:44.599Z","comments":true,"path":"2021/12/31/20211231/","link":"","permalink":"http://spcablast.club/2021/12/31/20211231/","excerpt":"","text":"完美数对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。 给定一个 整数 n， 如果是完美数，返回 true，否则返回 false 示例 1： 输入：num = 28输出：true解释：28 = 1 + 2 + 4 + 7 + 141, 2, 4, 7, 和 14 是 28 的所有正因子。示例 2： 输入：num = 6输出：true 1234567891011121314151617class Solution &#123;public: bool checkPerfectNumber(int num) &#123; //怎么求一个数的因数的和嘞，遍历也太离谱了 //1是一定有，从2遍历到num/2，3到num/3 , 根号num，到根号num if(num == 1) return false; int sum = 1; for(int i = 2; i * i &lt;=num; ++i)&#123; if(num % i == 0)&#123; sum+=i; sum+=num/i; &#125; &#125; if(sum == num) return true; return false; &#125;&#125;; 出现次数最多的子树元素和给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。 你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。 示例 1：输入: 5 / 2 -3返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。 123456789101112131415161718192021222324252627282930313233&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: unordered_map&lt;int,int&gt; sum; vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;&#x2F;&#x2F;后序遍历 vector&lt;int&gt;ans; dfs(root); int maxCnt&#x3D;0; for(auto mPair:sum)&#123; maxCnt&#x3D;max(maxCnt,mPair.second);&#x2F;&#x2F;目前次数最多的 &#125; for(auto mPair:sum)&#123; if(mPair.second&#x3D;&#x3D;maxCnt)ans.push_back(mPair.first); &#125; return ans; &#125; int dfs(TreeNode*root)&#123; if(!root) return 0; int add&#x3D;root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right); sum[add]++; return add; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20211229","date":"2021-12-28T16:00:00.000Z","updated":"2021-12-29T13:31:08.232Z","comments":true,"path":"2021/12/29/20211229/","link":"","permalink":"http://spcablast.club/2021/12/29/20211229/","excerpt":"","text":"最短无序连续子数组给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 请你找出符合题意的 最短 子数组，并输出它的长度。 示例 1： 输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。示例 2： 输入：nums = [1,2,3,4]输出：0示例 3： 输入：nums = [1]输出：0 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; //顺序遍历，如果出现第一个不是升序的，说明，记录下前边的最大值，如果出现的第一个不是升序的，就需要在前边找到他应该在的位置，也就是哪个数小于他， //这样前面又有序了，也获得了第一个插入的位置，就是答案的开始（后边可能会更新，但是没关系更新了就用新的）， //然后继续往后看，有小的就往前插，每次记录这个小的的位置，这就是答案的结尾 //欸，我觉得这样就行了 //欸，是不是不用插入，记住位置就行了 int left = -1, right = -1, _max = INT_MIN, _min = INT_MAX; for(int i = 0; i &lt; nums.size(); ++i)&#123; //保存升序的序列的最大值 if(nums[i] &lt; _max)&#123; right = i; &#125; else &#123; _max = nums[i];//记住前边最大的数 &#125; if(nums[nums.size()-i-1] &gt; _min)&#123; left = nums.size()-i-1; &#125; else&#123; _min = nums[nums.size() - i -1]; &#125; &#125; //前边的最大值大于目前值，说明目前值得往前移动，这就是右边界 //后边的最小值小于当前值，说明当前值要往后移，这就是左边界 return left == -1?0:right - left + 1; &#125;&#125;; 删除最外层的括号有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。 12345678910111213141516class Solution &#123;public: string removeOuterParentheses(string s) &#123; int L=1;int R=0;//CV大法好 string ans; for(int i=1;i&lt;s.size();i++)&#123; if(s[i]=='(')L++;//永远都是（打头， else R++; if(R!=L)ans.push_back(s[i]);//左右括号 else &#123; i++;L=1;R=0; &#125; &#125; return ans; &#125;&#125;; 整花活，整个向量按其中某一维排序整半天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211228","date":"2021-12-27T16:00:00.000Z","updated":"2021-12-28T12:02:09.264Z","comments":true,"path":"2021/12/28/20211228/","link":"","permalink":"http://spcablast.club/2021/12/28/20211228/","excerpt":"","text":"实现 Trie (前缀树)Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 输入[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”][[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]输出[null, null, true, false, true, null, true] 解释Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // 返回 Truetrie.search(“app”); // 返回 Falsetrie.startsWith(“app”); // 返回 Truetrie.insert(“app”);trie.search(“app”); // 返回 True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Trie &#123;public://淦呐，用什么来区分没一个单词呢，这里的重点还是能快速查找吧，甚至能根据前缀查找//首选肯定是hashmap，但是用什么来当map的值呢？单词咋转//我想到一个离谱的实现，26叉树，每个再26叉，太浪费空间了//每个单词算出来一个int类型的数？那怎么表示前缀呢直接a代表1，然后就吧字符串变成了，不对，还是没前缀//真用树啊，这我是没想到的，好像还挺省空间的，重复的长度的字母都在一个节点上，省不少，就是每个节点得来个指针vector&lt;Trie*&gt; children;bool isEnd; Trie() :children(26), isEnd(false)&#123;&#125; Trie* searchPrefix(string prefix) &#123; Trie * node = this; int ch = 0; for(char c : prefix)&#123; ch = c - 'a'; if(node-&gt;children[ch] == nullptr)&#123;//找到一半断了，说明没找着 return nullptr; &#125; node = node-&gt;children[ch]; &#125; return node; &#125; void insert(string word) &#123; Trie* node = this; int ch = 0; for(char c : word)&#123;//根节点的子节点没这字母就创一个，最后到头了isEnd置true ch = c - 'a'; if(node-&gt;children[ch] == nullptr)&#123; node-&gt;children[ch] = new Trie(); &#125; node = node-&gt;children[ch]; &#125; node-&gt;isEnd = true; &#125; bool search(string word) &#123; Trie* node = this-&gt;searchPrefix(word); return node != nullptr &amp;&amp; node-&gt;isEnd; &#125; bool startsWith(string prefix) &#123; return this-&gt;searchPrefix(prefix) != nullptr; &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */ 有一个问题，c++在return a &amp;&amp; b的时候，如果a是false，就不会管b有没有语法错误，比如 return node != nullptr &amp;&amp; node-&gt;isEnd; 我node为空的时候是不能用node-&gt;isEnd的，顺序调换一下运行时就会报错 存在重复元素给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1]输出: true 123456789101112131415161718192021222324class Solution &#123;public: // bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; // //暴力的话直接二重循环，有一个就返回false // //不暴力的话， // unordered_map&lt;int, int&gt; mymap; // for(int num : nums)&#123; // mymap[num]++; // if(mymap[num]&gt;=2) return true; // &#125; // return false; // &#125; //还可以哈希表 bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; s; for (int x: nums) &#123; if (s.find(x) != s.end()) &#123; return true; &#125; s.insert(x); &#125; return false; &#125;&#125;; 果然，简单题的评论区可以获得简单的快乐，都是人才","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"树 - 算法题","slug":"树-算法题","permalink":"http://spcablast.club/tags/%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211227","date":"2021-12-26T16:00:00.000Z","updated":"2021-12-27T12:15:41.995Z","comments":true,"path":"2021/12/27/20211227/","link":"","permalink":"http://spcablast.club/2021/12/27/20211227/","excerpt":"","text":"###825. 适龄的朋友在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。 如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求： age[y] &lt;= 0.5 * age[x] + 7age[y] &gt; age[x]age[y] &gt; 100 &amp;&amp; age[x] &lt; 100否则，x 将会向 y 发送一条好友请求。 注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。 返回在该社交媒体网站上产生的好友请求总数。 示例 1： 输入：ages = [16,16]输出：2解释：2 人互发好友请求。示例 2： 输入：ages = [16,17,18]输出：2解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int numFriendRequests(vector&lt;int&gt;&amp; ages) &#123; //那么这题的主要问题就在怎么解决a给b发了，b怎么知道该不给a发，让我我肯定用个hashmap，存谁给谁发了，下次有就查一查里面有没有 //再看题目要求 //他不会给比自己年纪大的人发，他自己小于100岁，对方大于100，一样 //他不会给小于自己年龄一半加7的人发， // x/2 + 7&lt; y &lt; x int ans = 0; sort(ages.begin(),ages.end());//升序排列，排列之后就有,前边的必然不会给后边的发，除非值相同 // for(int i = 0; i&lt; ages.size(); ++i)&#123;//j会不会向i发 // for(int j = 0; j &lt;= i; ++j)&#123;//超时了，我丢 // if(ages[j] &lt;= 14) continue; // if(ages[i] &lt; (ages[j] - 7)*2 &amp;&amp; i!=j)&#123; // ans++; // &#125; // if(ages[i] == ages[j] &amp;&amp; i!=j)&#123; // ans++; // &#125; // &#125; // &#125; int left = 0, right = 0,n = ages.size(); for (int age: ages) &#123;//获取这个age会发请求的人的区间 if (age &lt; 15) &#123; continue; &#125; while (ages[left] &lt;= 0.5 * age + 7) &#123; ++left; &#125; while (right + 1 &lt; n &amp;&amp; ages[right + 1] &lt;= age) &#123; ++right; &#125; ans += right - left; &#125; return ans; &#125;&#125;; 较大分组的位置在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 示例 1： 输入：s = “abbxxxxzzy”输出：[[3,6]]解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。示例 2： 输入：s = “abc”输出：[]解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) &#123; //直接，双指针 vector&lt;vector&lt;int&gt;&gt; ans; int left = 0, right = 1; if(s.size() &lt; 3) return ans; for(int i = 0; i&lt; s.size(); ++i)&#123; vector&lt;int&gt; temp = &#123;left,right&#125;; int _len = 1; while(s[left] == s[right])&#123; right++; _len++; &#125; if(_len &gt;= 3)&#123; temp[1] = right-1; ans.push_back(temp); if(right+2 &lt; s.size())&#123; left = right; right = right+1; &#125; else return ans; &#125; else&#123; if(right+1&lt;s.size())&#123; left = right; right = right+1; &#125; else return ans; &#125; &#125; return ans; &#125;&#125;; 今日吐槽：累了，下机，歇了","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211226","date":"2021-12-25T16:00:00.000Z","updated":"2021-12-27T12:19:35.910Z","comments":true,"path":"2021/12/26/20211226/","link":"","permalink":"http://spcablast.club/2021/12/26/20211226/","excerpt":"","text":"活字印刷你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。 注意：本题中，每个活字字模只能使用一次。 示例 1： 输入：”AAB”输出：8解释：可能的序列为 “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”。示例 2： 输入：”AAABBC”输出：188 12345678910111213141516171819202122class Solution &#123;//排列组合题，去掉相同的组合，public: int res; void dfs(map&lt;char, int&gt;&amp; hash) &#123;//这个dfs是绝了，这个字母取一个，然后生成一个新的hashmap，重复操作 for (auto&amp; data : hash) &#123; if (data.second &gt; 0) &#123; data.second--;//用完之后数量减一 res++; dfs(hash); data.second++;//相当于溜完他开头的，溜下一个开头的 &#125; &#125; &#125; int numTilePossibilities(string tiles) &#123;//用hashmap记录各种字母的数量，怎么达到去重，还得看dfs map&lt;char, int&gt; hash; for (char c : tiles) &#123; hash[c]++; &#125; dfs(hash); return res; &#125;&#125;; Bigram 分词给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 “first second third” 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。 示例 1： 输入：text = “alice is a good girl she is a good student”, first = “a”, second = “good”输出：[“girl”,”student”]示例 2： 输入：text = “we will we will rock you”, first = “we”, second = “will”输出：[“we”,”rock”] 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findOcurrences(string text, string first, string second) &#123; vector&lt;string&gt; textlist; int s = 0, e = 0, len = text.length(); while (true) &#123;//存到vector里，判断有没有连续的first和second，有就答案加加 while (s &lt; len &amp;&amp; text[s] == ' ') &#123;//直接双指针 s++; &#125; if (s &gt;= len) &#123; break; &#125; e = s + 1; while (e &lt; len &amp;&amp; text[e] != ' ') &#123; e++; &#125; textlist.push_back(text.substr(s, e - s)); s = e + 1; &#125; vector&lt;string&gt; ans; for (int i = 2; i &lt; textlist.size(); i++) &#123; if (textlist[i - 2] == first &amp;&amp; textlist[i - 1] == second) &#123; ans.push_back(textlist[i]); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"}],"author":"YP"},{"title":"Dailycode","slug":"20211225","date":"2021-12-24T16:00:00.000Z","updated":"2021-12-26T01:04:07.171Z","comments":true,"path":"2021/12/25/20211225/","link":"","permalink":"http://spcablast.club/2021/12/25/20211225/","excerpt":"","text":"奇偶树如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ： 二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: bool isEvenOddTree(TreeNode* root) &#123; //层序遍历呗，奇数层偶数层分别不同的规则，判断一下就行 queue&lt;TreeNode*&gt; qu; int level = 0; qu.push(root); while(!qu.empty())&#123; //弹出根节点，压栈两个子节点 int prev = level % 2 == 0 ? INT_MIN : INT_MAX; int size = qu.size(); for(int i = 0; i&lt; size;++i)&#123; TreeNode * temp = qu.front(); qu.pop(); if(level % 2 == 0)&#123;//偶数层 if(temp-&gt;val % 2 == 0 || temp-&gt;val &lt;= prev)&#123; return false; &#125; &#125; if(level % 2 == 1)&#123;//奇数层 if(temp-&gt;val % 2 == 1 || temp-&gt;val &gt;= prev)&#123; return false; &#125; &#125; prev = temp-&gt;val; if (temp-&gt;left != nullptr) &#123; qu.push(temp-&gt;left); &#125; if (temp-&gt;right != nullptr) &#123; qu.push(temp-&gt;right); &#125; &#125; level++; &#125; return true; &#125;&#125;; 括号的最大嵌套深度如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）： 字符串是一个空字符串 “”，或者是一个不为 “(“ 或 “)” 的单字符。字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)： depth(“”) = 0depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 “(“ 或者 “)”depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串depth(“(“ + A + “)”) = 1 + depth(A)，其中 A 是一个 有效括号字符串例如：””、”()()”、”()(()())” 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 “)(“ 、”(()” 都不是 有效括号字符串 。 给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。 示例 1： 输入：s = “(1+(2*3)+((8)/4))+1”输出：3解释：数字 8 在嵌套的 3 层括号中。 123456789101112131415161718class Solution &#123;public: int maxDepth(string s) &#123; //上栈,甚至不用 int depth = 0; int _max = 0; for(char c : s)&#123; if( c =='(')&#123; depth ++ ; _max = depth &gt; _max?depth:_max; &#125; if(c == ')')&#123; depth --; &#125; &#125; return _max; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"有一个功能他加着加着就把站炸了","slug":"node版本管理","date":"2021-12-24T16:00:00.000Z","updated":"2021-12-27T07:56:24.436Z","comments":true,"path":"2021/12/25/node版本管理/","link":"","permalink":"http://spcablast.club/2021/12/25/node%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"hexo 版本和nodejs版本得对应，hexo更新到最新了，欸，又嫌弃node版本太低，node版本更新了，行了，发布的时候github觉得node版本太高 于是就需要一个nodejs的版本管理器，nvm下载地址安装的时候需要装在路径名没中文，没空格的地方，你看那个Program Files,这不就一个空格嘛。 在node的官网下载对应版本，比如node-v16.4.2-win-x64.zip,解压丢到D:\\nvm下边就行了,文件夹改名为v16.4.2； 用管理员权限开命令提示符，敲进去nvm use 16.4.2就ok了 nvm use 报错：exit status 1 + 乱码，两种可能 nvm安装路径有中文或者空格 打开cmd没有使用管理员权限 管理了node的版本发现里边没装hexo，当然没装了，这都新下的nodejs，还好之前下的文件夹还在，开始重头再来，都重头再来了，下次换电脑更方便 来自从头建站npm install -g hexo-cli安装hexo 装完了hexo再装aplaer npm install hexo-tag-aplayer –save","categories":[{"name":"nvm","slug":"nvm","permalink":"http://spcablast.club/categories/nvm/"}],"tags":[{"name":"nodejs版本管理","slug":"nodejs版本管理","permalink":"http://spcablast.club/tags/nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211224","date":"2021-12-23T16:00:00.000Z","updated":"2021-12-25T01:48:40.568Z","comments":true,"path":"2021/12/24/20211224/","link":"","permalink":"http://spcablast.club/2021/12/24/20211224/","excerpt":"","text":"搜索旋转排序数组整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0输出：4 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; //本来是升序排列，但是突然尾巴接头了，所以会突然有一个降序，所以直接判断目标和首尾的大小 //如果target &gt; head //往前二分 // //如果target &lt; tail //往后二分 //否则找不到 if(!nums.size()) return -1; if(nums.size() == 1) return nums[0] == target? 0 : -1; int left = 0, right = nums.size() - 1; int mid; while(left &lt;= right)&#123; mid = (left + right)/2; if(nums[mid] == target) return mid; if (nums[0] &lt;= nums[mid]) &#123; if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;//前半部分有序 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else if( nums[0] &gt; nums[mid] )&#123;// if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.size() -1]) &#123;// left = mid +1; &#125; else&#123; right = mid -1; &#125; &#125; &#125; return -1;//找不到 &#125;&#125;; ###476. 数字的补数对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。 例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。给你一个整数 num ，输出它的补数。 示例 1： 输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 数字的补数对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。 例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。给你一个整数 num ，输出它的补数。 示例 1： 输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 1234567891011121314151617181920class Solution &#123;public://位运算的题，这题可以整很多天了 int findComplement(int num) &#123;//前头补1，直接取反 uint t = 1u &lt;&lt; 31; while (! (t &amp; num)) &#123; num |= t; t &gt;&gt;= 1; &#125; return ~num; // long a = 1; // while(true)&#123; // if(num &gt;= a)&#123; // a &lt;&lt;= 1; // 等价于 a *= 2; // &#125;else&#123; // return a - num - 1; // &#125; // &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"二分","slug":"二分","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%88%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211223","date":"2021-12-22T16:00:00.000Z","updated":"2021-12-27T12:19:56.449Z","comments":true,"path":"2021/12/23/20211223/","link":"","permalink":"http://spcablast.club/2021/12/23/20211223/","excerpt":"","text":"###589. N 叉树的前序遍历给定一个 N 叉树，返回其节点值的 前序遍历 。 N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 进阶： 递归法很简单，你可以使用迭代法完成此题吗?//简简单单一个dfs 1234567891011121314151617181920212223242526272829303132/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt;ans; void DFS(Node* root)&#123; if(root)&#123; ans.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; DFS(root-&gt;children[i]); &#125; &#125; &#125; vector&lt;int&gt; preorder(Node* root) &#123; DFS(root); return ans; &#125;&#125;; ###576. 出界的路径数给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。 12345678910111213141516171819202122232425262728class Solution &#123;public: static constexpr int MOD = 1'000'000'007; int findPaths(int m, int n, int maxMove, int startRow, int startColumn) &#123; vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; int outCounts = 0; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(maxMove + 1, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n))); dp[0][startRow][startColumn] = 1; for (int i = 0; i &lt; maxMove; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; int count = dp[i][j][k]; if (count &gt; 0) &#123; for (auto &amp;direction : directions) &#123; int j1 = j + direction[0], k1 = k + direction[1]; if (j1 &gt;= 0 &amp;&amp; j1 &lt; m &amp;&amp; k1 &gt;= 0 &amp;&amp; k1 &lt; n) &#123; dp[i + 1][j1][k1] = (dp[i + 1][j1][k1] + count) % MOD; &#125; else &#123; outCounts = (outCounts + count) % MOD; &#125; &#125; &#125; &#125; &#125; &#125; return outCounts; &#125;&#125;; 今日吐槽：在实验室的电脑写了题，家里的电脑登陆力扣并没有通过的代码，说明存本地了；早早下班，昨天11点40睡上午虽然没反应，下午2点多到3点直接困倒在桌上，下班早可以运动运动 修改_partial 下边的 articl.ejs可以修改文章页面内容 var ap = new APlayer({ element: document.getElementById(\"aplayer-FVuHOgjv\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var ap = new APlayer({ element: document.getElementById(\"aplayer-ibLhWrTH\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"测试曲目\", author: \"lol\", url: \"test.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); {方法二，直接使用网易云音乐：% meting “972904675” “netease” “playlist”“autoplay “ “mutex:false” 先打断施法”listmaxheight:340px” “preload:none” “theme:#ad7a86”%} me打断施法，使用网易云的单曲也行ting “31654455” “ne打断tease” “song” “preload:auto” 这个行 ![tes t](/im age/av atar.jpg) hexo如何使用本地资源，以及放置路径 参考博客参考博客","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"音频添加","slug":"音频添加","permalink":"http://spcablast.club/tags/%E9%9F%B3%E9%A2%91%E6%B7%BB%E5%8A%A0/"}],"author":"YP"},{"title":"Dailycode","slug":"20211222","date":"2021-12-21T16:00:00.000Z","updated":"2021-12-27T12:20:10.007Z","comments":true,"path":"2021/12/22/20211222/","link":"","permalink":"http://spcablast.club/2021/12/22/20211222/","excerpt":"","text":"###687. 最长同值路径给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5输出: 2 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int ans; int dfs(TreeNode* root)&#123;//直接dfs，左子树最长的和右子树哪个长，取长的，返回//靠，这题也挺难 if(!root)return 0; int l = dfs(root-&gt;left), r = dfs(root-&gt;right); int lp = (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) ? l : 0; int rp = (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == root-&gt;val) ? r : 0; ans = max(ans, lp + rp); return max(lp, rp) + 1; &#125; int longestUnivaluePath(TreeNode* root) &#123; ans = 0; dfs(root); return ans; &#125;&#125;; ###349. 两个数组的交集给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); vector&lt;int&gt; ans; int i = 0, j = 0; while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())&#123; if(nums1[i] &lt; nums2[j])&#123;//1&lt;2,外层走 i++; &#125; else if(nums1[i] == nums2[j])&#123;//1==2，一起走 if (!ans.size() || nums2[j] != ans.back()) &#123; ans.push_back(nums2[j]); &#125; i++; j++; &#125; else&#123;//1&gt;2,j自己走 j++;//continue; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"}],"author":"YP"},{"title":"Dailycode","slug":"20211221","date":"2021-12-20T16:00:00.000Z","updated":"2021-12-27T12:20:24.944Z","comments":true,"path":"2021/12/21/20211221/","link":"","permalink":"http://spcablast.club/2021/12/21/20211221/","excerpt":"","text":"一年中的第几天给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。 示例 1： 输入：date = “2019-01-09”输出：9 123456789101112131415161718192021222324252627class Solution &#123;public: int dayOfYear(string date) &#123; vector&lt;int&gt; dateofyear; int ans = 0; string temp = \"\"; for(int i = 0; i &lt; date.size(); ++i)&#123; if(date[i] != '-')&#123; temp.push_back(date[i]); &#125; else&#123; dateofyear.push_back(atoi(temp.c_str())); temp = \"\"; &#125; &#125; dateofyear.push_back(atoi(temp.c_str())); int month[12] = &#123;31, 28 ,31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; //好了，年月日已经有了，接下来就是判断闰月了 if((dateofyear[0] % 400 == 0) || (dateofyear[0] % 4 == 0 &amp;&amp; dateofyear[0] % 100 !=0))&#123;//闰月再判断是否2月 month[1]++; &#125; for(int i = 0; i &lt; dateofyear[1] - 1; ++i)&#123; ans+=month[i]; &#125; return ans + dateofyear[2]; &#125;&#125;; 掷骰子的N种方法这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。 我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。 如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。 示例 1： 输入：d = 1, f = 6, target = 3输出：1 12345678910111213141516171819202122232425262728class Solution &#123;public: int numRollsToTarget(int n, int k, int target) &#123; //我靠，就是给你一个数，看d个0到f的数有几种组合加起来会等于这个数 //动 态 规 划 //dp[i][j] 扔i个骰子和为j和dp[i-1][j]的关系？没啥关系，和dp[i-1][j-1]有关系吧 // int dp[n+1][target+1]; memset(dp, 0, sizeof(dp)); int base = 1000000007; for (int i = 1; i &lt;= min(k, target); ++i) &#123; dp[1][i] = 1; &#125; for (int i = 2; i &lt;= n; ++i) &#123; // 最小是i（骰子最小是1） for (int j = i; j &lt;= min(n*k, target); ++j) &#123; for (int l = 1; l &lt;= k &amp;&amp; j - l &gt;= 0; ++l) &#123; dp[i][j] = (dp[i][j] + dp[i-1][j-l]) % base; &#125; &#125; &#125; return dp[n][target]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211220","date":"2021-12-19T16:00:00.000Z","updated":"2021-12-20T12:47:21.811Z","comments":true,"path":"2021/12/20/20211220/","link":"","permalink":"http://spcablast.club/2021/12/20/20211220/","excerpt":"","text":"###475. 供暖器冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 在加热器的加热半径范围内的每个房屋都可以获得供暖。 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1: 输入: houses = [1,2,3], heaters = [2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123; //找两个热水器间隔最远是多少是不是就行了， //如果只有一个热水器，那就长度 // int left = 0, right = 0; // for(int i = 0; i &lt; heaters.size(); ++i)&#123; // right = max(heaters[i] - left, right); // left = heaters[i]; // &#125; // right = max(right, (houses[houses.size()-1] - heaters[heaters.size() -1]));//最后一个房子位置减去最后一个热水器位置 // right -= 1; // return right%2 == 0?right/2:(right+1)/2; //如果能用一个houses这么大的映射，存下每一个house里的离得最近的热水器的距离，最后去这些距离里面最大的，那这不就是要的半径的两倍嘛。 int _max = INT_MIN, _min = 0, j = 0; sort(houses.begin(), houses.end()); sort(heaters.begin(), heaters.end()); for(int i = 0; i &lt; houses.size(); ++i)&#123; _min = abs(heaters[j] - houses[i]); //if(_min &gt; 0) return j; for(;j &lt;heaters.size() - 1; ++j)&#123; if(abs(heaters[j+1] - houses[i]) &lt; _min)&#123; _min = min(abs(heaters[j+1] - houses[i]), _min);//得到每个房子到热水器最近距离 &#125; else break; &#125; _max = max(_max, _min); //在最近距离里取最大 &#125; return _max; // sort(houses.begin(), houses.end()); // sort(heaters.begin(), heaters.end()); // int ans = 0; // for (int i = 0, j = 0; i &lt; houses.size(); i++) &#123; // int curDistance = abs(houses[i] - heaters[j]); // while (j &lt; heaters.size() - 1 &amp;&amp; abs(houses[i] - heaters[j]) &gt;= abs(houses[i] - heaters[j + 1])) &#123; // j++; // curDistance = min(curDistance, abs(houses[i] - heaters[j])); // &#125; // ans = max(ans, curDistance); // &#125; // return ans; &#125;&#125;; ###594. 最长和谐子序列和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 示例 1： 输入：nums = [1,3,2,2,5,2,3,7]输出：5解释：最长的和谐子序列是 [3,2,2,2,3] 12345678910111213141516class Solution &#123;public: int findLHS(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; cnt; int ans = 0; for (int num : nums) &#123; cnt[num]++; &#125; for (auto [key, val] : cnt) &#123; if (cnt.count(key + 1)) &#123;//如果有比这个数大1的 ans = max(ans, val + cnt[key + 1]); &#125; &#125; return res; &#125;&#125;; 今日吐槽：我今天早点睡明天会充满power吧，会吧？","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211219","date":"2021-12-18T16:00:00.000Z","updated":"2021-12-19T12:38:45.367Z","comments":true,"path":"2021/12/19/20211219/","link":"","permalink":"http://spcablast.club/2021/12/19/20211219/","excerpt":"","text":"###9. 回文数给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(int x) &#123; //如果直接转字符串，取反，转整数，是不是直接就有了 if(x&lt;0) return false; if(x ==0 )return true; vector&lt;int&gt; list; while(x&gt;0)&#123; list.push_back(x%10); x/=10; &#125; int left = 0, right = list.size() -1; while(left&lt;=right)&#123; if(list[left] != list[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125;; ###1814. 统计一个数组中好对子的数目给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ： 0 &lt;= i &lt; j &lt; nums.lengthnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。 示例 1： 输入：nums = [42,11,1,97]输出：2解释：两个坐标对为： (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。 (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int rev(int num)&#123; int ans = 0; while(num)&#123; ans = ans*10 + num%10; num /= 10; &#125; return ans; &#125; // int countNicePairs(vector&lt;int&gt;&amp; nums) &#123; // //那不就是num[i] - revnum[i] = num[j] - revnum[j] // //新建一个数组，把所有的存起来， // //只需要写一个rev函数 // long ans = 0; // for(int i = 0; i &lt; nums.size(); ++i)&#123; // nums[i] -= rev(nums[i]); // &#125; // for(int i = 0;i&lt;nums.size();++i)&#123; // for(int j = i+1;j&lt;nums.size();++j)&#123; // if(nums[j] == nums[i])&#123; // ans++; // ans = ans%(1000000007); // &#125; // &#125; // &#125; // return ans; // &#125; //超时了，超时了就用哈希表呗 int countNicePairs(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; mp; int ans = 0; for(int i=0; i&lt;nums.size(); i++)&#123; int re = rev(nums[i]); ans = (ans + mp[nums[i] - re]) % 1000000007; mp[nums[i] - re]++; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211218","date":"2021-12-17T16:00:00.000Z","updated":"2021-12-18T02:10:33.509Z","comments":true,"path":"2021/12/18/20211218/","link":"","permalink":"http://spcablast.club/2021/12/18/20211218/","excerpt":"","text":"###419. 甲板上的战舰给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。 战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。 1234567891011121314151617181920212223242526class Solution &#123;public: int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; //这题是检查有几行或者几列有超过2个X的嘛 //o，不是，是一个战舰至少在同一行或同一列占2格，数有多少个战舰 //那我只要统计每一行和每一列的，左边没有X，上边没有X的X的个数，就是答案 //硬算的话，只需要把一个X后边的或者下边的X干掉，就不会干扰到下一个的计算 int row = board.size(); int col = board[0].size(); int ans = 0; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (board[i][j] == 'X') &#123; if (i &gt; 0 &amp;&amp; board[i - 1][j] == 'X') &#123; continue; &#125; if (j &gt; 0 &amp;&amp; board[i][j - 1] == 'X') &#123; continue; &#125; ans++; &#125; &#125; &#125; return ans; &#125;&#125;; ###434. 字符串中的单词数统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: “Hello, my name is John”输出: 5解释: 这里的单词是指连续的不是空格的字符，所以 “Hello,” 算作 1 个单词。 12345678910111213class Solution &#123;public: int countSegments(string s) &#123; if(!s.size()) return 0; int ans = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if ((i == 0 || s[i - 1] == ' ') &amp;&amp; s[i] != ' ') &#123; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211216","date":"2021-12-15T16:00:00.000Z","updated":"2021-12-27T12:20:54.952Z","comments":true,"path":"2021/12/16/20211216/","link":"","permalink":"http://spcablast.club/2021/12/16/20211216/","excerpt":"","text":"###94. 二叉树的中序遍历给定一个二叉树的根节点 root ，返回它的 中序 遍历。 //让我想起了以前上课的时候 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void lfd(TreeNode* root)&#123; if(!root) return; lfd(root-&gt;left); ans.push_back(root-&gt;val); lfd(root-&gt;right); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; //中序遍历 //左，中，右 lfd(root); return ans; &#125;private: vector&lt;int&gt; ans;&#125;; ###95. 不同的二叉搜索树 II给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 示例 1： 输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public://不会，这递归可太妙了//首先挨个遍历，//每一个进行一个什么操作，每一个根节点进行一个递归，进行一个对他所有子节点作为根节点的递归//好像乱了，就是把每个值都当作一个根节点，把所有左子树，右子树列出来，拼成一个树，存到答案里 vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123; if (start &gt; end) &#123; return &#123; nullptr &#125;; &#125; vector&lt;TreeNode*&gt; allTrees; // 枚举可行根节点 for (int i = start; i &lt;= end; i++) &#123; // 获得所有可行的左子树集合 vector&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - 1); // 获得所有可行的右子树集合 vector&lt;TreeNode*&gt; rightTrees = generateTrees(i + 1, end); // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上 for (auto&amp; left : leftTrees) &#123; for (auto&amp; right : rightTrees) &#123; TreeNode* currTree = new TreeNode(i); currTree-&gt;left = left; currTree-&gt;right = right; allTrees.emplace_back(currTree); &#125; &#125; &#125; return allTrees; &#125; vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if (!n) &#123; return &#123;&#125;; &#125; return generateTrees(1, n); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211215","date":"2021-12-14T16:00:00.000Z","updated":"2021-12-27T12:21:08.426Z","comments":true,"path":"2021/12/15/20211215/","link":"","permalink":"http://spcablast.club/2021/12/15/20211215/","excerpt":"","text":"###851. 喧闹和富有有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 “person x “。 给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。 示例 1： 输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]输出：[5,5,2,5,4,5,6,7]解释：answer[0] = 5，person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，但是目前还不清楚他是否比 person 0 更有钱。answer[7] = 7，在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），最安静（有较低安静值 quiet[x]）的人是 person 7。其他的答案也可以用类似的推理来解释。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;int&gt; loudAndRich(vector&lt;vector&lt;int&gt;&gt;&amp; richer, vector&lt;int&gt;&amp; quiet) &#123; //这题的意思是给你一个人x，返回比他有钱的所有人中quiet值最小的人的号 //这看起来像图的题啊，每个人挂一个链表，后边接所有比他有钱的人，就解决了，但是是不是浪费空间 //欸，那我给按所有人的有钱等级排个序，就有了，排了， //哦~我懂了，我需要一个map，没过一个pair，就把比这个人有钱的quiet值和存了的比一下 //奥，不需要pair，只需要一个n位的数组，每经过一个pair就更新比这个人有钱的人的quiet // int n = richer.size(); // vector&lt;int&gt; ans(n,INT_MAX); // for(int i = 0; i &lt; n; ++i)&#123; // int num = quiet[richer[i][1]]; // if(ans[richer[i][0]] &gt; num)&#123; // ans[richer[i][0]] = num; // &#125; // &#125; // return ans; //阅读理解失败，有钱是连环的，还是得用链表或者图 int n = quiet.size(); vector&lt;vector&lt;int&gt;&gt; g(n); for (auto &amp;r : richer) &#123; g[r[1]].emplace_back(r[0]);//整了个类似链表的vector，也行，用一行存所有比这个人有钱的人 &#125; vector&lt;int&gt; ans(n, -1); function&lt;void(int)&gt; dfs = [&amp;](int x) &#123;//啊（二声），写的什么东西 if (ans[x] != -1) &#123; return; &#125; ans[x] = x; for (int y : g[x]) &#123;//从第一个比这个人有钱的开始 dfs(y);//找其他比，比他有钱的人有钱的 if (quiet[ans[y]] &lt; quiet[ans[x]]) &#123; ans[x] = ans[y]; &#125; &#125; &#125;; for (int i = 0; i &lt; n; ++i) &#123; dfs(i); &#125; return ans; &#125;&#125;; ###563. 二叉树的坡度给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度就是其所有节点的坡度之和。 示例 1： 输入：root = [1,2,3]输出：1解释：节点 2 的坡度：|0-0| = 0（没有子节点）节点 3 的坡度：|0-0| = 0（没有子节点）节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）坡度总和：0 + 0 + 1 = 1示例 2： 输入：root = [4,2,9,3,5,null,7]输出：15解释：节点 3 的坡度：|0-0| = 0（没有子节点）节点 5 的坡度：|0-0| = 0（没有子节点）节点 7 的坡度：|0-0| = 0（没有子节点）节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 1234567891011121314151617181920212223242526272829&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: &#x2F;&#x2F;说实话，就是计算两棵树的节点和再减一下，再递归一下 int ans &#x3D; 0; int findTilt(TreeNode* root) &#123; dfs(root); return ans; &#125; int dfs(TreeNode* node) &#123; if (node &#x3D;&#x3D; nullptr) &#123; return 0; &#125; int sumLeft &#x3D; dfs(node-&gt;left);&#x2F;&#x2F;左子树的和 int sumRight &#x3D; dfs(node-&gt;right);&#x2F;&#x2F;右子数的和 ans +&#x3D; abs(sumLeft - sumRight);&#x2F;&#x2F;每个节点的坡度累加 return sumLeft + sumRight + node-&gt;val;&#x2F;&#x2F;返回整棵树的节点和 &#125; &#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211214","date":"2021-12-13T16:00:00.000Z","updated":"2021-12-27T12:21:17.659Z","comments":true,"path":"2021/12/14/20211214/","link":"","permalink":"http://spcablast.club/2021/12/14/20211214/","excerpt":"","text":"###931. 下降路径最小和给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。 下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。 示例 1： 输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]输出：13解释：下面是两条和最小的下降路径，用加粗+斜体标注：[[2,1,3], [[2,1,3], [6,5,4], [6,5,4], [7,8,9]] [7,8,9]] 1234567891011121314151617181920212223class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; //下降路径，第一行挑最小，但是第一行每个都作为起点 //best = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1]) int N = matrix.size(); for (int r = N-2; r &gt;= 0; --r) &#123;//从倒数第二行开始 for (int c = 0; c &lt; N; ++c) &#123; int best = matrix[r+1][c]; if (c &gt; 0) best = min(best, matrix[r+1][c-1]); if (c+1 &lt; N) best = min(best, matrix[r+1][c+1]); matrix[r][c] += best; &#125; &#125; int ans = INT_MAX; for (int x: matrix[0]) ans = min(ans, x); return ans; &#125;&#125;; ###933. 最近的请求次数写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：[“RecentCounter”, “ping”, “ping”, “ping”, “ping”][[], [1], [100], [3001], [3002]]输出：[null, 1, 2, 3, 3] 解释：RecentCounter recentCounter = new RecentCounter();recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2recentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3recentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3 12345678910111213141516class RecentCounter &#123;private: queue&lt;int&gt; q;//队列存time，是不是可以直接用数组，数组不如vector，vector不如队列，public: RecentCounter() &#123;&#125; int ping(int t) &#123; q.push(t); while (t - q.front() &gt; 3000) q.pop(); //若时间太早，则循环出队 return q.size(); //最后返回队列长度，即最近3000ms的请求次数 &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211213","date":"2021-12-12T16:00:00.000Z","updated":"2021-12-27T12:21:27.008Z","comments":true,"path":"2021/12/13/20211213/","link":"","permalink":"http://spcablast.club/2021/12/13/20211213/","excerpt":"","text":"###807. 保持城市天际线给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。 城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。 我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。 在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //这题的意思就是填格子吧，每个格子可以补充到行列最大值里小的那个 //所以需要获取每行和每列的最大值 //遍历两遍行了，第一遍存行加列减一个最大值， //第二遍累加/我只要算每一行每一列的总和，存起来，就不用累加了//没用，别存了 if(grid.size()==0) return 0; int col = 0, row = 0, ans = 0; vector&lt;int&gt; rowmax(grid.size(),0); vector&lt;int&gt; colmax(grid[0].size(),0); row = grid.size(); col = grid[0].size(); for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; rowmax[i] = grid[i][j]&gt;rowmax[i]?grid[i][j]:rowmax[i]; &#125; &#125; for(int i = 0; i&lt;col; ++i)&#123; for(int j = 0; j&lt;row; ++j)&#123; colmax[i] = grid[j][i]&gt;colmax[i]?grid[j][i]:colmax[i]; &#125; &#125; for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; int maxnum = min(rowmax[i], colmax[j]); if(maxnum - grid[i][j] &gt;=0)&#123; ans +=maxnum - grid[i][j]; &#125; &#125; &#125; return ans; &#125;&#125;; ###剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。例如:给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果： [ [3], [9,20], [15,7]] 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; //层次遍历，返回条件是啥嘞 vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; points;//队列存每层根节点 points.push(root); while(points.size())&#123; int col=points.size();//当前层有几个节点 vector&lt;int&gt; ans1;//存当前层数据 for(int i=0;i&lt;col;i++)&#123;//根据数量从队列里取相应的节点 TreeNode *temp=points.front(); points.pop(); ans1.push_back(temp-&gt;val); if(temp-&gt;left) points.push(temp-&gt;left); if(temp-&gt;right) points.push(temp-&gt;right); &#125; ans.push_back(ans1); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"二叉树 - 算法题","slug":"二叉树-算法题","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211212","date":"2021-12-11T16:00:00.000Z","updated":"2021-12-12T12:08:37.754Z","comments":true,"path":"2021/12/12/20211212/","link":"","permalink":"http://spcablast.club/2021/12/12/20211212/","excerpt":"","text":"转换成小写字母给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。 示例 1： 输入：s = “Hello”输出：”hello” 123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(int i&#x3D;0;i&lt;s.size();++i)&#123; s[i] &#x3D; tolower(s[i]); &#125; return s; &#125;&#125;; ###421. 数组中两个数的最大异或值给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。 进阶：你可以在 O(n) 的时间解决这个问题吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; //找异或值最大的俩，就是要1最多，两个数异或等于1，就是同位相等，就着最大值怎么样，拿着最大值和其他的数来 //所以要不要转成2进制 //首先看谁的1111111111，前面的1位置远，然后 //动态规划行吗，存当前最大的值 //1个的时候是自己，2个的时候也是，三个的时候分别用两个数和第三个数异或，然后挑大的，这样又只剩下两个数了，再第四位，好像行 // int left = 0,right = 0, ans=0; // if(nums.size() == 0) return 0; // if(nums.size() == 1) return nums[0]; // if(nums.size() == 2) return nums[0]^nums[1]; // for(int i = 0;i&lt;nums.size();++i)&#123; // if((left ^ nums[i]) &gt; ans)&#123; // right = nums[i]; // ans = left ^ right; // &#125; // else if((right ^ nums[i]) &gt; ans)&#123; // left = nums[i]; // ans = left ^ right; // &#125; // ans = left ^ right; // &#125; // return ans; //那我只能说，康康题解，这题怎么可能On的，啊，翻译翻译，什么叫On int x = 0; for (int k = HIGH_BIT; k &gt;= 0; --k) &#123; unordered_set&lt;int&gt; seen; // 将所有的 pre^k(a_j) 放入哈希表中 for (int num: nums) &#123; // 如果只想保留从最高位开始到第 k 个二进制位为止的部分 // 只需将其右移 k 位 seen.insert(num &gt;&gt; k); &#125; // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分 // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1 int x_next = x * 2 + 1; bool found = false; // 枚举 i for (int num: nums) &#123; if (seen.count(x_next ^ (num &gt;&gt; k))) &#123; found = true; break; &#125; &#125; if (found) &#123; x = x_next; &#125; else &#123; // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0 // 即为 x = x*2 x = x_next - 1; &#125; &#125; return x; &#125;private: // 最高位的二进制位编号为 30 static constexpr int HIGH_BIT = 30;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110_","date":"2021-12-09T16:00:00.000Z","updated":"2021-12-10T12:17:52.091Z","comments":true,"path":"2021/12/10/20211110_/","link":"","permalink":"http://spcablast.club/2021/12/10/20211110_/","excerpt":"","text":"###24. 两两交换链表中的节点给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ // 1 2 3 4 5 6 7 // 2 1 3 4 5 6 7 // 2 1 4 3 6 5 7class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head) return head; if(!head-&gt;next) return head; int cnt = 0; ListNode* pre = head; ListNode* cur = head-&gt;next; ListNode* ini = new ListNode(0); ListNode* temp = ini; temp-&gt;next = head; while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;next)&#123;//从头开始，只需要把第一个指到第二个的next，第二个指到第一个就行了，然后两个指针都向前两步， pre = temp-&gt;next; cur = temp-&gt;next-&gt;next; temp-&gt;next = cur; pre-&gt;next = cur-&gt;next; cur-&gt;next = pre; temp = pre; &#125; return ini-&gt;next; &#125;&#125;; ###剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：2 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: //1 //1 2 //1 2 +1 //1 2 // int fib(int n)&#123; // if(n == 0) return 1; // else if(n == 1) return 1; // else // return (fib(n-1) + fib(n-2))%1000000007; // &#125; // int numWays(int n) &#123;//跳3级台阶，等于1级和2级台阶的数量加起来 // if(n == 0) return 1; // if(n ==1) return 1; // return (fib(n))%1000000007; // &#125; int numWays(int n) &#123;//递归44就超时了，迭代1000000000也超时了 if (n &lt;= 1) &#123; return 1; &#125; int a = 1; int b = 2; for (int i = 2; i &lt; n; i++) &#123; int temp = (a + b); a = b; b = temp; b %= 1000000007; &#125; return b; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211209","date":"2021-12-08T16:00:00.000Z","updated":"2021-12-09T13:36:18.523Z","comments":true,"path":"2021/12/09/20211209/","link":"","permalink":"http://spcablast.club/2021/12/09/20211209/","excerpt":"","text":"###766. 托普利茨矩阵给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 12345678910111213141516171819class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size() == 1) return true; if(matrix[0].size() ==1 )return true; //if(matrix.size() == 2) return matrix[0][0] == matrix[1][1]; //用一行存第一行 //和下一行比 //更新第一行 for(int i = 1; i&lt;=matrix.size() -1; ++i)&#123; for(int j = 0; j&lt; matrix[0].size() -1; j++)&#123; if(!(matrix[i-1][j] == matrix[i][j+1]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; ###150. 逆波兰表达式求值根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [“2”,”1”,”+”,”3”,”*”]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: // int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; // //数字入栈，符号运算，弹出结果 // stack&lt;int&gt; stac; // for(int i =0;i&lt;tokens.size();++i)&#123; // string&amp; get = tokens[i]; // //判断数字还是符号 // if(get[0] -'+' != 0 &amp;&amp; get[0]-'-'!=0 &amp;&amp;get[0]-'*'!=0&amp;&amp;get[0]-'/'!=0)&#123; // stac.push(atoi(get[i].c_str())); // &#125; // else&#123; // int num1 = stac.top(); // stac.pop(); // int num2 = stac.top(); // stac.pop(); // switch(get[0])&#123; // case '+': // stac.push(num2 + num1); // break; // case '-': // stac.push(num2 - num1); // break; // case '*': // stac.push(num2 * num1); // break; // case '/': // stac.push(num2 / num1); // break; // &#125; // &#125; // &#125; // return stac.top(); // &#125; int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; stk; int n = tokens.size(); for (int i = 0; i &lt; n; i++) &#123; string&amp; token = tokens[i]; if (isNumber(token)) &#123; stk.push(atoi(token.c_str())); &#125; else &#123; int num2 = stk.top(); stk.pop(); int num1 = stk.top(); stk.pop(); switch (token[0]) &#123; case '+': stk.push(num1 + num2); break; case '-': stk.push(num1 - num2); break; case '*': stk.push(num1 * num2); break; case '/': stk.push(num1 / num2); break; &#125; &#125; &#125; return stk.top(); &#125; bool isNumber(string&amp; token) &#123; return !(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\"); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211208","date":"2021-12-07T16:00:00.000Z","updated":"2021-12-08T12:17:49.975Z","comments":true,"path":"2021/12/08/20211208/","link":"","permalink":"http://spcablast.club/2021/12/08/20211208/","excerpt":"","text":"###35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 123456789101112131415161718class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() -1, ans = nums.size(); while(left &lt;= right)&#123; if(target == nums[(left+right)/2] )&#123; return (left+right)/2; &#125; else if(target &lt; nums[(left+right)/2])&#123; ans = (left+right)/2; right = (left+right)/2-1; &#125; else if(target &gt; nums[(left+right)/2]) left = (left+right)/2+1; &#125; return ans; &#125;&#125;; ###1509. 三次操作后最大值与最小值的最小差给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。 请你返回三次操作后， nums 中最大值与最小值的差的最小值。 示例 1： 输入：nums = [5,3,2,4]输出：0解释：将数组 [5,3,2,4] 变成 [2,2,2,2].最大值与最小值的差为 2-2 = 0 。 123456789101112131415161718class Solution &#123;public: int minDifference(vector&lt;int&gt;&amp; nums) &#123; //找最大和第二大的， //找最小和第二小的， //最大的减，嘴小的加，看哪个合适 //结果就是，找最大的四个数，最小的四个数，一共能删除三个数，删除3个最大，第四大减去最小，删除2个最大，一个最小 if(nums.size() &lt;= 4)&#123; return 0; &#125; int ret = INT_MAX; sort(nums.begin(),nums.end()); for(int i = 0; i&lt;4; ++i)&#123; ret = min(ret, (nums[nums.size()-i -1] - nums[3-i])); &#125; return ret; &#125; &#125;; 今日吐槽：“时间”这个名词是时间的外显嘛，本没有时间，只有事物状态的变化，是嘛，将事物状态变化的速度来一个量化的单位，就是时间了。衡量单位出现的作用是什么呢？","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211207","date":"2021-12-06T16:00:00.000Z","updated":"2021-12-07T12:17:12.578Z","comments":true,"path":"2021/12/07/20211207/","link":"","permalink":"http://spcablast.club/2021/12/07/20211207/","excerpt":"","text":"###1844. 将所有数字用字符替换给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。 定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。 比方说，shift(‘a’, 5) = ‘f’ 和 shift(‘x’, 0) = ‘x’ 。对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。 请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 ‘z’ 。 1234567891011class Solution &#123;public: string replaceDigits(string s) &#123; for(int i = 0; i&lt; s.size();++i)&#123; if(i%2==1)&#123; s[i] = (s[i-1] - 'a' + (s[i] - '0'))%32 + 'a'; &#125; &#125; return s; &#125;&#125;; ###剑指 Offer II 026. 重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; //除了用一个指针指到末尾去，然后一边取一个存到新的里边 //奥，还可以从末尾拿一个过来，插到每一个的后边，直到取完，这样就省了新空间 //坏了，每次都得从头过去取吗，不从头过去取难道用一个空间存，、 //是不是可以截断成两个，然后倒插，怎么倒插呢 为了省时间还可以截断成log2 n个部分，存这么点节点，遍历的时间就省了 vector&lt;ListNode *&gt; list; while(head-&gt;next)&#123; list.push_back(head); head = head-&gt;next; &#125; list.push_back(head); int left = 0, right = list.size() - 1; while(left &lt; right)&#123; list[left]-&gt;next = list[right]; left++; if(left == right) break; list[right]-&gt;next = list[left]; right--; &#125; list[left]-&gt;next = nullptr; &#125;&#125;; 今日吐槽：刚刚坐在实验室突然感觉力气逐渐消失，还特别累，逐渐变困，感觉哪里不对，一想，原来是考完试回来忘了吃晚饭，大家注意吃饭","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211105","date":"2021-12-04T16:00:00.000Z","updated":"2021-12-05T12:08:35.984Z","comments":true,"path":"2021/12/05/20211105/","link":"","permalink":"http://spcablast.club/2021/12/05/20211105/","excerpt":"","text":"###139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。 示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 123456789101112131415161718192021class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; //判断首字母有几个匹配的，一个一个比较，没有一个相等就说明可以返回false了 auto wordDictSet = unordered_set &lt;string&gt; (); for (auto word: wordDict) &#123;//把字典里的都存起来 wordDictSet.insert(word); &#125; auto dp = vector &lt;bool&gt; (s.size() + 1);//每一位存0位到当前位是否是能拆 dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123;//如果从j开始，到i结束这段能在字典里找到，且到j这段也能拆，那么就说明到i这段能拆 if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; ###627. 变更性别SQL架构Salary 表： +————-+———-+| Column Name | Type |+————-+———-+| id | int || name | varchar || sex | ENUM || salary | int |+————-+———-+id 是这个表的主键。sex 这一列的值是 ENUM 类型，只能从 (‘m’, ‘f’) 中取。本表包含公司雇员的信息。 请你编写一个 SQL 查询来交换所有的 ‘f’ 和 ‘m’ （即，将所有 ‘f’ 变为 ‘m’ ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。 注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。 12345678// Write your MySQL query statement belowUPDATE salarySET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END;//还有数据库的题，神秘，这是什么操作，如果是m设置成f，否则设置成m","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"SQL - 算法题","slug":"SQL-算法题","permalink":"http://spcablast.club/tags/SQL-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211204","date":"2021-12-03T16:00:00.000Z","updated":"2021-12-04T01:31:29.021Z","comments":true,"path":"2021/12/04/20211204/","link":"","permalink":"http://spcablast.club/2021/12/04/20211204/","excerpt":"","text":"###121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //我只需要将当前值减去过去最小的，比一比，就行了 int cur = 0, min = INT_MAX, max = INT_MIN, index = 0; cur = prices[0]; for(int i = 0; i &lt; prices.size(); ++i)&#123; cur = prices[i]; if(min &gt; prices[i])&#123; min = prices[i]; &#125; if(max &lt; cur - min)&#123; max = cur - min; index = i; &#125; &#125; return max&gt;0?max:0; &#125;&#125;; ###413. 等差数列划分如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4]输出：3解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。示例 2： 输入：nums = [1]输出：0 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; //神秘，我需要判断出来当前是不是等差，如果是，在哪儿停止，下一个开始又计数 //一通操作算出来了有几个 if(nums.size()&lt;3)&#123; return 0; &#125; int pre = INT_MIN, ppre, cur,cnt = 0, t = 0; pre = nums[1] - nums[0]; cur = nums[2] - nums[1]; bool last = false; for(int i =2; i&lt; nums.size();++i)&#123; cur = nums[i] - nums[i-1]; if(pre != cur)&#123;//说明上一个和这一个不相等,不在一个等差数列 t = 0; last = false; &#125; else &#123; t++; last = true; &#125; if((!last) &amp;&amp; (pre == cur))&#123;//如果上一个pre不等于cur但是这一个pre等于cur，说明进入一个等差数列 //cnt++; &#125; pre = cur; cnt += t;//先找到有几个等差数列，再算每个等差数列里面有几个等差数列，好优化 &#125; return cnt; &#125;&#125;; 今日吐槽：早睡早起身体好，食堂的辣白菜可太好吃了，今天又是不想营业的一天，该干活了。动态规划，不对劲，这题不对劲","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211202","date":"2021-12-01T16:00:00.000Z","updated":"2021-12-02T11:53:11.813Z","comments":true,"path":"2021/12/02/20211202/","link":"","permalink":"http://spcablast.club/2021/12/02/20211202/","excerpt":"","text":"###152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 1234567891011121314151617181920212223class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; // //这题是不是跟昨天的一样 // int maxMul = INT_MIN, pre = 1, cur = 0; // for(int num : nums)&#123; // cur = pre*num; // maxMul = max(maxMul,cur); // if(cur = 0) pre = 1; // else pre = cur; // &#125; // return maxMul; //事实告诉我不是，因为还能-2*-2 = 4，小加小等于大 int maxF = nums[0], minF = nums[0], ans = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; int mx = maxF, mn = minF; maxF = max(mx * nums[i], max(nums[i], mn * nums[i])); minF = min(mn * nums[i], min(nums[i], mx * nums[i])); ans = max(maxF, ans); &#125; return ans; &#125;&#125;; ###278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 12345678910111213141516171819// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; long left = 1, right = n; while(left&lt;right)&#123; if(isBadVersion((left+right)/2))&#123; right = (left+right)/2; &#125; else&#123; left = (left+right)/2;//可以加一，因为这个位置已经判断过了 &#125; if(right==left+1) break; &#125; if(isBadVersion(left)) return left; return right; &#125;&#125;; 这波啊，这波是用空间换时间，直接来两个long int，不用跟他讲什么江湖道义，大家并肩子一起上，挺丑的，没有官方题解美观 今日吐槽：昨晚10点半就睡了，今天充满了power，虽然动态规划还是不太会，但是会写框架了呀，问题不大，在学了在学了还深度学习，学个der，令人头秃","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211201","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:23:56.226Z","comments":true,"path":"2021/12/01/20211201/","link":"","permalink":"http://spcablast.club/2021/12/01/20211201/","excerpt":"","text":"###53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2： 输入：nums = [1]输出：1示例 3： 输入：nums = [5,4,-1,7,8]输出：23 12345678910111213141516171819class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; //我知道了，把每一个位置的最大和存在一个数组里，遍历的时候把最大存在max里，最后返回 //优化一下就是把当前最大和上一个最大比较，大的更新，再下一步 //好像不对 //假如只有一个数，返回自身dp[0] = nums[1] //两个数，返回加来大还是本身大dp[1] = max(dp[0],num[1] + dp[0])，如果是dp[0]说明断了，且新来的这个数一定是负数，那么就得更新一下计数方式，下次计算从下一位开始 //三个数,if(更新)dp[2] = max(dp[1],num[2] + dp[1]) 或者 dp[2] = num[2] //也不对，用负数把数组分割一下，有道理，一个区域后边的负数比这个区域的正数负的少，就可以用 //变复杂了 int pre = 0, maxAns = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); maxAns = max(maxAns, pre); &#125; return maxAns; &#125;&#125;; 字典序排数给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]示例 2： 输入：n = 2输出：[1,2] 提示： 1 &lt;= n &lt;= 5 * 104 12345678910111213141516171819class Solution &#123;public: void dfs(int n, vector&lt;int&gt; &amp; ans, int num)&#123; if(num&gt;n) return; ans.push_back(num); for(int j = 0;j &lt;= 9;j++)&#123; dfs(n, ans, num*10+j); &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; //时间复杂度On，空间复杂度O1，啊这，字典序是什么序的 //1 10 11 ... 19 110 111...119 vector&lt;int&gt; ans; for(int i = 1; i&lt;10; i++)&#123; dfs(n, ans, i); &#125; return ans; &#125;&#125;; 今日吐槽：dfs，不会，动态规划还没学会呢，又给我dfs，但是dfs看起来没有动态规划难的亚子，爬，一递归就乱了，得整整递归","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"《黑羊》","slug":"黑羊-卡尔维诺","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:54:55.372Z","comments":true,"path":"2021/12/01/黑羊-卡尔维诺/","link":"","permalink":"http://spcablast.club/2021/12/01/%E9%BB%91%E7%BE%8A-%E5%8D%A1%E5%B0%94%E7%BB%B4%E8%AF%BA/","excerpt":"","text":"黑羊 卡尔维诺 从前有个国家，里面人人是贼。一到傍晚，他们手持万能钥匙和遮光灯笼出门，走到邻居家里行窃。破晓时分，他们提着偷来的东西回到家里，总能发现自己家也失窃了。 他们就这样幸福地居住在一起。没有不幸的人，因为每个人都从别人那里偷东西，别人又再从别人那里偷，依次下去，直到最后一个人去第一个窃贼家行窃。该国贸易也就不可避免地是买方和卖方的双向欺骗。政府是个向臣民行窃的犯罪机构，而臣民也仅对欺骗政府感兴趣。所以日子倒也平稳，没有富人和穷人。 有一天－－到底是怎么回事没人知道－－总之是有个诚实人到了该地定居。到晚上，他没有携袋提灯地出门，却呆在家里抽烟读小说。贼来了，见灯亮着，就没进去。 这样持续了有一段时间。后来他们感到有必要向他挑明一下，纵使他想什么都不做地过日子，可他没理由妨碍别人做事。他天天晚上呆在家里，这就意味着有一户人家第二天没了口粮。 诚实人感到他无力反抗这样的逻辑。从此他也像他们一样，晚上出门，次日早晨回家，但他不行窃。他是诚实的。对此，你是无能为力的。他走到远处的桥上，看河水打桥下流过。每次回家，他都会发现家里失窃了。 不到一星期，诚实人就发现自己已经一文不名了；他家徒四壁，没任何东西可吃。但这不能算不了什么，因为那是他自己的错；不，问题是他的行为使其他人很不安。因为他让别人偷走了他的一切却不从别人那儿偷任何东西；这样总有人在黎明回家时，发现家里没被动过－－那本该是由诚实人进去行窃的。不久以后，那些没有被偷过的人家发现他们比人家就富了，就不想再行窃了。更糟的是，那些跑到诚实人家里去行窃的人，总发现里面空空如也，因此他们就变穷了。 同时，富起来的那些人和诚实人一样，养成了晚上去桥上的习惯，他们也看河水打桥下流过。这样，事态就更混乱了，因为这意味着更多的人在变富，也有更多的人在变穷。 现在，那些富人发现，如果他们天天去桥上，他们很快也会变穷的。他们就想：“我们雇那些穷的去替我们行窃吧。”他们签下合同，敲定了工资和如何分成。自然，他们依然是贼，依然互相欺骗。但形势表明，富人是越来越富，穷人是越来越穷。 有些人富裕得已经根本无须亲自行窃或雇人行窃就可保持富有。但一旦他们停止行窃的话，他们就会变穷，因为穷人会偷他们。因此他们又雇了穷人中的最穷者来帮助他们看守财富，以免遭穷人行窃，这就意味着要建立警察局和监狱。 因此，在那诚实人出现后没几年，人们就不再谈什么偷盗或被偷盗了，而只说穷人和富人；但他们个个都还是贼。唯一诚实的只有开头的那个人，但他不久便死了，饿死的。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"http://spcablast.club/tags/%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4/"}],"author":"YP"},{"title":"Dailycode","slug":"20211130","date":"2021-11-29T16:00:00.000Z","updated":"2021-11-30T13:34:56.239Z","comments":true,"path":"2021/11/30/20211130/","link":"","permalink":"http://spcablast.club/2021/11/30/20211130/","excerpt":"","text":"删除并获得点数给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2]输出：6解释：删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int rob(vector&lt;int&gt; nums)&#123; int n = nums.size(); int first = nums[0], secend = max(first, nums[1]); for(int i = 2; i &lt; n; i++ )&#123; int temp = secend; secend = max(first + nums[i], secend); first = temp; &#125; return secend; &#125;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; //找最大，是最大大，还是最大减一 //一个返回自己 //两个返回最大，除非比他小一的乘起来比他大 //那这样就可以开一个哈希表，数字乘以出现次数，是这个数的值，a + c and b //取每个数，来个最大值 //假如取了第一个数，那么当前最大值存一下 //取第二个数，当前最大值存一下，是等于dp[0] + dp[1]还是dp[1]判断一下 //取第三个数，dp[0] + if dp[1] + dp[2] //取第四个数，dp[1] + if dp[2] + dp[3] //好，写 //先排序，再哈希，再dp if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int n = nums.size(), maxNum = 0; for(int i = 0;i &lt; n;++i)&#123; if(nums[i] &gt; maxNum)&#123; maxNum = nums[i]; &#125; &#125; vector&lt;int&gt; numNew(maxNum + 1); for(int num : nums)&#123; numNew[num] += num; &#125; return rob(numNew); &#125;&#125;; 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 示例 1： 输入：s = “()”输出：true 123456789101112131415161718192021222324class Solution &#123;public: bool isValid(string s) &#123; if(s.size() % 2 == 1) return false; //不成对，false stack&lt;char&gt; st; unordered_map&lt;char, char&gt; pairs = &#123; &#123;')','('&#125;, &#123;']','['&#125;, &#123;'&#125;','&#123;'&#125; &#125;; for(char ch : s)&#123; if(pairs.count(ch))&#123; if(st.empty() || st.top() != pairs[ch])&#123;//读到一个右括号，看是不是空，栈顶是不是对应的左括号 return false; &#125; st.pop();//没问题退栈 &#125; else&#123; st.push(ch);//否则压栈 &#125; &#125; return st.empty(); &#125;&#125;; 今日吐槽：歇了一天今天不困了，但是还需要中午补一点，该补一补了 感觉","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211129","date":"2021-11-28T16:00:00.000Z","updated":"2021-11-29T12:32:36.335Z","comments":true,"path":"2021/11/29/20211129/","link":"","permalink":"http://spcablast.club/2021/11/29/20211129/","excerpt":"","text":"剑指 Offer 62. 圆圈中最后剩下的数字0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3输出: 3示例 2： 输入: n = 10, m = 17输出: 2 12345678910111213class Solution &#123;public: int lastRemaining(int n, int m) &#123; //0 1 2 3 4 5 6 7 8 9 //每次往前计数，计到m，cnt--,再数m个，直到cnt==1，评论说这个方法超时了，呵，肤浅，超时，那就不用呗 //f，当前位置，m，每次向前移动位置，i是递归的初始状态 int f = 0; for (int i = 2; i != n + 1; ++i) &#123; f = (m + f) % i; &#125; return f; &#125;&#125;; 跳跃游戏 VII给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处： i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且s[j] == ‘0’.如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。 示例 1： 输入：s = “011010”, minJump = 2, maxJump = 3输出：true解释：第一步，从下标 0 移动到下标 3 。第二步，从下标 3 移动到下标 5 。 1234567891011121314151617181920212223242526class Solution &#123;public: bool canReach(string s, int minJump, int maxJump) &#123; //问题就在于 //每次前进minJump到maxJump距离，在其中找到几个下标为0的位置， //是否可以作为动态规划来解决，从终点往前，数i到j个格子，查里面有没有0，有就存起来 //问题在于我老想着优化的方法，只判断某些点可达不可达，而动态规划每个点都算了可达不可达存起来了 //每次走i步，和每次走j步，有一个区间，如果这个区间有0，说明能到对应的i int n = s.size(); vector&lt;int&gt; f(n), pre(n); f[0] = 1; // 由于我们从 i=minJump 开始动态规划，因此需要将 [0,minJump) 这部分的前缀和预处理出来 for (int i = 0; i &lt; minJump; ++i) &#123; pre[i] = 1; &#125; for (int i = minJump; i &lt; n; ++i) &#123; int left = i - maxJump, right = i - minJump; if (s[i] == '0') &#123; int total = pre[right] - (left &lt;= 0 ? 0 : pre[left - 1]); f[i] = (total != 0); &#125; pre[i] = pre[i - 1] + f[i]; &#125; return f[n - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211128","date":"2021-11-27T16:00:00.000Z","updated":"2021-11-28T14:17:17.108Z","comments":true,"path":"2021/11/28/20211128/","link":"","permalink":"http://spcablast.club/2021/11/28/20211128/","excerpt":"","text":"打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2： 输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// class Solution &#123;// public:// int rob(vector&lt;int&gt;&amp; nums) &#123;// //我应该从哪儿开始偷啊啊，gan// //真就能随便从一个位置开始吗// if(nums.size() == 0) return 0;// if(nums.size() == 1) return nums[0];// if(nums.size() == 2) return max(nums[0],nums[1]);// int ans0 = 0, ans1 = 0;// vector&lt;int&gt; dp[nums.size() + 1],dp2[nums.size() + 1];// //dp[i] = max(dp[i-2] + nums[i], dp[i-1] )// //分两种情况，从0开始和从1开始// dp[0] = nums[0], dp[1] = max(nums[0],nums[1]);// dp2[0] = nums[1], dp2[1] = max(nums[1],nums[2]);// for(int i = 2; i&lt;nums.size() -1; ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// for(int i = 3; i&lt;nums.size(); ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// return max(dp[nums.size()],dp2[nums.size()]);// &#125;// &#125;;class Solution &#123;public: int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int first = nums[start], second = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) &#123; int temp = second; second = max(first + nums[i], second); first = temp; &#125; return second; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 1) &#123; return nums[0]; &#125; else if (length == 2) &#123; return max(nums[0], nums[1]); &#125; return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); &#125;&#125;; 构造矩形作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 你设计的矩形页面必须等于给定的目标面积。 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。 长度 L 和宽度 W 之间的差距应当尽可能小。你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 输入: 4输出: [2, 2]解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 123456789101112class Solution &#123;public: vector&lt;int&gt; constructRectangle(int area) &#123; int w = 0,h = 0; w= sqrt(area); h = w; while(area % w)&#123; w--; &#125; return &#123;area / w, w&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211127","date":"2021-11-26T16:00:00.000Z","updated":"2021-11-27T15:35:32.455Z","comments":true,"path":"2021/11/27/20211127/","link":"","permalink":"http://spcablast.club/2021/11/27/20211127/","excerpt":"","text":"最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public:int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid)&#123; //好，我现在看什么都想动态规划，gan //假设我在最后一个格子了，那么比较到达左边需要的总数小还是上边的总数小 //感觉就像穷举，没错，就是了 if (!grid.size()) return 0; if (!grid[0].size()) return 0; int col = grid.size(), row = grid[0].size(); vector&lt;int&gt; dp(col * row); dp[0] = grid[0][0]; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; if (i * col + j != 0) &#123; //跳过0，0 if (i == 0) &#123; //第0列 if(j&gt;0) dp[i * row + j] = grid[0][j] + dp[i * row + j -1]; &#125; else if (j == 0) &#123; //第0列 dp[i * row + j] = grid[i][0] + dp[(i-1)*row]; &#125; else &#123; dp[i * row + j] = min(dp[(i - 1) * row + j] + grid[i][j], dp[i * row + j - 1] + grid[i][j]); &#125; &#125; &#125; &#125; return dp[col * row - 1]; &#125; ###7. 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; if(x == 0) return 0; int ans = 0,temp = 0; while(x!=0)&#123; temp = x%10; if( ans &lt;= INT_MAX/10 &amp;&amp; ans &gt;= INT_MIN/10) ans = ans*10 + temp; else return 0; x/=10; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211126","date":"2021-11-25T16:00:00.000Z","updated":"2021-11-26T13:56:01.063Z","comments":true,"path":"2021/11/26/20211126/","link":"","permalink":"http://spcablast.club/2021/11/26/20211126/","excerpt":"","text":"###746. 使用最小花费爬楼梯数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2： 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //用动态规划的思想来分析 //首先，如果只有一个台阶，那我就用这个， //如果有两个台阶，选小的那个 //如果有三个台阶，是否到达第三个台阶，判断从2跳过3大还是1到3大 //默认我已经站在某个台阶了，我只要判断是跳一步还是跳两步 // if(cost.size() == 0) return 0; // if(cost.size() == 1) return cost[0]; // int i = 1, r = 0, g = cost[0], b = cost[1], ans = 0, step = -1;//r是-1，g是中间， // while(i &lt; cost.size())&#123; // if(ans + cost[i-1] &gt; ans + cost[i])&#123;//0+cost[0] &gt; 0+cost[1] // i += 2; // ans += cost[i]; // &#125; // else // &#123; // i++; // ans += cost[i-1]; // &#125; // &#125; // return ans; //那我又倒了，再来一遍 int n = cost.size(); vector&lt;int&gt; dp(n + 1);//多了前置一位和后置一位 dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt; n+1;i++)&#123; dp[i] = min(cost[i-1] + dp[i-1], cost[i-2] + dp[i-2]); &#125; return dp[n]; &#125;&#125;; ###722. 删除注释给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 这表示每行源码由\\n分隔。 在 C++ 中有两种注释风格，行内注释和块注释。 字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。 字符串/* 表示一个块注释，它表示直到/的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串//并没有结束块注释，因为注释的结尾与开头相重叠。 第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。 同样，如果字符串/*出现在行或块注释中也会被忽略。 如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。 样例中没有控制字符，单引号或双引号字符。比如，source = “string s = “/* Not a comment. */“;” 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。） 我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。 最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。 从源代码中删除注释后，需要以相同的格式返回源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Solution &#123;public: // vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; // vector&lt;string&gt; ans, empty; // bool del = false; // string current = \"\"; // for(int i = 0; i&lt; source.size();i++)&#123; // //先判断有没有// // if(source[i].size()&gt;=2)&#123;//获得一个 // char former = source[i][0], cur = source[i][1]; // current.push_back(former);//先压一个 // for(int j = 1;j&lt;source[i].size();++j)&#123; // cur = source[i][j]; // former = source[i][j-1]; // if(former == '/'&amp;&amp;cur == '*')&#123;//标志位置1,后边不要 // current.pop_back();//吐出/ // del = true; // &#125; // else if(former == '*' &amp;&amp; cur == '/')&#123;//标志位置0，开始要 // current.pop_back();//吐出/ // del = false; // j++; // &#125; // else if(former == '/' &amp;&amp; cur =='/')&#123;//后边都不要 // break; // &#125; // else &#123; // current.push_back(cur); // if(del)&#123; // current.pop_back(); // &#125; // &#125; // //如果到头了，没有*/那就continue // //if((j == source[i].size()) &amp;&amp; del)&#123; // // continue; // //&#125; // &#125; // if(current.size() &amp;&amp; !del)&#123;//这行正常，或者这行string+ // ，或这行有*/ // ans.push_back(current);//这一行完了， // string().swap(current); // &#125; // &#125; // else&#123; // ans.push_back(source[i]); // //string().swap(current); // &#125; // &#125; // return ans; // &#125; vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; bool isComment = false; vector&lt;string&gt; res; string curr = \"\"; for (string s : source) &#123; // cout &lt;&lt; s &lt;&lt; endl; int i = 0; if (!isComment) &#123; curr = \"\"; &#125; int n = s.size(); while (i &lt; n) &#123; if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '*') &#123; isComment = true; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '*' &amp;&amp; s[i+1] == '/') &#123; isComment = false; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '/') &#123; break; &#125; else if (!isComment) &#123; curr += s[i]; // cout &lt;&lt; curr&lt;&lt; \" \" &lt;&lt; endl; &#125; ++i; &#125; if (!isComment &amp;&amp; !curr.empty()) &#123; res.push_back(curr); &#125; &#125; return res; &#125;&#125;; 吐槽：！他思路和我一样，代码也和我一样，我就过不去，啊我好菜啊","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211125","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-27T01:27:14.223Z","comments":true,"path":"2021/11/25/20211125/","link":"","permalink":"http://spcablast.club/2021/11/25/20211125/","excerpt":"","text":"###509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1给你 n ，请计算 F(n) 。 12345678910111213141516171819202122232425262728293031class Solution &#123;public://今日吐槽：因为是中午，所以有力气吐槽//人是有限的，精神呀，还是体力呀，精神又包括注意力，记忆力，操控自己做哪件事不做哪件事也需要消耗精神力，体力，只要没睡觉，都在消耗体力//那么既然人是有限的，而一天要完成的活动是有量的，假使这个人的能量恰好或者很难完成所有的活动//这样很容易就能得到一个结论，//先在精神力和体力都充足的时候把一定要完成的事情做完了，在能量消耗过多的时候通过特定的行为恢复一部分能量，比如睡了，吃点//如果还是不能完成所有的活动，那么就一定会放弃一些事情，或者粗略的完成一些事情，否则就到第二天了//以及，我以为的只是我现在以为的 int fib(int n) &#123;//怎么用动态规划的思想做这道题嘞//因为斐波那契数列第三个后，每一个数都是由前两个加起来的到的，所以存在递推关系//关键词：// 边界条件：F(0) = 0, F(1) = 1;这是这个问题的起始点，所有的数都由这两个开始// F(n) = F(n-1) + F(n-2)直到 n == 2// 现在是22点13分，继续// 根据以上的推论，递推公式有了，边界条件有了，就可以写代码了，好了 int i = 2; if(n &lt; 2) return n; //用三个变量存所需的所有变量 long long p = 0, q = 1, r = 2; while(i&lt;=n)&#123; r = p + q; p = q; q = r; i++; &#125; return r; //好了，哪里用了动态规划的思想呢，r = p + q, &#125;&#125;; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int ans = 0; bool arrive(int step)&#123; if(step &lt; 0 ) return false; if(step == 0) &#123; ans += 1; return true; &#125; else if(arrive(step - 1) &amp;&amp; arrive(step - 2)); return true; &#125; int climbStairs(int n) &#123; //我天下无敌了，好了，大概吧 //走一步，或两步一次，到顶 //那就可以从顶开始减，减一或者减二，直到为0. //那边界条件就是n = 0 //每次执行的操作是减一或者减二，可以来个递归，最后n &lt; 0 返回无法到达，n == 0返回可以到达 //int ans = 0; //arrive(n); //return ans; //那我还是太菜了呀，每次从顶上下来是减一或者减二，说明dp[i] = dp[i-1] + dp[i-2],我站在这个台阶，从前一个台阶上来一种，或者是从前2个台阶上来的第二种，有两个状态可以到达我这个状态，每一个状态都有两个状态可以转移过来，就得到了递推公式，那我上面的递归也没问题吧，为什么超时了呢 int p = 0, q = 0, r = 1; for (int i = 1; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r; &#125;&#125;; 今日吐槽：又是无力吐槽的一天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211124","date":"2021-11-23T16:00:00.000Z","updated":"2021-12-27T12:22:23.893Z","comments":true,"path":"2021/11/24/20211124/","link":"","permalink":"http://spcablast.club/2021/11/24/20211124/","excerpt":"","text":"祖父节点值为偶数的节点和给你一棵二叉树，请你返回满足以下条件的所有节点的值之和： 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）如果不存在祖父节点值为偶数的节点，那么返回 0 。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;//笑死，祖父节点，难道要判断一个节点有几个孙子节点，那就可以直接深度嘛，我只要遍历到倒数第二层就完事儿了//o，要孙子节点的值加起来啊，我还以为是加爷爷节点的值int ans = 0;public: void dfs(int gp_val, int p_val, TreeNode* node) &#123; if (!node) &#123; return; &#125; if (gp_val % 2 == 0) &#123; ans += node-&gt;val; &#125; dfs(p_val, node-&gt;val, node-&gt;left); dfs(p_val, node-&gt;val, node-&gt;right); &#125; int sumEvenGrandparent(TreeNode* root) &#123; dfs(1, 1, root); return ans; &#125;&#125;; 二进制表示中质数个计算置位给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 12345678910111213class Solution &#123;public: int countPrimeSetBits(int left, int right) &#123; int a[20] = &#123;0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1&#125;; int res = 0; for (int i = left; i &lt;= right; ++i) &#123; res += a[__builtin_popcount(i)];//还有算整数转二进制数的1的个数的函数，怪了 &#125; return res; &#125;&#125;;//[作者](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/cchao-100de-jian-dan-jie-fa-by-ffreturn-pj11/)","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作 - 算法题","slug":"vector操作-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211123","date":"2021-11-22T16:00:00.000Z","updated":"2021-12-27T12:22:31.988Z","comments":true,"path":"2021/11/23/20211123/","link":"","permalink":"http://spcablast.club/2021/11/23/20211123/","excerpt":"","text":"###1389. 按既定顺序创建目标数组给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。重复上一步，直到在 nums 和 index 中都没有要读取的元素。请你返回目标数组。 题目保证数字插入位置总是存在。 1234567891011class Solution &#123;public: vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) &#123; //这题目可太绕了，在新数组index[i]的值的序号处，插入nums[i] vector &lt;int&gt; r; for (unsigned i = 0; i &lt; nums.size(); ++i) &#123; r.insert(r.begin() + index[i], nums[i]); &#125; return r; &#125;&#125;; ###面试题 05.02. 二进制数转字符串二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 示例1: 输入：0.625 输出：”0.101”示例2: 输入：0.1 输出：”ERROR” 提示：0.1无法被二进制准确表示提示： 32位包括输出中的”0.”这两位。 12345678910111213141516171819class Solution &#123;public: string printBin(double num) &#123; //从2的-1次方开始减，减到2的-32次方，如果中间都大于这个2的多少次放，说明那一次能减，如果有一次减到了0，说明能表示，如果不能，error //那这样就可以从2的-1次方加，能加就加，给个1，不能加给个0，加到2的-32次方，0.1010001 string ans = \"0.\"; while(num != 0)&#123;//怪了，double怎么能判断!=0的 num*=2; if(num&gt;=1)&#123; ans += \"1\"; num -= 1; &#125; else ans+=\"0\"; if(ans.size()&gt;32) return \"ERROR\"; &#125; return ans; &#125;&#125;; 正经吐槽：怎么还能拿double和0 == 的，这合适吗，这一点都不合适，不应该double - 0 &gt; 1.79E+308嘛 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211122","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-28T14:20:24.993Z","comments":true,"path":"2021/11/22/20211122/","link":"","permalink":"http://spcablast.club/2021/11/22/20211122/","excerpt":"","text":"384打乱数组给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果 题（吐）解（槽）：这又是数学题，排列组合和概率问题，实现每一位出现其中的数字的概率都相同，可以这样做，也可以每一位随机一个数，再在整体里删了用过的数 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; m_nums; vector&lt;int&gt; origin; Solution(vector&lt;int&gt;&amp; nums) &#123; //copy(m_nums.begin(),nums.begin(),nums.end()); m_nums = nums; origin = nums; &#125; vector&lt;int&gt; reset() &#123; return origin; &#125; vector&lt;int&gt; shuffle() &#123; int temp = 0, index = 0, len = m_nums.size(); for(int i = 0; i &lt; len; i++)&#123; temp = m_nums[i]; index = i + rand() % (len - i); m_nums[i] = m_nums[index]; m_nums[index] = temp; &#125; return m_nums; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */ ###剑指 Offer 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]示例 2： 输入：arr = [0,1,2,1], k = 1输出：[0] 123456789101112class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; sort(arr.begin(),arr.end()); //if(arr.size() == 0) return null; vector&lt;int&gt; ans; for(int i = 0;i &lt; k; i++)&#123; ans.push_back(arr[i]); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211121","date":"2021-11-20T16:00:00.000Z","updated":"2021-11-21T14:56:01.423Z","comments":true,"path":"2021/11/21/20211121/","link":"","permalink":"http://spcablast.club/2021/11/21/20211121/","excerpt":"","text":"###8. 字符串转换整数 (atoi)请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: //我又倒了，我应该学一下怎么写自动机的，或者是正则表达式 //int myAtoi(string s) &#123; //丢空格 //起始是正负号，或者没有 //有数字转数字，没数字返回0 //大于INT_MAX返回INT_MAX小于INT_MIN返回INT_MIN //为什么我用VS和这里结果不一样 // if(s.size() == 0) return 0; // long flag = 1 ,temp = 0, ans = 0; // for(int i =0; i &lt; s.size(); ++i)&#123; // //先都当负数，有正负号存到flag里 // if(s[i] == ' ')&#123; // &#125; // else&#123; // if(s[i] == '+')&#123; // flag = 1; // &#125; // else if(s[i] == '-')&#123; // flag = 0; // &#125; // else if((s[i] - '0')&gt;=0 &amp;&amp; (s[i] - '0')&lt;=9)&#123; // temp = s[i] - '0'; // ans = ans*10 - temp; // &#125; // else // break; // &#125; // &#125; // ans = flag?-ans:ans; // if(ans &gt; INT_MAX) return INT_MAX; // if(ans &lt; INT_MIN) return INT_MIN; // return ans; // &#125; //考虑到各种情况的题解 //这题目不仅要取出数字，还得判断是不是一个正常意义的数字 int myAtoi(string str) &#123; unsigned long len = str.length(); // 去除前导空格 int index = 0; while (index &lt; len) &#123; if (str[index] != ' ') &#123; break; &#125; index++; &#125; if (index == len) &#123; return 0; &#125; int sign = 1; // 处理第 1 个非空字符为正负符号，这两个判断需要写在一起 if (str[index] == '+') &#123; index++; &#125; else if (str[index] == '-') &#123; sign = -1; index++; &#125; // 根据题目限制，只能使用 int 类型 int res = 0; while (index &lt; len) &#123; char curChar = str[index]; if (curChar &lt; '0' || curChar &gt; '9') &#123; break; &#125; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; (curChar - '0') &gt; INT_MAX % 10)) &#123; return INT_MAX; &#125; if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; (curChar - '0') &gt; -(INT_MIN % 10))) &#123; return INT_MIN; &#125; res = res * 10 + sign * (curChar - '0'); index++; &#125; return res; &#125;&#125;; ###908. 最小差值 I给你一个整数数组 nums，请你给数组中的每个元素 nums[i] 都加上一个任意数字 x （-k &lt;= x &lt;= k），从而得到一个新数组 result 。 返回数组 result 的最大值和最小值之间可能存在的最小差值。 示例 1： 输入：nums = [1], k = 0输出：0解释：result = [1]示例 2： 输入：nums = [0,10], k = 2输出：6解释：result = [2,8]示例 3： 输入：nums = [1,3,6], k = 3输出：0解释：result = [3,3,3] or result = [4,4,4] 提示： 1 &lt;= nums.length &lt;= 100000 &lt;= nums[i] &lt;= 100000 &lt;= k &lt;= 10000 123456789101112class Solution &#123;public: int smallestRangeI(vector&lt;int&gt;&amp; nums, int k) &#123; int min = INT_MAX,max = INT_MIN; for(int num :nums)&#123; if(num &lt; min) min = num; if(num &gt; max) max = num; &#125; int ans = max - min - 2*k; return ans&gt;=0?ans:0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211120","date":"2021-11-19T16:00:00.000Z","updated":"2021-11-20T13:50:15.758Z","comments":true,"path":"2021/11/20/20211120/","link":"","permalink":"http://spcablast.club/2021/11/20/20211120/","excerpt":"","text":"###剑指 Offer 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 12345678910111213141516class Solution &#123;public: int fib(int n) &#123; int i &#x3D; 0, j &#x3D; 1, temp, ans; if(n &#x3D;&#x3D; 0) return 0; if(n &#x3D;&#x3D; 1) return 1; for(int k &#x3D; 1; k&lt;n;k++)&#123; ans &#x3D; i + j; temp &#x3D; k; i &#x3D; j; j &#x3D; ans % (1000000007); &#125; ans &#x3D; ans % (1000000007); return ans; &#125;&#125;; ###29. 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3题（吐）解（槽）：这题也太离谱了，我提交了16次，边界情况这么多,以及我写的方法又死了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: int divide(int dividend, int divisor) &#123; &#x2F;&#x2F;被除数为最小值，除数分别为1和-1 if (dividend &#x3D;&#x3D; INT_MIN) &#123; if (divisor &#x3D;&#x3D; 1) &#123; return INT_MIN; &#125; if (divisor &#x3D;&#x3D; -1) &#123; return INT_MAX; &#125; &#125; if(divisor &#x3D;&#x3D; INT_MIN)&#123; if(dividend &#x3D;&#x3D; INT_MIN)&#123; return 1; &#125; return 0; &#125; if(divisor &#x3D;&#x3D; 0 ) return 0; &#x2F;&#x2F;一定要转成负的，因为如果被除数是INT_MIN不好表示 bool flag &#x3D; false; int m_dividend &#x3D; 0, m_divisor &#x3D; 0, ans &#x3D; 0; if(dividend &gt; 0)&#123; m_dividend &#x3D; -dividend; flag &#x3D; !flag; &#125; else m_dividend &#x3D; dividend; if(divisor &gt; 0)&#123; m_divisor &#x3D; -divisor; flag &#x3D; !flag; &#125; else m_divisor &#x3D; divisor; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 vector&lt;int&gt; listDividend &#x3D; &#123;m_divisor&#125;; while(m_dividend - m_divisor &lt;&#x3D; m_divisor)&#123; m_divisor +&#x3D; m_divisor; listDividend.push_back(m_divisor); &#125; for(int i &#x3D; listDividend.size() -1; i&gt;&#x3D;0 ; i--)&#123; if(listDividend[i] &gt;&#x3D; m_dividend)&#123; ans +&#x3D; 1 &lt;&lt; i; m_dividend -&#x3D; listDividend[i]; &#125; &#125; return flag?-ans:ans; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; -1)return -dividend; &#x2F;&#x2F; int ans &#x3D; 0, temp &#x3D; abs(divisor), totle &#x3D; 0, m_dividend &#x3D; abs(dividend); &#x2F;&#x2F; while(m_dividend -totle &gt;&#x3D; temp)&#123; &#x2F;&#x2F; totle +&#x3D; temp; &#x2F;&#x2F; ans++; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if((dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0)) &#x2F;&#x2F; return ans; &#x2F;&#x2F; else &#x2F;&#x2F; return -(ans); &#x2F;&#x2F; long m_dividend &#x3D; abs(dividend), m_divisor &#x3D; abs(divisor); &#x2F;&#x2F; if(divisor &#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D; -1)return -dividend; &#x2F;&#x2F; int temp &#x3D; divisor, itera &#x3D; 1; &#x2F;&#x2F; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F; &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 &#x2F;&#x2F; while(m_divisor &lt; m_dividend)&#123; &#x2F;&#x2F; temp &#x3D; m_divisor; &#x2F;&#x2F; itera++; &#x2F;&#x2F; m_divisor +&#x3D; m_divisor; &#x2F;&#x2F; &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211119","date":"2021-11-18T16:00:00.000Z","updated":"2021-11-20T01:02:59.852Z","comments":true,"path":"2021/11/19/20211119/","link":"","permalink":"http://spcablast.club/2021/11/19/20211119/","excerpt":"","text":"50. Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。 示例 1： 输入：x = 2.00000, n = 10输出：1024.00000示例 2： 输入：x = 2.10000, n = 3输出：9.26100示例 3： 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: double powe(long itera, double x)&#123; double ans &#x3D; 1, temp &#x3D; x; while(itera &gt; 0)&#123; if(itera%2 &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;ans &#x3D; x*temp; ans *&#x3D; temp; &#125; temp &#x3D; temp*temp; itera &gt;&gt;&#x3D; 1; &#125; return ans; &#125; double myPow(double x, int n) &#123; &#x2F;&#x2F;暴力方法超时了 &#x2F;&#x2F; double ans &#x3D; 1.00000; &#x2F;&#x2F; long nplus &#x3D; n; &#x2F;&#x2F; if(nplus &#x3D;&#x3D; 0) return 1; &#x2F;&#x2F; if(abs(abs(x) - ans) &lt;&#x3D; 0.000001) return x; &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; abs(nplus); i++)&#123; &#x2F;&#x2F; ans &#x3D; ans*x; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(nplus&lt;0)&#123; &#x2F;&#x2F; ans &#x3D; 1&#x2F;ans; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return ans; if(n &#x3D;&#x3D; 0) return 1.00000; if(abs(x - 1.00000) &lt; 2.22045e-16) return 1.000; long itera &#x3D; n; double ans; ans &#x3D; powe(abs(itera), x); return itera&gt;0?ans:1&#x2F;ans; &#125; &#125;; 598. 范围求和 II 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 输入:m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释:初始状态, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] 1234567891011class Solution &#123;public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) &#123; int mina &#x3D; m;int minb &#x3D; n; for(int i&#x3D;0;i&lt;ops.size();i++)&#123; mina &#x3D; mina&gt;ops[i][0]?ops[i][0]:mina; minb &#x3D; minb&gt;ops[i][1]?ops[i][1]:minb; &#125; return mina*minb; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211118","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:55:18.810Z","comments":true,"path":"2021/11/18/20211118/","link":"","permalink":"http://spcablast.club/2021/11/18/20211118/","excerpt":"","text":"###48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 题（吐）解（槽）：今天无力吐槽，干活 123456789101112131415161718192021class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#x2F;&#x2F;外圈到内圈轮流换位置 &#x2F;&#x2F;圈数等于n&#x2F;2 &#x2F;&#x2F;1 1 &#x2F;&#x2F; &#x2F;&#x2F;3 4 &#x2F;&#x2F;转起来（0+1，0）（0+1，n-1）(n-1,n-1-1)(0,n-1-1) int n &#x3D; matrix.size(); for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123; for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; ++j) &#123; int temp &#x3D; matrix[i][j]; matrix[i][j] &#x3D; matrix[n - j - 1][i]; matrix[n - j - 1][i] &#x3D; matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] &#x3D; matrix[j][n - i - 1]; matrix[j][n - i - 1] &#x3D; temp; &#125; &#125; &#125;&#125;; ###771. 宝石与石头 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 字母区分大小写，因此 “a” 和 “A” 是不同类型的石头。 示例 1： 输入：jewels = “aA”, stones = “aAAbbbb”输出：3示例 2： 输入：jewels = “z”, stones = “ZZ”输出：0 123456789101112131415class Solution &#123;public: int numJewelsInStones(string jewels, string stones) &#123; int ans &#x3D; 0; for(int i &#x3D; 0;i&lt;jewels.size();i++)&#123; int cur &#x3D; jewels[i] - &#39;0&#39;; for(int j &#x3D; 0; j&lt;stones.size();j++)&#123; if(stones[j] - &#39;0&#39; &#x3D;&#x3D; cur)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"ffmpeg操作","slug":"ffmpeg操作","date":"2021-11-17T16:00:00.000Z","updated":"2023-09-01T07:53:01.244Z","comments":true,"path":"2021/11/18/ffmpeg操作/","link":"","permalink":"http://spcablast.club/2021/11/18/ffmpeg%E6%93%8D%E4%BD%9C/","excerpt":"","text":"ffmpeg.exe -i aa.mp4 -y -f image2 -ss 8 -t 0.01 -s 800x600 test.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpgffmpeg -i test.mp4 -r 30 -t 4 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 -vframes 10 image-%3d.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpg -i file name-r frame/s-f ..F… set commands file-ss time_off set the start time offset-t duration record or transcode “duration” seconds of audio/video ffmpeg -i input.mp4 -vf crop=640:480:495:270 output.mp4 -y crop:w,h,x,y x,y,左上角起始点，横，纵","categories":[{"name":"工具","slug":"工具","permalink":"http://spcablast.club/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"-ffmpeg命令行操作","slug":"ffmpeg命令行操作","permalink":"http://spcablast.club/tags/ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"}],"author":"YP"},{"title":"VSCode","slug":"VScode的配置","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-20T00:47:46.999Z","comments":true,"path":"2021/11/18/VScode的配置/","link":"","permalink":"http://spcablast.club/2021/11/18/VScode%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"最近要 机器 学习了，down个VSCode用用 pip install flake8装了个flake8,获得了语法提示 pip install yapf装个yapf，Alt+Shift+F可以自动化格式代码 setting.json设置一下 123456&#123; \"workbench.colorTheme\": \"Default Dark+\", \"python.defaultInterpreterPath\": \"C:\\\\Program Files\\\\Python39\\\\python.exe\", \"python.linting.flake8Enabled\": true, \"python.formatting.provider\": \"yapf\"&#125;","categories":[{"name":"VSCode","slug":"VSCode","permalink":"http://spcablast.club/categories/VSCode/"}],"tags":[],"author":"YP"},{"title":"论意欲的自由","slug":"论道德和自由","date":"2021-11-17T16:00:00.000Z","updated":"2021-12-01T12:55:59.506Z","comments":true,"path":"2021/11/18/论道德和自由/","link":"","permalink":"http://spcablast.club/2021/11/18/%E8%AE%BA%E9%81%93%E5%BE%B7%E5%92%8C%E8%87%AA%E7%94%B1/","excerpt":"","text":"论意欲的自由 起因：挪威皇家科学院提出的问题 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是自由的？ 叔本华回答这个问题写了这篇论文 正文： 第一部分，先对几个关键概念定义 1.1自由 (叔本华认为）我们能想到的是：不存在任何起妨碍的作用的东西。根据妨碍的作用之物将自由分为三类： 身体、物质、上的自由 智力上的自由 道德上的自由。 A 身体、物质上的自由指的是不存在任何种类的物质障碍。比如：人和动物没有受到皮带、绳索、监狱、瘫痪等的阻碍，他们的身体与他们的意愿相符，那动物和人就称为自由的。这是原初的，直接的，最常见的涵义。 自由的哲学概念的涵义： B 智力上的自由。智力是动因传递到意识的媒介，智力的区别导致动因是否能准确，清晰的传递到人的意识之中。 C 道德(不是日常通用的那个道德的涵义)上的自由起始： 在人没有受到物质阻碍的情况下，一个人却可以纯粹受动因的制约而不会随心所欲的行事。（动因包括恐吓，许诺，危险等） 若要接受本文的推理过程，那就得接受以上物质上的智力上的和道德上的自由就包括了自由所有的范畴了，但是是吗 引出问题：受到如此制约的人是自由的吗？人的意愿会受到以上动因的影响，那么意愿本身是自由的吗？ 从物质上对自由的制约因素到精神上对自由的制约因继续推理：如此，自由的定义从仅指能否做出行为，到与意愿发生了关联。 这样，自由的定义: 不存在任何起妨碍的作用的东西， 就变成了: 与自己的意愿相符（如果我可以根据自己的意愿行事，那我就是自由的） 这个定义把问题：“我们的意愿本身是自由的吗”变成了废话 因为把自由的定义代入之后就变成了“我们的意愿本身是自由（与自己的意愿相符）的吗” 显然是的，但是没有告诉我们东西。 所以，问题：意愿的背后是否还有原因，意愿是否依赖于其他，意愿本身是自由的吗？为了解决这个问题，需要改变自由的定义。 得出新的自由的定义：自由：不存在任何必然性。 修改后的定义还是一个否定的定义，是前一个定义的抽象涵义 是吗是吗，不存在妨碍和不存在必然性这真的是一个东西？ 必然性： 某一充足原因（根据）引发出结果。（某样东西就是从某一原因引发的结果，我们就会知道这个结果是必然的。比如，逻辑方面，数学方面，物理方面，三角形的角度相同可以得到三角形的边长相同）也就是说，不存在任何必然性，就是不依赖于任何原因，也就是一个人的意愿在外现时，并不受到原因，或者理由的左右和决定，因为否则的话，一个人的意欲活动就不会是自由的，而是必然的了。 问题变成：能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 那么接下来讨论自身意识和人的意欲（意愿）的定义，通过自身意识来定义人的意欲。 1.2 自身意识 定义：对我们自身的意识。 这个定义是相对于我们对于其他事物的意识而言的。作者把意识分成对自身的意识和对其他事物的意识，分界线由自身的定义决定 人认知其他事物的认知功能的形式分为时间，空间，因果律。我们无法使用这些功能得到对自身的意识，只能用来掌握其他事物的客观知识。 认知官能首先是以直观的方式认识、把握这一现实外在世界；然后，认知官 能就反思、琢磨以此方式所获得的直观认识，并把这些认识加工、整理 成概念。在语词的帮助下对这些概念进行无穷尽的组合，就构成了思维活动。在减去了我们总体意识中这绝大部分的内容以后，所剩下的部分 就是对自身的意识. 问题：一个人是怎么意识到自身的？ 回答：自身意识的对象物是始终就是自己的意欲活动。（通过意欲活动感受到自身） 是不是说我们能感受到的关于自己的内容，都是自己的意欲活动。 意欲活动的外现：一切渴望、奋斗、愿望、希冀、怀念、爱恋、高兴、欢庆 等，还有就是不情愿和抗拒的感情，所有的厌恶、反感、害怕、愤怒、 憎恨、悲哀、痛苦，一句话，所有一切的情感和激情。 这些情感和激情都是我们意欲的骚动，我们的意欲要么得到满足，要么无法得到满足，与我们获得或错失我们的欲望之物、忍受或者去掉我们的厌恶之物有关。这些构成了我们内在感觉的对象。 那么可以说，当一个人完全感觉不到外部的世界之后，再没有情绪，他就感觉不到自己了？没有触觉听觉视觉味觉嗅觉 而这些自身意识或者说内在感觉的对象，和外在世界存在着联系。我们在外在世界的察觉的对象，是诱发上述活动的动因和材料。 这里把自身意识和外在世界联系起来了，联系关系是外在世界诱发自身意识的活动。 2.1意欲和自身意识的关系 当一个人意欲着，他就是意欲着某一对象物。意欲活动是我们自身意识的对象，某一事物进入到我们对其他事物的意识，意欲活动产生了。 >前半句算结论还是算假设呢，或者是即将被证明的假设？ 动因： 上一句的某一事物在与我们认知官能的关系中，被称为动因,也是意欲活动的素材。意欲活动的目标就是对动因产生反应。意欲活动的本质就在这个反应之中。得出结论:没有动因，意欲活动就不会产生 问题：如果这些事物进入到我们对其他事物的意识里，意欲活动是否必然发生？发生的意欲活动一定是一样的吗？也就是，意欲会不会对这些事物有所反应？在完全一样的条件下，意欲能否有彼此相反的反应？也就是说，意欲活动会由动因必然引起吗？ 自由不自由就在这了，如果一个动因对应一个意欲活动，那人就不是自由的了当动因进入意识的时候，意欲是否保留着活动或者不活动的完全自由？ 回顾问题： 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 因为人对自身的意识 = 意欲活动，而意欲是由人对外部的意识引起的，对自身的意识不包含人对外部的意识，所以光凭人对自身的意识是不足以的得到问题的答案的。 人的自身的意识关于意欲活动的感受大致是： 我可以做我意欲要做的事。这句话真正的含义是，我们能做出与意欲相符的事。而我们无法意识到意欲的产生，只能感受到意欲产生之后，我们这么做了。无法说明我们的意欲活动的产生是否依赖于外在世界。 自身意识能感受意欲活动和操作身体。*还在酝酿过程中的是愿望，酝酿结束了的叫决定，在做出行为之后，这一行为才向自身意识表明这是决定，因为在付诸行动之前，愿望是能改变的。人们可以有相反的愿望，却只能意欲其中之一，因为到底意欲什么，只能通过做出的行动才让自身已是知道。 自身意识只包含了意欲活动，却不包含决定意欲活动的原因和理由（原因和理由在对其他事物的意识里） 那么问题就变成了： 一个人是否也和世界上的所有其他事物一样，由于自己的构成而从此成为一个明确的存在物，并且就像大自然的所有其他存在物一样，有着自己确定永恒的素质；这些素质随着外在机会的出现而必然作出反应；因此，这些素质从这方面看都带有其不变的特性（性格）；所以，这些素质以及那些可作些微调整的东西，是完全听任外在机会和诱因的限定和左右？抑或人类惟独就是大自然的例外？ 动因在进入人的意识之后，是否通过这个人的性格的处理，输出一个确定的结果，形成一个唯一的确定的意欲活动？他想说的是我可以这样做，也可以完全相反的那么做，但是由于我个人的性格，我最后只会选择一个确定的行为。 一个人的意欲就是他本身，这个人存在的真正内核。人的意欲构成了人的意识的基础。他就是想说人的性格是确定的，不变的，天生的，后天的经验无法改变一个人的性格， 3.1意欲和我们对其他的意识 让我们观察那些受意欲驱使着的意欲生物。把因果律的原因分为三种：原因，刺激，动因3.1.1原因指的是机械的物理的化学的变化3.1.2刺激指的是适当的刺激引起相应的变化//那个时候的科学不太行，这俩都不是很合适3.1.3动因以认知为媒介的因果作用。动物的活动随着动因展开，在动物的自身意识中由动因引起的内在动力叫做意欲。 人的行为动因大多是思想和念头，目前时空形成的的动因不多。所有的动因都是原因，所有的因果都有其必然性。 举个例子：我可以做出我所意欲的事情。如果我意欲（愿意）的话，我可以把我所拥有的一切捐献给穷人，以致自己也成为穷人中的一员——如果我意欲（愿意）的话！但我却无法真有这样的意欲，因为与此相反的动因 对我产生了太强有力的作用。而如果我的性格是另外一种样子，甚至是一个圣人，那我就会有捐献所拥有的一切的意欲。我真要是这样的圣人，那我就不这样意欲也不行。也就是说，我就必然要这样做。所有这些都与自身意识中的表白“我可以做出我所意欲的事情”并行不悖。 *性格首要决定了各种不同的动因在某一个人 身上的作用方式，因为动因所引出的所有结果，其基础根源是性格，正如由最狭窄意义上的原因所引出的结果，其基础根源是普遍自然力，由 刺激所引出的结果，其基础根源是生命力一样。与自然力一样，性格同样是原初的、无法改变的和无法解释的。 每个人的性格不一样； 性格是在经验之后才能了解到的； 性格是持续如一的； 性格是与生俱来的；人由于自己的性格始终不渝的追求自己的目标，性格无法改变，能通过改变他的认知改变他追求这个目标的方法和手段。 有什么用呢，比如我以为明天能早起，我下定决心等会儿去跑步，我以为我到了那个点就会去跑步，而事实上，根据我的性格，也就是意欲，也就是那个使我不同与其他人的那个事物，决定了我等会儿并不会去跑步，而是回去坐着。那这个又有什么用呢，可以根据我的性格，设置一个行为，比如走在路上突然跑起来，我就会跑回去（因为我的性格是万事开头难，开了个头就会想做完，做完了或者受到不可抗力打断才会中断），跑着跑着跑到楼下就算热好身了，甚至还有可能会练一会别的。 结论怎么来的呢，不知道，我在中途绕进去了，建议看原文结论：有了既定的动因和确定的性格，那么必然引出一定的行为结果。所有发生的事情，无论大小，都是必然地发生。 这些结论可以给作者提供平静和安慰，我觉得这样就少了人定胜天的那种感觉，既然胜天都是注定了，那么胜天也就没有失去了应该有的那种感觉。 4.1先行者列举了一些历史上对这个问题发表过意见的伟人。顺便骂了几个人（比如黑格尔）命运引领情愿者，单但拖曳不情愿的人。 –伏尔泰所以，我们可以承认：如果我们真有可能对一个人的思维方式——这通过内在和外在的行为呈现出来——有一深刻的了解，清楚 知道这个人行为后面的每一或大或小的推动力，以及所有能够影响 这个人的思维方式的外在诱因，那我们就像可以确切计算出在何时 日食、月食一样地确切计算出一个人将来的行为。 –康德 这证实了这一已得到人们承认和赞扬的格言：在科学的探索中，我们都要尽可能地精准和诚实，不受干扰地走自己的路；不要 担心自己的探索是否有可能与这一学科以外的事情相抵触，而要尽我们所能真实、完美地把这一探索工作本身进行到底。我经常看到 的情形让我确信：当我们的探索工作完结以后，那在探索进行过程 中，在考虑到其他领域的学说时，有些东西有时候会显得大有疑 问；但只要我把这些疑问置之不理，心无旁骛地专注于自己的探索 直至完成，那原先似乎大有疑问的东西，却出乎预料地与在丝毫没 有顾虑到别人的学说、对那些东西既没有先入为主的偏好也没有偏 恶的情况下，所独自发现的东西完全吻合。只要著作者能够下定决 心，更加诚实地投入工作中去，那他们就会避免犯下许多的错误， 避免无谓浪费那么多的精力。（《实践理性批判》第四版，190 页） –康德 哲学家的武器是事实的理据，而不是权威的言论。（由于我没有跟上他的思路推出来结论，只能放点结论了） *“他是个坏人，是个恶棍，或者“这是个无赖，或者“他是个渺小、下作、虚假的 人，等等。这就是人们的判定；人们的指责总是针对这个人的性格。 做出的行为连带其动因，纯粹只是表明行为人的性格的证据而已；行为只是这个人的性格的外相，而这个人的性格已是永远和无法逆转地确定了下来。所以，亚里士多德说得很对，“我们赞扬做出了某一行为的 人，但那些行为只是显示了做出行为的人的性格而已。就算是行为还没 有做出来，但只要我们相信这个人会做出这样的行为，那我们仍然会赞 扬这个人。因此，引起我们厌恶、鄙视和憎恨的，并不是那瞬间就过 去了的行为，而是做出这些行为的人身上那些永远存在的素质，亦即性格。因此，在所有的语言里，形容道德败坏的词语、标示劣性的绰号都 是对人更甚于对事，因为性格才应该承担罪责，而这罪责只是因为有了 机会才通过做出行为得到证实。结论： 一个人永远只做出他所意欲（愿）的行为，但他做出这样的行为其实是必然的。原因全在于这个人已经就是他所意欲：因为只要这个人是这样的人，那必然就会做出所有这样的事情。如果我们客观（体）考察这个人的行事，亦即从外在考察这些所为，那我们就会确实 无疑地认出：这些行为和大自然每一存在物的发挥是一样的，都是严格 受制于因果法则。从主观（体）上看，每个人都感觉自己总是按照自己 的意欲行事。但这只说明了他的发挥（行为），只是他自身本质的纯粹外现而已。所以，大自然的每一存在物，甚至最低级的一类，都会有这同一样的感觉——如果它们能够感觉的话。//我是我 再贴一段： 因此，大致上而言，所有在当事人当时不知道自己在干什么或者完全没有能力考虑到制止这样做的理由，亦即在没有能力考虑到事情后果 的情况下所犯下的罪行，都可视为在欠缺智力自由的情况下的犯罪。因 此，这种情形的犯罪，犯罪者是不应受到惩罚的。 但如果人们认为：由于没有道德上的自由，因此，一个人做出某种行为是不可避免的，所以，犯下罪行的人不应该受到惩罚，那他们可是 理解错了刑罚的目的。也就是说，他们误以为对罪犯实施惩罚是因为罪 行本身的缘故，是基于道德理由的以牙还牙的报复。虽然康德也教导这 样的观点，但这样的惩罚却是荒谬的、没有任何目的的、绝对是没有任 何理由的。这是因为一个人又有何权利以绝对法官自居去判断他人的道 德，并因为他人的罪过而对其加以折磨！其实，法律——亦即威胁给予 惩罚——目的却是要成为制止人们将来犯罪的相反动因。如果在某些情 形里，法律起不到这样的制约作用，那也得执行法律，因为如果法律得 不到实行，那在将来的所有情形里，法律都将无法再发挥制约的作用。 在罪犯方面，罪犯在这种情况下遭受惩罚是自己的道德品质所致——罪 犯自己的道德品质与那外在环境的动因，再加上误导自己让自己以为可 以侥幸逃脱惩罚的智力，三者结合起来，不可避免地促成了犯罪。在这 种情况下，只有当事人的道德性格并不是这个人自己的作品，并不是认 知的行为，而是他人的作品，那他遭受惩罚才是不公正的。如果一个人 罪恶行为的结果并不是人为的，而是遵循大自然的规则，那行为与其后 果也是一样的关系。例如，如果因放肆纵欲而导致疾病，又或者，如果 一个人在夜间闯入别人的猪圈，试图盗走里面的猪，但却碰上碰巧在这过夜的主人寄宿在这猪圈里的大熊。 既然一切都是确定的，那么对于个人来说，只知道是确定的而不知道确定的内容是什么，那么未来就还是未知的，只不过能更加平静地对待以后会发生的一切事情，和以往发生的一切事情，因为都是注定的，人的性格决定了他知道了一切都是确定的之后会做出的反应。 上面对自身的意识和对外界的意识分的比较怪，可能是为了方便论证。 论文里还有点对道德和良心的论述，因为性格是确定的，所以善恶也确定了，良心是事情发生后对事情的反思。//由于后面跟不上了，只能贴很多原文，建议看原文，100页左右。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"叔本华","slug":"叔本华","permalink":"http://spcablast.club/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"自由","slug":"自由","permalink":"http://spcablast.club/tags/%E8%87%AA%E7%94%B1/"},{"name":"意欲","slug":"意欲","permalink":"http://spcablast.club/tags/%E6%84%8F%E6%AC%B2/"},{"name":"推理","slug":"推理","permalink":"http://spcablast.club/tags/%E6%8E%A8%E7%90%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211117","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T13:42:26.191Z","comments":true,"path":"2021/11/17/20211117/","link":"","permalink":"http://spcablast.club/2021/11/17/20211117/","excerpt":"","text":"###1552. 两球之间的磁力在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 题解：干啊，思路有了，写出来还差一点 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool legal(int m, vector&lt;int&gt;&amp; position, int k)&#123; int pre &#x3D; position[0], count &#x3D; 1; for(int i &#x3D; 0;i &lt; position.size();++i)&#123; if(position[i] - pre &gt;&#x3D; m)&#123; pre &#x3D; position[i]; count++; &#125; &#125; if(count &gt;&#x3D; k) return true; else return false; &#125; int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; &#x2F;&#x2F;又是数学题，gan啊 &#x2F;&#x2F;阅读理解：数轴上n点，position[i], 激活m个点，找到使得m个点中每两个点的距离都尽可能的大的位置 &#x2F;&#x2F;既然这样，首尾两个球肯定是要用的，然后求中间的值，看最接近的是哪个，这样就有两段，分别取中值，找最接近的，比较四段长度 &#x2F;&#x2F;那我岂不是可以排序，然后求出所有的间隔，由大到小，不行 &#x2F;&#x2F;好像懂了，太顶了，直接找答案，答案就在0到最大值减去最小值，然后对这个值进行二分查找，存在m个长度的段大于等于这个值就对了，多于m个说明这个值可以加，小于m说明这个值得减 sort(position.begin(),position.end()); int l &#x3D; position.size(); int dis &#x3D; position[l -1] - position[0]; int left &#x3D; 1, right &#x3D; dis, prelen &#x3D; 0, ans &#x3D; -1; while(left &lt;&#x3D; right)&#123; int mid &#x3D; (right + left) &#x2F;2; if(legal(mid, position, m))&#123;&#x2F;&#x2F;如果有m个大于等于len，说明m小了 ans &#x3D; mid; left &#x3D; mid + 1; &#125; else&#123; right &#x3D; mid - 1; &#125; &#125; return ans; &#125;&#125;; ###169. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：[3,2,3]输出：3示例 2： 输入：[2,2,1,1,1,2,2]输出：2 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 题解： 123456789101112131415161718192021222324252627class Solution &#123;public: &#x2F;&#x2F;这题我见过，用哈希map吧，map好像还行，不如哈希 &#x2F;&#x2F;进阶挺难的 int majorityElement(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F; unordered_map&lt;int, int&gt; counts; &#x2F;&#x2F; int majority &#x3D; 0, cnt &#x3D; 0; &#x2F;&#x2F; for (int num: nums) &#123; &#x2F;&#x2F; ++counts[num]; &#x2F;&#x2F; if (counts[num] &gt; cnt) &#123; &#x2F;&#x2F; majority &#x3D; num; &#x2F;&#x2F; cnt &#x3D; counts[num]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return majority; unordered_map&lt;int,int&gt; map; int ans &#x3D; 0, count &#x3D; 0; for(int num:nums)&#123; ++map[num]; if(map[num] &gt; count)&#123; ans &#x3D; num; count &#x3D; map[num]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211116","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-17T04:57:58.142Z","comments":true,"path":"2021/11/16/20211116/","link":"","permalink":"http://spcablast.club/2021/11/16/20211116/","excerpt":"","text":"###67. 二进制求和给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100”示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。1 &lt;= a.length, b.length &lt;= 10^4字符串如果不是 “0” ，就都不含前导零。 题解分四种情况不如官方题解直接分两种情况，优化代码，不可能优化的，字符串的操作还得多学 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; &#x2F;&#x2F;先把字符串倒过来，用两个数存长度， &#x2F;&#x2F;a &#x3D; a.reverse(); &#x2F;&#x2F;b &#x3D; b.reverse(); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans; int acc &#x3D; 0; char tempa, tempb; int la &#x3D; a.size(), lb &#x3D; b.size(); for(int i &#x3D; 0; (i &lt; la || i &lt; lb); i++)&#123; if(i&lt;la) tempa &#x3D; a[i]; else tempa &#x3D; &#39;0&#39;; if(i&lt;lb) tempb &#x3D; b[i]; else tempb &#x3D; &#39;0&#39;; if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 3) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 2) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 1) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 0; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 0) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 0; &#125; &#125; if(acc &#x3D;&#x3D; 1)&#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(),ans.end()); return ans; &#125;&#125;; 看看人家 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int n &#x3D; max(a.size(), b.size()), carry &#x3D; 0; for (size_t i &#x3D; 0; i &lt; n; ++i) &#123; carry +&#x3D; i &lt; a.size() ? (a.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; carry +&#x3D; i &lt; b.size() ? (b.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; ans.push_back((carry % 2) ? &#39;1&#39; : &#39;0&#39;); carry &#x2F;&#x3D; 2; &#125; if (carry) &#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-binary&#x2F;solution&#x2F;er-jin-zhi-qiu-he-by-leetcode-solution&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ###299. 猜数字游戏链接你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数字和朋友猜测的数字都可能含有重复数字。 示例 1: 输入: secret = “1807”, guess = “7810”输出: “1A3B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1807” |“7810”示例 2: 输入: secret = “1123”, guess = “0111”输出: “1A1B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1123” “1123” | or |“0111” “0111”注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。 题解（吐槽）：中等题的难度也是有区别的，这个算简单吧，而且阅读理解可能是大问题，阅读理解对了之后就是怎么把已知信息用算法表现出来了，欸，思想，就是思想。优化，是不可能优化的，就是从这里跳下去，我也不会优 12345678910111213141516171819class Solution &#123;public: string getHint(string secret, string guess) &#123; &#x2F;&#x2F;简单的方法应该是遍历一遍，把公牛数字找出来，不如排序，或者用map，0到9分别有几个，对应数量相减，再减去公牛数字就是奶牛数字个数，直接用数组就行了 int cow &#x3D; 0, bull &#x3D; 0; int counts[10] &#x3D; &#123;0&#125;,countg[10] &#x3D; &#123;0&#125;; for(int i &#x3D; 0;i &lt; secret.size();++i)&#123; if(secret[i] &#x3D;&#x3D; guess[i]) bull++; else&#123; counts[secret[i] - &#39;0&#39;]++; countg[guess[i] - &#39;0&#39;]++; &#125; &#125; for(int i &#x3D; 0;i&lt;10;i++)&#123; cow +&#x3D; min(countg[i],counts[i]); &#125; return to_string(bull) + &#39;A&#39; + to_string(cow)+&#39;B&#39;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211115","date":"2021-11-14T16:00:00.000Z","updated":"2022-12-20T01:35:51.396Z","comments":true,"path":"2021/11/15/20211115/","link":"","permalink":"http://spcablast.club/2021/11/15/20211115/","excerpt":"","text":"###264. 丑数 II给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10输出：12解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 123456789&#x2F;&#x2F;没人比我更懂暴力算法.jpgint all[] &#x3D; &#123;1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400&#125;;class Solution &#123;public: int nthUglyNumber(int n) &#123; return all[n-1]; &#125;&#125;; #######正常解法 12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] &#x3D; 1; int p2 &#x3D; 1, p3 &#x3D; 1, p5 &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; int num2 &#x3D; dp[p2] * 2, num3 &#x3D; dp[p3] * 3, num5 &#x3D; dp[p5] * 5; dp[i] &#x3D; min(min(num2, num3), num5);&#x2F;&#x2F;取个最小的保证顺序 if (dp[i] &#x3D;&#x3D; num2) &#123;&#x2F;&#x2F;pi++的意思是这个数乘了2还是最小的，其他的数乘了3，5应该加到下一个了 p2++; &#125; if (dp[i] &#x3D;&#x3D; num3) &#123; p3++; &#125; if (dp[i] &#x3D;&#x3D; num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 那我只能说，我不理解，到底该谁乘2，谁乘3，谁乘5，乘几次啊 ###剑指 Offer II 069. 山峰数组的顶部符合下列属性的数组 arr 称为 山峰数组（山脉数组） ： arr.length &gt;= 3存在 i（0 &lt; i &lt; arr.length - 1）使得：arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。 示例 1： 输入：arr = [0,1,0]输出：1示例 2： 输入：arr = [1,3,5,4,2]输出：2 1234567891011class Solution &#123;public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) &#123; int max &#x3D; arr[0]; for(int i&#x3D;1;i&lt;arr.size();++i)&#123; if(arr[i] &lt; max) return i - 1; max &#x3D; arr[i]; &#125; return 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211114","date":"2021-11-13T16:00:00.000Z","updated":"2022-12-20T01:35:51.396Z","comments":true,"path":"2021/11/14/20211114/","link":"","permalink":"http://spcablast.club/2021/11/14/20211114/","excerpt":"","text":"###455. 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 1234567891011121314151617181920class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; int totol &#x3D; 0; sort(g.begin(),g.end());&#x2F;&#x2F;默认由小到大排序 sort(s.begin(),s.end()); int j &#x3D; 0; for(int i &#x3D; 0; i&lt; g.size();++i)&#123; while(j &lt; s.size())&#123; if(s[j] &gt;&#x3D; g[i]) &#123; totol++; j++; break; &#125; else j++; &#125; &#125; return totol; &#125;&#125;; ###剑指 Offer 56 - I. 数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;我只能说，NB，这方法，顶 int ret &#x3D; 0; for (int n : nums) ret ^&#x3D; n; int div &#x3D; 1; while ((div &amp; ret) &#x3D;&#x3D; 0) div &lt;&lt;&#x3D; 1; int a &#x3D; 0, b &#x3D; 0; for (int n : nums) if (div &amp; n) a ^&#x3D; n; else b ^&#x3D; n; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211113","date":"2021-11-12T16:00:00.000Z","updated":"2021-11-17T08:48:03.461Z","comments":true,"path":"2021/11/13/20211113/","link":"","permalink":"http://spcablast.club/2021/11/13/20211113/","excerpt":"","text":"###面试题 10.11. 峰与谷在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。 示例: 输入: [5, 3, 1, 2, 3]输出: [5, 1, 3, 2, 3] 1234567891011121314151617181920212223242526272829class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; vers(nums); int left &#x3D; 0, right &#x3D; nums.size()-1, len &#x3D;nums.size(); sort(vers.begin(),vers.end()); int index &#x3D; 0; while(left &lt; right)&#123; nums[index++] &#x3D; vers[left++]; nums[index++] &#x3D; vers[right--]; &#125; if(nums.size()%2 !&#x3D; 0) nums[index] &#x3D; vers[left]; &#x2F;&#x2F;这个回答和我有缘，想到一块去了 &#x2F;&#x2F; size_t idx &#x3D; 0, len &#x3D; nums.size(); &#x2F;&#x2F; if (len &lt; 3) return; &#x2F;&#x2F; size_t low &#x3D; 0, high &#x3D; len - 1; &#x2F;&#x2F; vector&lt;int&gt; sorted(nums); &#x2F;&#x2F; sort(sorted.begin(), sorted.end()); &#x2F;&#x2F; while (low &lt; high) &#123; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[high--]; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[low++]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if (len % 2 &gt; 0) nums[idx] &#x3D; sorted[low]; &#x2F;&#x2F; 作者：gfu &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;peaks-and-valleys-lcci&#x2F;solution&#x2F; bi-jiao-zhi-guan-de-xiang-fa-xian-pai-xu-by-gfu&#x2F; &#x2F;&#x2F; 来源：力扣（LeetCode） &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; ###13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: int romanToInt(string s) &#123; int lastNum &#x3D; 0, totol &#x3D; 0; for(int i &#x3D; 0; i&lt; s.length();i++)&#123; if(s[i] &#x3D;&#x3D; &#39;I&#39;)&#123; lastNum &#x3D; 1; totol +&#x3D; 1; &#125; else if(s[i] &#x3D;&#x3D; &#39;V&#39;)&#123; if(lastNum &lt; 5)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 5; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 5; totol +&#x3D; 5; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;X&#39;)&#123; if(lastNum &lt; 10)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 10; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 10; totol +&#x3D; 10; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;L&#39;)&#123; if(lastNum &lt; 50)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 50; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 50; totol +&#x3D; 50; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;C&#39;)&#123; if(lastNum &lt; 100)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 100; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 100; totol +&#x3D; 100; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;D&#39;)&#123; if(lastNum &lt; 500)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 500; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 500; totol +&#x3D; 500; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;M&#39;)&#123; if(lastNum &lt; 1000)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 1000; totol +&#x3D;lastNum; &#125; else totol +&#x3D; 1000; &#125; &#125; return totol; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211112","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-17T08:48:08.786Z","comments":true,"path":"2021/11/12/20211112/","link":"","permalink":"http://spcablast.club/2021/11/12/20211112/","excerpt":"","text":"###5. 最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 Solution &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public: void len(int * result, int i, int j, string s)&#123; if(i!&#x3D;j &amp;&amp; s[i] !&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; i; &#125; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; j; --i; ++j; &#125; return; &#125; string longestPalindrome(string s) &#123; if(s.length() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; int maxLen[2], maxi, maxL; int start &#x3D; 0, end &#x3D; 0; int index1[2],index2[2]; for(int k &#x3D; 0; k &lt; s.length(); ++k)&#123; len(index1, k, k, s); len(index2, k, k+1, s); if(index1[1] - index1[0] &gt; end -start)&#123; start &#x3D; index1[0]; end &#x3D; index1[1]; &#125; if(index2[1] - index2[0] &gt; end -start)&#123; start &#x3D; index2[0]; end &#x3D; index2[1]; &#125; &#125; return s.substr(start, end - start + 1); &#x2F;&#x2F;for(int j &#x3D; k, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; (j+1) &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F;&#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;for(int k &#x3D; 1; k &lt; s.length(); ++k)&#123; &#x2F;&#x2F; for(int j &#x3D; k+1, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; j &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i] &#x3D;&#x3D; s[j])&#123; &#x2F;&#x2F; if(maxLen &lt;&#x3D; 2)&#123; &#x2F;&#x2F; maxLen &#x3D; 2; &#x2F;&#x2F; maxi &#x3D; j; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;return s.substr(maxi, maxLen); &#125;&#125;; ###14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1： 输入：strs = [“flower”,”flow”,”flight”]输出：”fl” 123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; string ans &#x3D; strs[0]; for(int j &#x3D; 0; j &lt; strs.size() ; ++j )&#123; int i &#x3D; 0; for(; i &lt;&#x3D; strs[0].length() &amp;&amp; i &lt; ans.length(); ++i)&#123; if(ans[i] !&#x3D; strs[j][i])&#123; break; &#125; &#125; if(ans.length() &#x3D;&#x3D; 0) return &quot;&quot;; ans &#x3D; strs[0].substr(0,i); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211111","date":"2021-11-10T16:00:00.000Z","updated":"2021-11-17T08:48:14.096Z","comments":true,"path":"2021/11/11/20211111/","link":"","permalink":"http://spcablast.club/2021/11/11/20211111/","excerpt":"","text":"###1785. 构成特定和需要添加的最少元素给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 1234567891011121314151617class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long long int sum &#x3D; 0; for(int num:nums)&#123; sum +&#x3D; num; &#125; if(sum &#x3D;&#x3D; goal) return 0; if(abs(sum - goal) &lt; abs(limit))&#123; return 1; &#125; if(abs(sum - goal) % abs(limit) &#x3D;&#x3D; 0 )&#123; return abs(sum - goal) &#x2F; abs(limit); &#125; else return abs(sum - goal) &#x2F; abs(limit) + 1; &#125;&#125;; ###剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left) , maxDepth(root-&gt;right)) +1; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-17T08:48:20.645Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211109","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-17T08:48:25.246Z","comments":true,"path":"2021/11/09/20211109/","link":"","permalink":"http://spcablast.club/2021/11/09/20211109/","excerpt":"","text":"###1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans(2,0); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int temp &#x3D; target - nums[i]; &#x2F;&#x2F;if( temp &lt; 0 ) continue; for(int j &#x3D; i+1; j &lt;nums.size(); ++j)&#123; if(temp &#x3D;&#x3D; nums[j] )&#123; ans[0] &#x3D; i; ans[1] &#x3D; j; return ans; &#125; &#125; &#125; return ans; &#125;&#125;;&#x2F;&#x2F;我就说哈希表好嘛，虽然我不会 ###198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 1234567891011121314151617181920class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1)&#123; return nums[0]; &#125; if(nums.size() &#x3D;&#x3D; 2)&#123; return max(nums[0],nums[1]); &#125; vector&lt;int&gt; ma(nums.size()+1, 0); ma[0] &#x3D; nums[0]; ma[1] &#x3D; max(nums[0], nums[1]); int maxNum &#x3D; 0; for(int i &#x3D; 2; i &lt; nums.size(); i++)&#123; maxNum &#x3D; nums[i]; ma[i] &#x3D; max(ma[i - 1], ma[i -2] + maxNum ); &#125; return ma[nums.size() - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211108","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-17T08:48:31.915Z","comments":true,"path":"2021/11/08/20211108/","link":"","permalink":"http://spcablast.club/2021/11/08/20211108/","excerpt":"","text":"###1105. 填充书架附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; &#x2F;&#x2F;我大受震撼，且我不理解，下次让我做我还不会 &#x2F;&#x2F; vector&lt;int&gt; d(books.size()+1,INT_MAX); &#x2F;&#x2F; d[books.size()] &#x3D; 0; &#x2F;&#x2F; for(int i &#x3D; books.size() - 1; i &gt;&#x3D; 0 ; --i)&#123; &#x2F;&#x2F; int MaxHeight &#x3D; 0; &#x2F;&#x2F; int leftWith &#x3D; shelfWidth; &#x2F;&#x2F; for(int j &#x3D; i; j &lt; books.size() &amp;&amp; leftWith &gt; books[j][0]; ++j)&#123; &#x2F;&#x2F; MaxHeight &#x3D; max(books[j][1], MaxHeight); &#x2F;&#x2F; d[i] &#x3D; min(MaxHeight + d[j+1],d[i]); &#x2F;&#x2F; leftWith -&#x3D; books[j][0]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return d[0]; vector&lt;int&gt; dp(books.size() + 1, INT_MAX); dp[books.size()] &#x3D; 0; for (int i &#x3D; books.size() - 1; i &gt;&#x3D; 0; --i) &#123; int max_book_height &#x3D; 0; int left_width &#x3D; shelfWidth; &#x2F;&#x2F; 把第 j 本书拿到第 i 本书后面 for (int j &#x3D; i; j &lt; books.size() &amp;&amp; left_width &gt;&#x3D; books[j][0]; ++j) &#123; max_book_height &#x3D; max(max_book_height, books[j][1]); dp[i] &#x3D; min(dp[i], max_book_height + dp[j+1]); left_width -&#x3D; books[j][0]; &#125; &#125; return dp[0];&#125;; ###1822. 数组元素积的符号已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 12345678910111213class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int product = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) product *= -1; &#125; return product; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211107","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-17T08:48:36.580Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211106","date":"2021-11-05T16:00:00.000Z","updated":"2021-11-17T08:48:43.077Z","comments":true,"path":"2021/11/06/20211106/","link":"","permalink":"http://spcablast.club/2021/11/06/20211106/","excerpt":"","text":"###82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。示例 1：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates( ListNode* head) &#123; if(!head) return head; ListNode* singleNode = new ListNode(0,head); ListNode* flagHeader = singleNode; while(flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;next)&#123; if(flagHeader-&gt;next-&gt;val == flagHeader-&gt;next-&gt;next-&gt;val)&#123; int temp = flagHeader-&gt;next-&gt;val; while( flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;val == temp )&#123; flagHeader-&gt;next = flagHeader-&gt;next-&gt;next; &#125; &#125; else&#123; flagHeader = flagHeader-&gt;next; &#125; &#125; return singleNode-&gt;next; &#125;&#125;; ###剑指 Offer 39. 数组中出现次数超过一半的数字 链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //来个map? unordered_map&lt;int, int&gt; myMap; int temp = 0, maxNum = 0; for(int num : nums)&#123; ++myMap[num]; if(myMap[num] &gt; maxNum)&#123; temp = num; maxNum = myMap[num]; &#125; &#125; return temp; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"}],"categories":[{"name":"影视","slug":"影视","permalink":"http://spcablast.club/categories/%E5%BD%B1%E8%A7%86/"},{"name":"健康","slug":"健康","permalink":"http://spcablast.club/categories/%E5%81%A5%E5%BA%B7/"},{"name":"运动","slug":"运动","permalink":"http://spcablast.club/categories/%E8%BF%90%E5%8A%A8/"},{"name":"计算机","slug":"计算机","permalink":"http://spcablast.club/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"},{"name":"随笔","slug":"随笔","permalink":"http://spcablast.club/categories/%E9%9A%8F%E7%AC%94/"},{"name":"文章","slug":"文章","permalink":"http://spcablast.club/categories/%E6%96%87%E7%AB%A0/"},{"name":"植物","slug":"植物","permalink":"http://spcablast.club/categories/%E6%A4%8D%E7%89%A9/"},{"name":"认识自己","slug":"认识自己","permalink":"http://spcablast.club/categories/%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1/"},{"name":"报错记录","slug":"报错记录","permalink":"http://spcablast.club/categories/%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"},{"name":"基础知识","slug":"基础知识","permalink":"http://spcablast.club/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"工具","permalink":"http://spcablast.club/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Boost","slug":"Boost","permalink":"http://spcablast.club/categories/Boost/"},{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"},{"name":"nvm","slug":"nvm","permalink":"http://spcablast.club/categories/nvm/"},{"name":"VSCode","slug":"VSCode","permalink":"http://spcablast.club/categories/VSCode/"}],"tags":[{"name":"影评","slug":"影评","permalink":"http://spcablast.club/tags/%E5%BD%B1%E8%AF%84/"},{"name":"饮食","slug":"饮食","permalink":"http://spcablast.club/tags/%E9%A5%AE%E9%A3%9F/"},{"name":"运动强度","slug":"运动强度","permalink":"http://spcablast.club/tags/%E8%BF%90%E5%8A%A8%E5%BC%BA%E5%BA%A6/"},{"name":"运动量","slug":"运动量","permalink":"http://spcablast.club/tags/%E8%BF%90%E5%8A%A8%E9%87%8F/"},{"name":"编译","slug":"编译","permalink":"http://spcablast.club/tags/%E7%BC%96%E8%AF%91/"},{"name":"艺术","slug":"艺术","permalink":"http://spcablast.club/tags/%E8%89%BA%E6%9C%AF/"},{"name":"逍遥游","slug":"逍遥游","permalink":"http://spcablast.club/tags/%E9%80%8D%E9%81%A5%E6%B8%B8/"},{"name":"写作","slug":"写作","permalink":"http://spcablast.club/tags/%E5%86%99%E4%BD%9C/"},{"name":"人","slug":"人","permalink":"http://spcablast.club/tags/%E4%BA%BA/"},{"name":"动画","slug":"动画","permalink":"http://spcablast.club/tags/%E5%8A%A8%E7%94%BB/"},{"name":"养生","slug":"养生","permalink":"http://spcablast.club/tags/%E5%85%BB%E7%94%9F/"},{"name":"青年","slug":"青年","permalink":"http://spcablast.club/tags/%E9%9D%92%E5%B9%B4/"},{"name":"多肉植物","slug":"多肉植物","permalink":"http://spcablast.club/tags/%E5%A4%9A%E8%82%89%E6%A4%8D%E7%89%A9/"},{"name":"长寿花","slug":"长寿花","permalink":"http://spcablast.club/tags/%E9%95%BF%E5%AF%BF%E8%8A%B1/"},{"name":"python","slug":"python","permalink":"http://spcablast.club/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://spcablast.club/tags/windows/"},{"name":"anaconda","slug":"anaconda","permalink":"http://spcablast.club/tags/anaconda/"},{"name":"指针","slug":"指针","permalink":"http://spcablast.club/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://spcablast.club/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"摘选","slug":"摘选","permalink":"http://spcablast.club/tags/%E6%91%98%E9%80%89/"},{"name":"网站","slug":"网站","permalink":"http://spcablast.club/tags/%E7%BD%91%E7%AB%99/"},{"name":"Signal","slug":"Signal","permalink":"http://spcablast.club/tags/Signal/"},{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"dfs","slug":"dfs","permalink":"http://spcablast.club/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"http://spcablast.club/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"心理学","slug":"心理学","permalink":"http://spcablast.club/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"链表","slug":"链表","permalink":"http://spcablast.club/tags/%E9%93%BE%E8%A1%A8/"},{"name":"总结","slug":"总结","permalink":"http://spcablast.club/tags/%E6%80%BB%E7%BB%93/"},{"name":"双指针","slug":"双指针","permalink":"http://spcablast.club/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"排序","slug":"排序","permalink":"http://spcablast.club/tags/%E6%8E%92%E5%BA%8F/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://spcablast.club/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"鲁迅全集","slug":"鲁迅全集","permalink":"http://spcablast.club/tags/%E9%B2%81%E8%BF%85%E5%85%A8%E9%9B%86/"},{"name":"马克思选集","slug":"马克思选集","permalink":"http://spcablast.club/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E9%80%89%E9%9B%86/"},{"name":"字符串","slug":"字符串","permalink":"http://spcablast.club/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"树","slug":"树","permalink":"http://spcablast.club/tags/%E6%A0%91/"},{"name":"优先队列","slug":"优先队列","permalink":"http://spcablast.club/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"快慢指针","slug":"快慢指针","permalink":"http://spcablast.club/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"vector排序","slug":"vector排序","permalink":"http://spcablast.club/tags/vector%E6%8E%92%E5%BA%8F/"},{"name":"二分","slug":"二分","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%88%86/"},{"name":"数组计数","slug":"数组计数","permalink":"http://spcablast.club/tags/%E6%95%B0%E7%BB%84%E8%AE%A1%E6%95%B0/"},{"name":"自动机","slug":"自动机","permalink":"http://spcablast.club/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"随机","slug":"随机","permalink":"http://spcablast.club/tags/%E9%9A%8F%E6%9C%BA/"},{"name":"归并排序","slug":"归并排序","permalink":"http://spcablast.club/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"图","slug":"图","permalink":"http://spcablast.club/tags/%E5%9B%BE/"},{"name":"多","slug":"多","permalink":"http://spcablast.club/tags/%E5%A4%9A/"},{"name":"vector","slug":"vector","permalink":"http://spcablast.club/tags/vector/"},{"name":"树 - 算法题","slug":"树-算法题","permalink":"http://spcablast.club/tags/%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"nodejs版本管理","slug":"nodejs版本管理","permalink":"http://spcablast.club/tags/nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"音频添加","slug":"音频添加","permalink":"http://spcablast.club/tags/%E9%9F%B3%E9%A2%91%E6%B7%BB%E5%8A%A0/"},{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"二叉树 - 算法题","slug":"二叉树-算法题","permalink":"http://spcablast.club/tags/%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"SQL - 算法题","slug":"SQL-算法题","permalink":"http://spcablast.club/tags/SQL-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"短篇小说","slug":"短篇小说","permalink":"http://spcablast.club/tags/%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4/"},{"name":"vector操作 - 算法题","slug":"vector操作-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C-%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"-ffmpeg命令行操作","slug":"ffmpeg命令行操作","permalink":"http://spcablast.club/tags/ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"},{"name":"叔本华","slug":"叔本华","permalink":"http://spcablast.club/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"自由","slug":"自由","permalink":"http://spcablast.club/tags/%E8%87%AA%E7%94%B1/"},{"name":"意欲","slug":"意欲","permalink":"http://spcablast.club/tags/%E6%84%8F%E6%AC%B2/"},{"name":"推理","slug":"推理","permalink":"http://spcablast.club/tags/%E6%8E%A8%E7%90%86/"},{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}]}