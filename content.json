{"meta":{"title":"YP Blog","subtitle":"咸的博客","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"书单","date":"2021-11-15T05:02:33.109Z","updated":"2021-11-15T05:02:33.109Z","comments":true,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"友情链接","date":"2021-04-24T08:25:31.069Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""},{"title":"reading","date":"2021-11-18T00:51:00.817Z","updated":"2021-11-18T00:51:00.817Z","comments":true,"path":"books/书单.html","permalink":"http://spcablast.club/books/%E4%B9%A6%E5%8D%95.html","excerpt":"","text":"《艺术创造学》 余秋雨 《论道德和自由》叔本华 《六祖坛经》 论充足根据律的四重根 叔本华 裸猿三部曲 生命是什么 薛定谔 《上瘾》 机器学习 周志华 鲁迅全集（太长） 作为意志和表象的世界 叔本华 荣格 红书，认识人性 弗洛伊德 阿德勒 《自卑与超越》 韦启昌译叔本华 心理学之旅 论语 道德形而上学奠基句读 邓晓芒 etc.虽然作者著书的时间不同于当代，但是他们想表达的内容确实在人的范围里，这是他们根据自己的智慧得出来的结论或者经验或者是过程的记录，是他们自己的感受。是，前人的智慧。可以从中学到他们的思考方式，甚至有些东西能直接拿来用 藏书馆：《自私的基因》 《人为什么活着》王小波 《西方哲学史》罗素 《代码之美》 《非暴力沟通》 《浮生六记》 九把刀 古龙 《把时间当朋友》 《相约星期二》 《数学原理》罗素 《源氏物语》《活着本来单纯》《丰子恺文集》 《社会性动物》 《理解人性》阿德勒 《怪诞心理学》 《陈丹青音乐笔记》 《艺术创造学》 《道德情操论》 《逃避自由》 《怪诞行为学》 《直觉泵和其他思考工具》 《生命是什么》薛定谔 《叔本华思想随笔》 《深入理解计算机系统》 《菊与刀》 《皮肤的秘密》 《偶像的黄昏》 《作为意志和表象的世界》 《纯粹理性批判》 《宪法》 《行政法》 《民法》 《中医基础理论》 《自然哲学之数学原理》 《杨戬-人生长恨水长东》 《精神现象学》我觉得一点没看 《叔本华美学随笔》 《茶花女》 《逻辑学上/下》我怎么一点印象没有 《北京折叠》 《康德哲学选讲-邓晓芒》 《象与骑象人》 《中国-传统与变革》 《当下的力量》 《韩瑜文集》 《现代操作系统》 《Linux内核完全注释》 《偶像的黄昏》 《大学，中庸》 《偶像的黄昏》 《中国文化的深层结构》 《态度改变与社会影响》 《自卑与超越》 《裸猿》 《侠客行》 金庸 《大问题 简明哲学导论》 《丧家狗》 《春秋大义》 《1984》 《悟空传》 《动物农场》 《哥伦比亚的倒影》 《变形记》 《洛丽塔》 《周易参同契》 《我所有的朋友都死了？》 《子不语》 《各自的朝圣路》 《资本论》必没看完 《梦的解析》 《雪中悍刀行》 《木心诗选》 《你应该熟读的中国古诗》 《尼采诗集》 《遇见最美的宋词》 《人间失格》 《瓦尔登湖》 《牛虻》没看 《一个陌生女人的来信》 《闲情偶寄》 《杀死一只知更鸟》 《罗生门》 《我与地坛》 《芥川龙之介作品选集》没印象 《人生哲思录》 《荣格自传》 《无人生还》 《人间草木》 《小王子》 《王尔德诗选》 《诗境浅说》 《忏悔录》 《论人生不平等的起源和基础》 《月亮和六便士》 《简爱》 《苦儿流浪记》 《文学回忆录》《木心谈木心》 《苏东坡传》 《感觉的自然史》 下次继续列"},{"title":"404 Not Found：该页无法显示","date":"2021-11-13T12:48:37.864Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://spcablast.club/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-13T12:48:45.850Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"about/index.html","permalink":"http://spcablast.club/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-11-13T12:49:26.061Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://spcablast.club/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-24T08:25:31.071Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://spcablast.club/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-13T12:49:53.171Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://spcablast.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dailycode","slug":"20211125","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-25T14:55:17.679Z","comments":true,"path":"2021/11/25/20211125/","link":"","permalink":"http://spcablast.club/2021/11/25/20211125/","excerpt":"","text":"###509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1给你 n ，请计算 F(n) 。 12345678910111213141516171819202122232425262728293031class Solution &#123;public://今日吐槽：因为是中午，所以有力气吐槽//人是有限的，精神呀，还是体力呀，精神又包括注意力，记忆力，操控自己做哪件事不做哪件事也需要消耗精神力，体力，只要没睡觉，都在消耗体力//那么既然人是有限的，而一天要完成的活动是有量的，假使这个人的能量恰好或者很难完成所有的活动//这样很容易就能得到一个结论，//先在精神力和体力都充足的时候把一定要完成的事情做完了，在能量消耗过多的时候通过特定的行为恢复一部分能量，比如睡了，吃点//如果还是不能完成所有的活动，那么就一定会放弃一些事情，或者粗略的完成一些事情，否则就到第二天了//以及，我以为的只是我现在以为的 int fib(int n) &#123;//怎么用动态规划的思想做这道题嘞//因为斐波那契数列第三个后，每一个数都是由前两个加起来的到的，所以存在递推关系//关键词：// 边界条件：F(0) = 0, F(1) = 1;这是这个问题的起始点，所有的数都由这两个开始// F(n) = F(n-1) + F(n-2)直到 n == 2// 现在是22点13分，继续// 根据以上的推论，递推公式有了，边界条件有了，就可以写代码了，好了 int i = 2; if(n &lt; 2) return n; //用三个变量存所需的所有变量 long long p = 0, q = 1, r = 2; while(i&lt;=n)&#123; r = p + q; p = q; q = r; i++; &#125; return r; //好了，哪里用了动态规划的思想呢，r = p + q, &#125;&#125;; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int ans = 0; bool arrive(int step)&#123; if(step &lt; 0 ) return false; if(step == 0) &#123; ans += 1; return true; &#125; else if(arrive(step - 1) &amp;&amp; arrive(step - 2)); return true; &#125; int climbStairs(int n) &#123; //我天下无敌了，好了，大概吧 //走一步，或两步一次，到顶 //那就可以从顶开始减，减一或者减二，直到为0. //那边界条件就是n = 0 //每次执行的操作是减一或者减二，可以来个递归，最后n &lt; 0 返回无法到达，n == 0返回可以到达 //int ans = 0; //arrive(n); //return ans; //那我还是太菜了呀，每次从顶上下来是减一或者减二，说明dp[i] = dp[i-1] + dp[i-2],我站在这个台阶，从前一个台阶上来一种，或者是从前2个台阶上来的第二种，有两个状态可以到达我这个状态，每一个状态都有两个状态可以转移过来，就得到了递推公式，那我上面的递归也没问题吧，为什么超时了呢 int p = 0, q = 0, r = 1; for (int i = 1; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r; &#125;&#125;; 今日吐槽：又是无力吐槽的一天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211124","date":"2021-11-23T16:00:00.000Z","updated":"2021-11-24T14:07:12.515Z","comments":true,"path":"2021/11/24/20211124/","link":"","permalink":"http://spcablast.club/2021/11/24/20211124/","excerpt":"","text":"祖父节点值为偶数的节点和给你一棵二叉树，请你返回满足以下条件的所有节点的值之和： 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）如果不存在祖父节点值为偶数的节点，那么返回 0 。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;//笑死，祖父节点，难道要判断一个节点有几个孙子节点，那就可以直接深度嘛，我只要遍历到倒数第二层就完事儿了//o，要孙子节点的值加起来啊，我还以为是加爷爷节点的值int ans = 0;public: void dfs(int gp_val, int p_val, TreeNode* node) &#123; if (!node) &#123; return; &#125; if (gp_val % 2 == 0) &#123; ans += node-&gt;val; &#125; dfs(p_val, node-&gt;val, node-&gt;left); dfs(p_val, node-&gt;val, node-&gt;right); &#125; int sumEvenGrandparent(TreeNode* root) &#123; dfs(1, 1, root); return ans; &#125;&#125;; 二进制表示中质数个计算置位给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 12345678910111213class Solution &#123;public: int countPrimeSetBits(int left, int right) &#123; int a[20] = &#123;0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1&#125;; int res = 0; for (int i = left; i &lt;= right; ++i) &#123; res += a[__builtin_popcount(i)];//还有算整数转二进制数的1的个数的函数，怪了 &#125; return res; &#125;&#125;;//[作者](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/cchao-100de-jian-dan-jie-fa-by-ffreturn-pj11/)","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作和 - 算法题","slug":"vector操作和-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C%E5%92%8C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211123","date":"2021-11-22T16:00:00.000Z","updated":"2021-11-23T12:11:49.828Z","comments":true,"path":"2021/11/23/20211123/","link":"","permalink":"http://spcablast.club/2021/11/23/20211123/","excerpt":"","text":"###1389. 按既定顺序创建目标数组给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。重复上一步，直到在 nums 和 index 中都没有要读取的元素。请你返回目标数组。 题目保证数字插入位置总是存在。 1234567891011class Solution &#123;public: vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) &#123; //这题目可太绕了，在新数组index[i]的值的序号处，插入nums[i] vector &lt;int&gt; r; for (unsigned i = 0; i &lt; nums.size(); ++i) &#123; r.insert(r.begin() + index[i], nums[i]); &#125; return r; &#125;&#125;; ###面试题 05.02. 二进制数转字符串二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 示例1: 输入：0.625 输出：”0.101”示例2: 输入：0.1 输出：”ERROR” 提示：0.1无法被二进制准确表示提示： 32位包括输出中的”0.”这两位。 12345678910111213141516171819class Solution &#123;public: string printBin(double num) &#123; //从2的-1次方开始减，减到2的-32次方，如果中间都大于这个2的多少次放，说明那一次能减，如果有一次减到了0，说明能表示，如果不能，error //那这样就可以从2的-1次方加，能加就加，给个1，不能加给个0，加到2的-32次方，0.1010001 string ans = \"0.\"; while(num != 0)&#123;//怪了，double怎么能判断!=0的 num*=2; if(num&gt;=1)&#123; ans += \"1\"; num -= 1; &#125; else ans+=\"0\"; if(ans.size()&gt;32) return \"ERROR\"; &#125; return ans; &#125;&#125;; 正经吐槽：怎么还能拿double和0 == 的，这合适吗，这一点都不合适，不应该double - 0 &gt; 1.79E+308嘛 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作和 - 算法题","slug":"vector操作和-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C%E5%92%8C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211122","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-22T12:25:56.451Z","comments":true,"path":"2021/11/22/20211122/","link":"","permalink":"http://spcablast.club/2021/11/22/20211122/","excerpt":"","text":"打乱数组给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果 题（吐）解（槽）：这又是数学题，排列组合和概率问题，实现每一位出现其中的数字的概率都相同，可以这样做，也可以每一位随机一个数，再在整体里删了用过的数 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; m_nums; vector&lt;int&gt; origin; Solution(vector&lt;int&gt;&amp; nums) &#123; //copy(m_nums.begin(),nums.begin(),nums.end()); m_nums = nums; origin = nums; &#125; vector&lt;int&gt; reset() &#123; return origin; &#125; vector&lt;int&gt; shuffle() &#123; int temp = 0, index = 0, len = m_nums.size(); for(int i = 0; i &lt; len; i++)&#123; temp = m_nums[i]; index = i + rand() % (len - i); m_nums[i] = m_nums[index]; m_nums[index] = temp; &#125; return m_nums; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */ ###剑指 Offer 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]示例 2： 输入：arr = [0,1,2,1], k = 1输出：[0] 123456789101112class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; sort(arr.begin(),arr.end()); //if(arr.size() == 0) return null; vector&lt;int&gt; ans; for(int i = 0;i &lt; k; i++)&#123; ans.push_back(arr[i]); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211121","date":"2021-11-20T16:00:00.000Z","updated":"2021-11-21T14:56:01.423Z","comments":true,"path":"2021/11/21/20211121/","link":"","permalink":"http://spcablast.club/2021/11/21/20211121/","excerpt":"","text":"###8. 字符串转换整数 (atoi)请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: //我又倒了，我应该学一下怎么写自动机的，或者是正则表达式 //int myAtoi(string s) &#123; //丢空格 //起始是正负号，或者没有 //有数字转数字，没数字返回0 //大于INT_MAX返回INT_MAX小于INT_MIN返回INT_MIN //为什么我用VS和这里结果不一样 // if(s.size() == 0) return 0; // long flag = 1 ,temp = 0, ans = 0; // for(int i =0; i &lt; s.size(); ++i)&#123; // //先都当负数，有正负号存到flag里 // if(s[i] == ' ')&#123; // &#125; // else&#123; // if(s[i] == '+')&#123; // flag = 1; // &#125; // else if(s[i] == '-')&#123; // flag = 0; // &#125; // else if((s[i] - '0')&gt;=0 &amp;&amp; (s[i] - '0')&lt;=9)&#123; // temp = s[i] - '0'; // ans = ans*10 - temp; // &#125; // else // break; // &#125; // &#125; // ans = flag?-ans:ans; // if(ans &gt; INT_MAX) return INT_MAX; // if(ans &lt; INT_MIN) return INT_MIN; // return ans; // &#125; //考虑到各种情况的题解 //这题目不仅要取出数字，还得判断是不是一个正常意义的数字 int myAtoi(string str) &#123; unsigned long len = str.length(); // 去除前导空格 int index = 0; while (index &lt; len) &#123; if (str[index] != ' ') &#123; break; &#125; index++; &#125; if (index == len) &#123; return 0; &#125; int sign = 1; // 处理第 1 个非空字符为正负符号，这两个判断需要写在一起 if (str[index] == '+') &#123; index++; &#125; else if (str[index] == '-') &#123; sign = -1; index++; &#125; // 根据题目限制，只能使用 int 类型 int res = 0; while (index &lt; len) &#123; char curChar = str[index]; if (curChar &lt; '0' || curChar &gt; '9') &#123; break; &#125; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; (curChar - '0') &gt; INT_MAX % 10)) &#123; return INT_MAX; &#125; if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; (curChar - '0') &gt; -(INT_MIN % 10))) &#123; return INT_MIN; &#125; res = res * 10 + sign * (curChar - '0'); index++; &#125; return res; &#125;&#125;; ###908. 最小差值 I给你一个整数数组 nums，请你给数组中的每个元素 nums[i] 都加上一个任意数字 x （-k &lt;= x &lt;= k），从而得到一个新数组 result 。 返回数组 result 的最大值和最小值之间可能存在的最小差值。 示例 1： 输入：nums = [1], k = 0输出：0解释：result = [1]示例 2： 输入：nums = [0,10], k = 2输出：6解释：result = [2,8]示例 3： 输入：nums = [1,3,6], k = 3输出：0解释：result = [3,3,3] or result = [4,4,4] 提示： 1 &lt;= nums.length &lt;= 100000 &lt;= nums[i] &lt;= 100000 &lt;= k &lt;= 10000 123456789101112class Solution &#123;public: int smallestRangeI(vector&lt;int&gt;&amp; nums, int k) &#123; int min = INT_MAX,max = INT_MIN; for(int num :nums)&#123; if(num &lt; min) min = num; if(num &gt; max) max = num; &#125; int ans = max - min - 2*k; return ans&gt;=0?ans:0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211120","date":"2021-11-19T16:00:00.000Z","updated":"2021-11-20T13:50:15.758Z","comments":true,"path":"2021/11/20/20211120/","link":"","permalink":"http://spcablast.club/2021/11/20/20211120/","excerpt":"","text":"###剑指 Offer 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 12345678910111213141516class Solution &#123;public: int fib(int n) &#123; int i &#x3D; 0, j &#x3D; 1, temp, ans; if(n &#x3D;&#x3D; 0) return 0; if(n &#x3D;&#x3D; 1) return 1; for(int k &#x3D; 1; k&lt;n;k++)&#123; ans &#x3D; i + j; temp &#x3D; k; i &#x3D; j; j &#x3D; ans % (1000000007); &#125; ans &#x3D; ans % (1000000007); return ans; &#125;&#125;; ###29. 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3题（吐）解（槽）：这题也太离谱了，我提交了16次，边界情况这么多,以及我写的方法又死了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: int divide(int dividend, int divisor) &#123; &#x2F;&#x2F;被除数为最小值，除数分别为1和-1 if (dividend &#x3D;&#x3D; INT_MIN) &#123; if (divisor &#x3D;&#x3D; 1) &#123; return INT_MIN; &#125; if (divisor &#x3D;&#x3D; -1) &#123; return INT_MAX; &#125; &#125; if(divisor &#x3D;&#x3D; INT_MIN)&#123; if(dividend &#x3D;&#x3D; INT_MIN)&#123; return 1; &#125; return 0; &#125; if(divisor &#x3D;&#x3D; 0 ) return 0; &#x2F;&#x2F;一定要转成负的，因为如果被除数是INT_MIN不好表示 bool flag &#x3D; false; int m_dividend &#x3D; 0, m_divisor &#x3D; 0, ans &#x3D; 0; if(dividend &gt; 0)&#123; m_dividend &#x3D; -dividend; flag &#x3D; !flag; &#125; else m_dividend &#x3D; dividend; if(divisor &gt; 0)&#123; m_divisor &#x3D; -divisor; flag &#x3D; !flag; &#125; else m_divisor &#x3D; divisor; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 vector&lt;int&gt; listDividend &#x3D; &#123;m_divisor&#125;; while(m_dividend - m_divisor &lt;&#x3D; m_divisor)&#123; m_divisor +&#x3D; m_divisor; listDividend.push_back(m_divisor); &#125; for(int i &#x3D; listDividend.size() -1; i&gt;&#x3D;0 ; i--)&#123; if(listDividend[i] &gt;&#x3D; m_dividend)&#123; ans +&#x3D; 1 &lt;&lt; i; m_dividend -&#x3D; listDividend[i]; &#125; &#125; return flag?-ans:ans; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; -1)return -dividend; &#x2F;&#x2F; int ans &#x3D; 0, temp &#x3D; abs(divisor), totle &#x3D; 0, m_dividend &#x3D; abs(dividend); &#x2F;&#x2F; while(m_dividend -totle &gt;&#x3D; temp)&#123; &#x2F;&#x2F; totle +&#x3D; temp; &#x2F;&#x2F; ans++; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if((dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0)) &#x2F;&#x2F; return ans; &#x2F;&#x2F; else &#x2F;&#x2F; return -(ans); &#x2F;&#x2F; long m_dividend &#x3D; abs(dividend), m_divisor &#x3D; abs(divisor); &#x2F;&#x2F; if(divisor &#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D; -1)return -dividend; &#x2F;&#x2F; int temp &#x3D; divisor, itera &#x3D; 1; &#x2F;&#x2F; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F; &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 &#x2F;&#x2F; while(m_divisor &lt; m_dividend)&#123; &#x2F;&#x2F; temp &#x3D; m_divisor; &#x2F;&#x2F; itera++; &#x2F;&#x2F; m_divisor +&#x3D; m_divisor; &#x2F;&#x2F; &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211119","date":"2021-11-18T16:00:00.000Z","updated":"2021-11-20T01:02:59.852Z","comments":true,"path":"2021/11/19/20211119/","link":"","permalink":"http://spcablast.club/2021/11/19/20211119/","excerpt":"","text":"50. Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。 示例 1： 输入：x = 2.00000, n = 10输出：1024.00000示例 2： 输入：x = 2.10000, n = 3输出：9.26100示例 3： 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: double powe(long itera, double x)&#123; double ans &#x3D; 1, temp &#x3D; x; while(itera &gt; 0)&#123; if(itera%2 &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;ans &#x3D; x*temp; ans *&#x3D; temp; &#125; temp &#x3D; temp*temp; itera &gt;&gt;&#x3D; 1; &#125; return ans; &#125; double myPow(double x, int n) &#123; &#x2F;&#x2F;暴力方法超时了 &#x2F;&#x2F; double ans &#x3D; 1.00000; &#x2F;&#x2F; long nplus &#x3D; n; &#x2F;&#x2F; if(nplus &#x3D;&#x3D; 0) return 1; &#x2F;&#x2F; if(abs(abs(x) - ans) &lt;&#x3D; 0.000001) return x; &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; abs(nplus); i++)&#123; &#x2F;&#x2F; ans &#x3D; ans*x; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(nplus&lt;0)&#123; &#x2F;&#x2F; ans &#x3D; 1&#x2F;ans; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return ans; if(n &#x3D;&#x3D; 0) return 1.00000; if(abs(x - 1.00000) &lt; 2.22045e-16) return 1.000; long itera &#x3D; n; double ans; ans &#x3D; powe(abs(itera), x); return itera&gt;0?ans:1&#x2F;ans; &#125; &#125;; 598. 范围求和 II 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 输入:m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释:初始状态, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] 1234567891011class Solution &#123;public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) &#123; int mina &#x3D; m;int minb &#x3D; n; for(int i&#x3D;0;i&lt;ops.size();i++)&#123; mina &#x3D; mina&gt;ops[i][0]?ops[i][0]:mina; minb &#x3D; minb&gt;ops[i][1]?ops[i][1]:minb; &#125; return mina*minb; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"论意欲的自由","slug":"论道德和自由","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-20T02:47:46.296Z","comments":true,"path":"2021/11/18/论道德和自由/","link":"","permalink":"http://spcablast.club/2021/11/18/%E8%AE%BA%E9%81%93%E5%BE%B7%E5%92%8C%E8%87%AA%E7%94%B1/","excerpt":"","text":"论意欲的自由 起因：挪威皇家科学院提出的问题 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是自由的？ 叔本华回答这个问题写了这篇论文 正文： 第一部分，先对几个关键概念定义 1.1自由 (叔本华认为）我们能想到的是：不存在任何起妨碍的作用的东西。根据妨碍的作用之物将自由分为三类： 身体、物质、上的自由 智力上的自由 道德上的自由。 A 身体、物质上的自由指的是不存在任何种类的物质障碍。比如：人和动物没有受到皮带、绳索、监狱、瘫痪等的阻碍，他们的身体与他们的意愿相符，那动物和人就称为自由的。这是原初的，直接的，最常见的涵义。 自由的哲学概念的涵义： B 智力上的自由。智力是动因传递到意识的媒介，智力的区别导致动因是否能准确，清晰的传递到人的意识之中。 C 道德(不是日常通用的那个道德的涵义)上的自由起始： 在人没有受到物质阻碍的情况下，一个人却可以纯粹受动因的制约而不会随心所欲的行事。（动因包括恐吓，许诺，危险等） 若要接受本文的推理过程，那就得接受以上物质上的智力上的和道德上的自由就包括了自由所有的范畴了，但是是吗 引出问题：受到如此制约的人是自由的吗？人的意愿会受到以上动因的影响，那么意愿本身是自由的吗？ 从物质上对自由的制约因素到精神上对自由的制约因继续推理：如此，自由的定义从仅指能否做出行为，到与意愿发生了关联。 这样，自由的定义: 不存在任何起妨碍的作用的东西， 就变成了: 与自己的意愿相符（如果我可以根据自己的意愿行事，那我就是自由的） 这个定义把问题：“我们的意愿本身是自由的吗”变成了废话 因为把自由的定义代入之后就变成了“我们的意愿本身是自由（与自己的意愿相符）的吗” 显然是的，但是没有告诉我们东西。 所以，问题：意愿的背后是否还有原因，意愿是否依赖于其他，意愿本身是自由的吗？为了解决这个问题，需要改变自由的定义。 得出新的自由的定义：自由：不存在任何必然性。 修改后的定义还是一个否定的定义，是前一个定义的抽象涵义 是吗是吗，不存在妨碍和不存在必然性这真的是一个东西？ 必然性： 某一充足原因（根据）引发出结果。（某样东西就是从某一原因引发的结果，我们就会知道这个结果是必然的。比如，逻辑方面，数学方面，物理方面，三角形的角度相同可以得到三角形的边长相同）也就是说，不存在任何必然性，就是不依赖于任何原因，也就是一个人的意愿在外现时，并不受到原因，或者理由的左右和决定，因为否则的话，一个人的意欲活动就不会是自由的，而是必然的了。 问题变成：能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 那么接下来讨论自身意识和人的意欲（意愿）的定义，通过自身意识来定义人的意欲。 1.2 自身意识 定义：对我们自身的意识。 这个定义是相对于我们对于其他事物的意识而言的。作者把意识分成对自身的意识和对其他事物的意识，分界线由自身的定义决定 人认知其他事物的认知功能的形式分为时间，空间，因果律。我们无法使用这些功能得到对自身的意识，只能用来掌握其他事物的客观知识。 认知官能首先是以直观的方式认识、把握这一现实外在世界；然后，认知官 能就反思、琢磨以此方式所获得的直观认识，并把这些认识加工、整理 成概念。在语词的帮助下对这些概念进行无穷尽的组合，就构成了思维活动。在减去了我们总体意识中这绝大部分的内容以后，所剩下的部分 就是对自身的意识. 问题：一个人是怎么意识到自身的？ 回答：自身意识的对象物是始终就是自己的意欲活动。（通过意欲活动感受到自身） 是不是说我们能感受到的关于自己的内容，都是自己的意欲活动。 意欲活动的外现：一切渴望、奋斗、愿望、希冀、怀念、爱恋、高兴、欢庆 等，还有就是不情愿和抗拒的感情，所有的厌恶、反感、害怕、愤怒、 憎恨、悲哀、痛苦，一句话，所有一切的情感和激情。 这些情感和激情都是我们意欲的骚动，我们的意欲要么得到满足，要么无法得到满足，与我们获得或错失我们的欲望之物、忍受或者去掉我们的厌恶之物有关。这些构成了我们内在感觉的对象。 那么可以说，当一个人完全感觉不到外部的世界之后，再没有情绪，他就感觉不到自己了？没有触觉听觉视觉味觉嗅觉 而这些自身意识或者说内在感觉的对象，和外在世界存在着联系。我们在外在世界的察觉的对象，是诱发上述活动的动因和材料。 这里把自身意识和外在世界联系起来了，联系关系是外在世界诱发自身意识的活动。 2.1意欲和自身意识的关系 当一个人意欲着，他就是意欲着某一对象物。意欲活动是我们自身意识的对象，某一事物进入到我们对其他事物的意识，意欲活动产生了。 >前半句算结论还是算假设呢，或者是即将被证明的假设？ 动因： 上一句的某一事物在与我们认知官能的关系中，被称为动因,也是意欲活动的素材。意欲活动的目标就是对动因产生反应。意欲活动的本质就在这个反应之中。得出结论:没有动因，意欲活动就不会产生 问题：如果这些事物进入到我们对其他事物的意识里，意欲活动是否必然发生？发生的意欲活动一定是一样的吗？也就是，意欲会不会对这些事物有所反应？在完全一样的条件下，意欲能否有彼此相反的反应？也就是说，意欲活动会由动因必然引起吗？ 自由不自由就在这了，如果一个动因对应一个意欲活动，那人就不是自由的了当动因进入意识的时候，意欲是否保留着活动或者不活动的完全自由？ 回顾问题： 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 因为人对自身的意识 = 意欲活动，而意欲是由人对外部的意识引起的，对自身的意识不包含人对外部的意识，所以光凭人对自身的意识是不足以的得到问题的答案的。 人的自身的意识关于意欲活动的感受大致是： 我可以做我意欲要做的事。这句话真正的含义是，我们能做出与意欲相符的事。而我们无法意识到意欲的产生，只能感受到意欲产生之后，我们这么做了。无法说明我们的意欲活动的产生是否依赖于外在世界。 自身意识能感受意欲活动和操作身体。*还在酝酿过程中的是愿望，酝酿结束了的叫决定，在做出行为之后，这一行为才向自身意识表明这是决定，因为在付诸行动之前，愿望是能改变的。人们可以有相反的愿望，却只能意欲其中之一，因为到底意欲什么，只能通过做出的行动才让自身已是知道。 自身意识只包含了意欲活动，却不包含决定意欲活动的原因和理由（原因和理由在对其他事物的意识里） 那么问题就变成了： 一个人是否也和世界上的所有其他事物一样，由于自己的构成而从此成为一个明确的存在物，并且就像大自然的所有其他存在物一样，有着自己确定永恒的素质；这些素质随着外在机会的出现而必然作出反应；因此，这些素质从这方面看都带有其不变的特性（性格）；所以，这些素质以及那些可作些微调整的东西，是完全听任外在机会和诱因的限定和左右？抑或人类惟独就是大自然的例外？ 动因在进入人的意识之后，是否通过这个人的性格的处理，输出一个确定的结果，形成一个唯一的确定的意欲活动？他想说的是我可以这样做，也可以完全相反的那么做，但是由于我个人的性格，我最后只会选择一个确定的行为。 一个人的意欲就是他本身，这个人存在的真正内核。人的意欲构成了人的意识的基础。他就是想说人的性格是确定的，不变的，天生的，后天的经验无法改变一个人的性格， 3.1意欲和我们对其他的意识 让我们观察那些受意欲驱使着的意欲生物。把因果律的原因分为三种：原因，刺激，动因3.1.1原因指的是机械的物理的化学的变化3.1.2刺激指的是适当的刺激引起相应的变化//那个时候的科学不太行，这俩都不是很合适3.1.3动因以认知为媒介的因果作用。动物的活动随着动因展开，在动物的自身意识中由动因引起的内在动力叫做意欲。 人的行为动因大多是思想和念头，目前时空形成的的动因不多。所有的动因都是原因，所有的因果都有其必然性。 举个例子：我可以做出我所意欲的事情。如果我意欲（愿意）的话，我可以把我所拥有的一切捐献给穷人，以致自己也成为穷人中的一员——如果我意欲（愿意）的话！但我却无法真有这样的意欲，因为与此相反的动因 对我产生了太强有力的作用。而如果我的性格是另外一种样子，甚至是一个圣人，那我就会有捐献所拥有的一切的意欲。我真要是这样的圣人，那我就不这样意欲也不行。也就是说，我就必然要这样做。所有这些都与自身意识中的表白“我可以做出我所意欲的事情”并行不悖。 *性格首要决定了各种不同的动因在某一个人 身上的作用方式，因为动因所引出的所有结果，其基础根源是性格，正如由最狭窄意义上的原因所引出的结果，其基础根源是普遍自然力，由 刺激所引出的结果，其基础根源是生命力一样。与自然力一样，性格同样是原初的、无法改变的和无法解释的。 每个人的性格不一样； 性格是在经验之后才能了解到的； 性格是持续如一的； 性格是与生俱来的；人由于自己的性格始终不渝的追求自己的目标，性格无法改变，能通过改变他的认知改变他追求这个目标的方法和手段。 有什么用呢，比如我以为明天能早起，我下定决心等会儿去跑步，我以为我到了那个点就会去跑步，而事实上，根据我的性格，也就是意欲，也就是那个使我不同与其他人的那个事物，决定了我等会儿并不会去跑步，而是回去坐着。那这个又有什么用呢，可以根据我的性格，设置一个行为，比如走在路上突然跑起来，我就会跑回去（因为我的性格是万事开头难，开了个头就会想做完，做完了或者受到不可抗力打断才会中断），跑着跑着跑到楼下就算热好身了，甚至还有可能会练一会别的。 结论怎么来的呢，不知道，我在中途绕进去了，建议看原文结论：有了既定的动因和确定的性格，那么必然引出一定的行为结果。所有发生的事情，无论大小，都是必然地发生。 这些结论可以给作者提供平静和安慰，我觉得这样就少了人定胜天的那种感觉，既然胜天都是注定了，那么胜天也就没有失去了应该有的那种感觉。 4.1先行者列举了一些历史上对这个问题发表过意见的伟人。顺便骂了几个人（比如黑格尔）命运引领情愿者，单但拖曳不情愿的人。 –伏尔泰所以，我们可以承认：如果我们真有可能对一个人的思维方式——这通过内在和外在的行为呈现出来——有一深刻的了解，清楚 知道这个人行为后面的每一或大或小的推动力，以及所有能够影响 这个人的思维方式的外在诱因，那我们就像可以确切计算出在何时 日食、月食一样地确切计算出一个人将来的行为。 –康德 这证实了这一已得到人们承认和赞扬的格言：在科学的探索中，我们都要尽可能地精准和诚实，不受干扰地走自己的路；不要 担心自己的探索是否有可能与这一学科以外的事情相抵触，而要尽我们所能真实、完美地把这一探索工作本身进行到底。我经常看到 的情形让我确信：当我们的探索工作完结以后，那在探索进行过程 中，在考虑到其他领域的学说时，有些东西有时候会显得大有疑 问；但只要我把这些疑问置之不理，心无旁骛地专注于自己的探索 直至完成，那原先似乎大有疑问的东西，却出乎预料地与在丝毫没 有顾虑到别人的学说、对那些东西既没有先入为主的偏好也没有偏 恶的情况下，所独自发现的东西完全吻合。只要著作者能够下定决 心，更加诚实地投入工作中去，那他们就会避免犯下许多的错误， 避免无谓浪费那么多的精力。（《实践理性批判》第四版，190 页） –康德 哲学家的武器是事实的理据，而不是权威的言论。（由于我没有跟上他的思路推出来结论，只能放点结论了） *“他是个坏人，是个恶棍，或者“这是个无赖，或者“他是个渺小、下作、虚假的 人，等等。这就是人们的判定；人们的指责总是针对这个人的性格。 做出的行为连带其动因，纯粹只是表明行为人的性格的证据而已；行为只是这个人的性格的外相，而这个人的性格已是永远和无法逆转地确定了下来。所以，亚里士多德说得很对，“我们赞扬做出了某一行为的 人，但那些行为只是显示了做出行为的人的性格而已。就算是行为还没 有做出来，但只要我们相信这个人会做出这样的行为，那我们仍然会赞 扬这个人。因此，引起我们厌恶、鄙视和憎恨的，并不是那瞬间就过 去了的行为，而是做出这些行为的人身上那些永远存在的素质，亦即性格。因此，在所有的语言里，形容道德败坏的词语、标示劣性的绰号都 是对人更甚于对事，因为性格才应该承担罪责，而这罪责只是因为有了 机会才通过做出行为得到证实。结论： 一个人永远只做出他所意欲（愿）的行为，但他做出这样的行为其实是必然的。原因全在于这个人已经就是他所意欲：因为只要这个人是这样的人，那必然就会做出所有这样的事情。如果我们客观（体）考察这个人的行事，亦即从外在考察这些所为，那我们就会确实 无疑地认出：这些行为和大自然每一存在物的发挥是一样的，都是严格 受制于因果法则。从主观（体）上看，每个人都感觉自己总是按照自己 的意欲行事。但这只说明了他的发挥（行为），只是他自身本质的纯粹外现而已。所以，大自然的每一存在物，甚至最低级的一类，都会有这同一样的感觉——如果它们能够感觉的话。//我是我 再贴一段： 因此，大致上而言，所有在当事人当时不知道自己在干什么或者完全没有能力考虑到制止这样做的理由，亦即在没有能力考虑到事情后果 的情况下所犯下的罪行，都可视为在欠缺智力自由的情况下的犯罪。因 此，这种情形的犯罪，犯罪者是不应受到惩罚的。 但如果人们认为：由于没有道德上的自由，因此，一个人做出某种行为是不可避免的，所以，犯下罪行的人不应该受到惩罚，那他们可是 理解错了刑罚的目的。也就是说，他们误以为对罪犯实施惩罚是因为罪 行本身的缘故，是基于道德理由的以牙还牙的报复。虽然康德也教导这 样的观点，但这样的惩罚却是荒谬的、没有任何目的的、绝对是没有任 何理由的。这是因为一个人又有何权利以绝对法官自居去判断他人的道 德，并因为他人的罪过而对其加以折磨！其实，法律——亦即威胁给予 惩罚——目的却是要成为制止人们将来犯罪的相反动因。如果在某些情 形里，法律起不到这样的制约作用，那也得执行法律，因为如果法律得 不到实行，那在将来的所有情形里，法律都将无法再发挥制约的作用。 在罪犯方面，罪犯在这种情况下遭受惩罚是自己的道德品质所致——罪 犯自己的道德品质与那外在环境的动因，再加上误导自己让自己以为可 以侥幸逃脱惩罚的智力，三者结合起来，不可避免地促成了犯罪。在这 种情况下，只有当事人的道德性格并不是这个人自己的作品，并不是认 知的行为，而是他人的作品，那他遭受惩罚才是不公正的。如果一个人 罪恶行为的结果并不是人为的，而是遵循大自然的规则，那行为与其后 果也是一样的关系。例如，如果因放肆纵欲而导致疾病，又或者，如果 一个人在夜间闯入别人的猪圈，试图盗走里面的猪，但却碰上碰巧在这过夜的主人寄宿在这猪圈里的大熊。 既然一切都是确定的，那么对于个人来说，只知道是确定的而不知道确定的内容是什么，那么未来就还是未知的，只不过能更加平静地对待以后会发生的一切事情，和以往发生的一切事情，因为都是注定的，人的性格决定了他知道了一切都是确定的之后会做出的反应。 上面对自身的意识和对外界的意识分的比较怪，可能是为了方便论证。 论文里还有点对道德和良心的论述，因为性格是确定的，所以善恶也确定了，良心是事情发生后对事情的反思。//由于后面跟不上了，只能贴很多原文，建议看原文，100页左右。","categories":[],"tags":[],"author":"YP"},{"title":"Dailycode","slug":"20211118","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:55:18.810Z","comments":true,"path":"2021/11/18/20211118/","link":"","permalink":"http://spcablast.club/2021/11/18/20211118/","excerpt":"","text":"###48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 题（吐）解（槽）：今天无力吐槽，干活 123456789101112131415161718192021class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#x2F;&#x2F;外圈到内圈轮流换位置 &#x2F;&#x2F;圈数等于n&#x2F;2 &#x2F;&#x2F;1 1 &#x2F;&#x2F; &#x2F;&#x2F;3 4 &#x2F;&#x2F;转起来（0+1，0）（0+1，n-1）(n-1,n-1-1)(0,n-1-1) int n &#x3D; matrix.size(); for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123; for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; ++j) &#123; int temp &#x3D; matrix[i][j]; matrix[i][j] &#x3D; matrix[n - j - 1][i]; matrix[n - j - 1][i] &#x3D; matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] &#x3D; matrix[j][n - i - 1]; matrix[j][n - i - 1] &#x3D; temp; &#125; &#125; &#125;&#125;; ###771. 宝石与石头 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 字母区分大小写，因此 “a” 和 “A” 是不同类型的石头。 示例 1： 输入：jewels = “aA”, stones = “aAAbbbb”输出：3示例 2： 输入：jewels = “z”, stones = “ZZ”输出：0 123456789101112131415class Solution &#123;public: int numJewelsInStones(string jewels, string stones) &#123; int ans &#x3D; 0; for(int i &#x3D; 0;i&lt;jewels.size();i++)&#123; int cur &#x3D; jewels[i] - &#39;0&#39;; for(int j &#x3D; 0; j&lt;stones.size();j++)&#123; if(stones[j] - &#39;0&#39; &#x3D;&#x3D; cur)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"ffmpeg操作","slug":"ffmpeg操作","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:57:41.824Z","comments":true,"path":"2021/11/18/ffmpeg操作/","link":"","permalink":"http://spcablast.club/2021/11/18/ffmpeg%E6%93%8D%E4%BD%9C/","excerpt":"","text":"ffmpeg.exe -i aa.mp4 -y -f image2 -ss 8 -t 0.01 -s 800x600 test.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpgffmpeg -i test.mp4 -r 30 -t 4 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 -vframes 10 image-%3d.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpg -i file name-r frame/s-f ..F… set commands file-ss time_off set the start time offset-t duration record or transcode “duration” seconds of audio/video","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"-ffmpeg命令行操作","slug":"ffmpeg命令行操作","permalink":"http://spcablast.club/tags/ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"}],"author":"YP"},{"title":"VSCode","slug":"VScode的配置","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-20T00:47:46.999Z","comments":true,"path":"2021/11/18/VScode的配置/","link":"","permalink":"http://spcablast.club/2021/11/18/VScode%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"最近要 机器 学习了，down个VSCode用用 pip install flake8装了个flake8,获得了语法提示 pip install yapf装个yapf，Alt+Shift+F可以自动化格式代码 setting.json设置一下 123456&#123; \"workbench.colorTheme\": \"Default Dark+\", \"python.defaultInterpreterPath\": \"C:\\\\Program Files\\\\Python39\\\\python.exe\", \"python.linting.flake8Enabled\": true, \"python.formatting.provider\": \"yapf\"&#125;","categories":[{"name":"VSCode","slug":"VSCode","permalink":"http://spcablast.club/categories/VSCode/"}],"tags":[],"author":"YP"},{"title":"Dailycode","slug":"20211117","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T13:42:26.191Z","comments":true,"path":"2021/11/17/20211117/","link":"","permalink":"http://spcablast.club/2021/11/17/20211117/","excerpt":"","text":"###1552. 两球之间的磁力在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 题解：干啊，思路有了，写出来还差一点 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool legal(int m, vector&lt;int&gt;&amp; position, int k)&#123; int pre &#x3D; position[0], count &#x3D; 1; for(int i &#x3D; 0;i &lt; position.size();++i)&#123; if(position[i] - pre &gt;&#x3D; m)&#123; pre &#x3D; position[i]; count++; &#125; &#125; if(count &gt;&#x3D; k) return true; else return false; &#125; int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; &#x2F;&#x2F;又是数学题，gan啊 &#x2F;&#x2F;阅读理解：数轴上n点，position[i], 激活m个点，找到使得m个点中每两个点的距离都尽可能的大的位置 &#x2F;&#x2F;既然这样，首尾两个球肯定是要用的，然后求中间的值，看最接近的是哪个，这样就有两段，分别取中值，找最接近的，比较四段长度 &#x2F;&#x2F;那我岂不是可以排序，然后求出所有的间隔，由大到小，不行 &#x2F;&#x2F;好像懂了，太顶了，直接找答案，答案就在0到最大值减去最小值，然后对这个值进行二分查找，存在m个长度的段大于等于这个值就对了，多于m个说明这个值可以加，小于m说明这个值得减 sort(position.begin(),position.end()); int l &#x3D; position.size(); int dis &#x3D; position[l -1] - position[0]; int left &#x3D; 1, right &#x3D; dis, prelen &#x3D; 0, ans &#x3D; -1; while(left &lt;&#x3D; right)&#123; int mid &#x3D; (right + left) &#x2F;2; if(legal(mid, position, m))&#123;&#x2F;&#x2F;如果有m个大于等于len，说明m小了 ans &#x3D; mid; left &#x3D; mid + 1; &#125; else&#123; right &#x3D; mid - 1; &#125; &#125; return ans; &#125;&#125;; ###169. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：[3,2,3]输出：3示例 2： 输入：[2,2,1,1,1,2,2]输出：2 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 题解： 123456789101112131415161718192021222324252627class Solution &#123;public: &#x2F;&#x2F;这题我见过，用哈希map吧，map好像还行，不如哈希 &#x2F;&#x2F;进阶挺难的 int majorityElement(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F; unordered_map&lt;int, int&gt; counts; &#x2F;&#x2F; int majority &#x3D; 0, cnt &#x3D; 0; &#x2F;&#x2F; for (int num: nums) &#123; &#x2F;&#x2F; ++counts[num]; &#x2F;&#x2F; if (counts[num] &gt; cnt) &#123; &#x2F;&#x2F; majority &#x3D; num; &#x2F;&#x2F; cnt &#x3D; counts[num]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return majority; unordered_map&lt;int,int&gt; map; int ans &#x3D; 0, count &#x3D; 0; for(int num:nums)&#123; ++map[num]; if(map[num] &gt; count)&#123; ans &#x3D; num; count &#x3D; map[num]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211116","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-17T04:57:58.142Z","comments":true,"path":"2021/11/16/20211116/","link":"","permalink":"http://spcablast.club/2021/11/16/20211116/","excerpt":"","text":"###67. 二进制求和给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100”示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。1 &lt;= a.length, b.length &lt;= 10^4字符串如果不是 “0” ，就都不含前导零。 题解分四种情况不如官方题解直接分两种情况，优化代码，不可能优化的，字符串的操作还得多学 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; &#x2F;&#x2F;先把字符串倒过来，用两个数存长度， &#x2F;&#x2F;a &#x3D; a.reverse(); &#x2F;&#x2F;b &#x3D; b.reverse(); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans; int acc &#x3D; 0; char tempa, tempb; int la &#x3D; a.size(), lb &#x3D; b.size(); for(int i &#x3D; 0; (i &lt; la || i &lt; lb); i++)&#123; if(i&lt;la) tempa &#x3D; a[i]; else tempa &#x3D; &#39;0&#39;; if(i&lt;lb) tempb &#x3D; b[i]; else tempb &#x3D; &#39;0&#39;; if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 3) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 2) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 1) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 0; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 0) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 0; &#125; &#125; if(acc &#x3D;&#x3D; 1)&#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(),ans.end()); return ans; &#125;&#125;; 看看人家 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int n &#x3D; max(a.size(), b.size()), carry &#x3D; 0; for (size_t i &#x3D; 0; i &lt; n; ++i) &#123; carry +&#x3D; i &lt; a.size() ? (a.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; carry +&#x3D; i &lt; b.size() ? (b.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; ans.push_back((carry % 2) ? &#39;1&#39; : &#39;0&#39;); carry &#x2F;&#x3D; 2; &#125; if (carry) &#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-binary&#x2F;solution&#x2F;er-jin-zhi-qiu-he-by-leetcode-solution&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ###299. 猜数字游戏链接你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数字和朋友猜测的数字都可能含有重复数字。 示例 1: 输入: secret = “1807”, guess = “7810”输出: “1A3B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1807” |“7810”示例 2: 输入: secret = “1123”, guess = “0111”输出: “1A1B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1123” “1123” | or |“0111” “0111”注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。 题解（吐槽）：中等题的难度也是有区别的，这个算简单吧，而且阅读理解可能是大问题，阅读理解对了之后就是怎么把已知信息用算法表现出来了，欸，思想，就是思想。优化，是不可能优化的，就是从这里跳下去，我也不会优 12345678910111213141516171819class Solution &#123;public: string getHint(string secret, string guess) &#123; &#x2F;&#x2F;简单的方法应该是遍历一遍，把公牛数字找出来，不如排序，或者用map，0到9分别有几个，对应数量相减，再减去公牛数字就是奶牛数字个数，直接用数组就行了 int cow &#x3D; 0, bull &#x3D; 0; int counts[10] &#x3D; &#123;0&#125;,countg[10] &#x3D; &#123;0&#125;; for(int i &#x3D; 0;i &lt; secret.size();++i)&#123; if(secret[i] &#x3D;&#x3D; guess[i]) bull++; else&#123; counts[secret[i] - &#39;0&#39;]++; countg[guess[i] - &#39;0&#39;]++; &#125; &#125; for(int i &#x3D; 0;i&lt;10;i++)&#123; cow +&#x3D; min(countg[i],counts[i]); &#125; return to_string(bull) + &#39;A&#39; + to_string(cow)+&#39;B&#39;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211115","date":"2021-11-14T16:00:00.000Z","updated":"2021-11-17T08:47:50.068Z","comments":true,"path":"2021/11/15/20211115/","link":"","permalink":"http://spcablast.club/2021/11/15/20211115/","excerpt":"","text":"###264. 丑数 II给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10输出：12解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 123456789&#x2F;&#x2F;没人比我更懂暴力算法.jpgint all[] &#x3D; &#123;1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400&#125;;class Solution &#123;public: int nthUglyNumber(int n) &#123; return all[n-1]; &#125;&#125;; #######正常解法 12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] &#x3D; 1; int p2 &#x3D; 1, p3 &#x3D; 1, p5 &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; int num2 &#x3D; dp[p2] * 2, num3 &#x3D; dp[p3] * 3, num5 &#x3D; dp[p5] * 5; dp[i] &#x3D; min(min(num2, num3), num5);&#x2F;&#x2F;取个最小的保证顺序 if (dp[i] &#x3D;&#x3D; num2) &#123;&#x2F;&#x2F;pi++的意思是这个数乘了2还是最小的，其他的数乘了3，5应该加到下一个了 p2++; &#125; if (dp[i] &#x3D;&#x3D; num3) &#123; p3++; &#125; if (dp[i] &#x3D;&#x3D; num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 那我只能说，我不理解，到底该谁乘2，谁乘3，谁乘5，乘几次啊 ###剑指 Offer II 069. 山峰数组的顶部符合下列属性的数组 arr 称为 山峰数组（山脉数组） ： arr.length &gt;= 3存在 i（0 &lt; i &lt; arr.length - 1）使得：arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。 示例 1： 输入：arr = [0,1,0]输出：1示例 2： 输入：arr = [1,3,5,4,2]输出：2 1234567891011class Solution &#123;public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) &#123; int max &#x3D; arr[0]; for(int i&#x3D;1;i&lt;arr.size();++i)&#123; if(arr[i] &lt; max) return i - 1; max &#x3D; arr[i]; &#125; return 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211114","date":"2021-11-13T16:00:00.000Z","updated":"2021-11-17T08:47:58.276Z","comments":true,"path":"2021/11/14/20211114/","link":"","permalink":"http://spcablast.club/2021/11/14/20211114/","excerpt":"","text":"###455. 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 1234567891011121314151617181920class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; int totol &#x3D; 0; sort(g.begin(),g.end());&#x2F;&#x2F;默认由小到大排序 sort(s.begin(),s.end()); int j &#x3D; 0; for(int i &#x3D; 0; i&lt; g.size();++i)&#123; while(j &lt; s.size())&#123; if(s[j] &gt;&#x3D; g[i]) &#123; totol++; j++; break; &#125; else j++; &#125; &#125; return totol; &#125;&#125;; ###剑指 Offer 56 - I. 数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;我只能说，NB，这方法，顶 int ret &#x3D; 0; for (int n : nums) ret ^&#x3D; n; int div &#x3D; 1; while ((div &amp; ret) &#x3D;&#x3D; 0) div &lt;&lt;&#x3D; 1; int a &#x3D; 0, b &#x3D; 0; for (int n : nums) if (div &amp; n) a ^&#x3D; n; else b ^&#x3D; n; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211113","date":"2021-11-12T16:00:00.000Z","updated":"2021-11-17T08:48:03.461Z","comments":true,"path":"2021/11/13/20211113/","link":"","permalink":"http://spcablast.club/2021/11/13/20211113/","excerpt":"","text":"###面试题 10.11. 峰与谷在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。 示例: 输入: [5, 3, 1, 2, 3]输出: [5, 1, 3, 2, 3] 1234567891011121314151617181920212223242526272829class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; vers(nums); int left &#x3D; 0, right &#x3D; nums.size()-1, len &#x3D;nums.size(); sort(vers.begin(),vers.end()); int index &#x3D; 0; while(left &lt; right)&#123; nums[index++] &#x3D; vers[left++]; nums[index++] &#x3D; vers[right--]; &#125; if(nums.size()%2 !&#x3D; 0) nums[index] &#x3D; vers[left]; &#x2F;&#x2F;这个回答和我有缘，想到一块去了 &#x2F;&#x2F; size_t idx &#x3D; 0, len &#x3D; nums.size(); &#x2F;&#x2F; if (len &lt; 3) return; &#x2F;&#x2F; size_t low &#x3D; 0, high &#x3D; len - 1; &#x2F;&#x2F; vector&lt;int&gt; sorted(nums); &#x2F;&#x2F; sort(sorted.begin(), sorted.end()); &#x2F;&#x2F; while (low &lt; high) &#123; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[high--]; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[low++]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if (len % 2 &gt; 0) nums[idx] &#x3D; sorted[low]; &#x2F;&#x2F; 作者：gfu &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;peaks-and-valleys-lcci&#x2F;solution&#x2F; bi-jiao-zhi-guan-de-xiang-fa-xian-pai-xu-by-gfu&#x2F; &#x2F;&#x2F; 来源：力扣（LeetCode） &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; ###13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: int romanToInt(string s) &#123; int lastNum &#x3D; 0, totol &#x3D; 0; for(int i &#x3D; 0; i&lt; s.length();i++)&#123; if(s[i] &#x3D;&#x3D; &#39;I&#39;)&#123; lastNum &#x3D; 1; totol +&#x3D; 1; &#125; else if(s[i] &#x3D;&#x3D; &#39;V&#39;)&#123; if(lastNum &lt; 5)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 5; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 5; totol +&#x3D; 5; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;X&#39;)&#123; if(lastNum &lt; 10)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 10; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 10; totol +&#x3D; 10; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;L&#39;)&#123; if(lastNum &lt; 50)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 50; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 50; totol +&#x3D; 50; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;C&#39;)&#123; if(lastNum &lt; 100)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 100; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 100; totol +&#x3D; 100; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;D&#39;)&#123; if(lastNum &lt; 500)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 500; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 500; totol +&#x3D; 500; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;M&#39;)&#123; if(lastNum &lt; 1000)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 1000; totol +&#x3D;lastNum; &#125; else totol +&#x3D; 1000; &#125; &#125; return totol; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211112","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-17T08:48:08.786Z","comments":true,"path":"2021/11/12/20211112/","link":"","permalink":"http://spcablast.club/2021/11/12/20211112/","excerpt":"","text":"###5. 最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 Solution &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public: void len(int * result, int i, int j, string s)&#123; if(i!&#x3D;j &amp;&amp; s[i] !&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; i; &#125; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; j; --i; ++j; &#125; return; &#125; string longestPalindrome(string s) &#123; if(s.length() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; int maxLen[2], maxi, maxL; int start &#x3D; 0, end &#x3D; 0; int index1[2],index2[2]; for(int k &#x3D; 0; k &lt; s.length(); ++k)&#123; len(index1, k, k, s); len(index2, k, k+1, s); if(index1[1] - index1[0] &gt; end -start)&#123; start &#x3D; index1[0]; end &#x3D; index1[1]; &#125; if(index2[1] - index2[0] &gt; end -start)&#123; start &#x3D; index2[0]; end &#x3D; index2[1]; &#125; &#125; return s.substr(start, end - start + 1); &#x2F;&#x2F;for(int j &#x3D; k, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; (j+1) &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F;&#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;for(int k &#x3D; 1; k &lt; s.length(); ++k)&#123; &#x2F;&#x2F; for(int j &#x3D; k+1, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; j &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i] &#x3D;&#x3D; s[j])&#123; &#x2F;&#x2F; if(maxLen &lt;&#x3D; 2)&#123; &#x2F;&#x2F; maxLen &#x3D; 2; &#x2F;&#x2F; maxi &#x3D; j; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;return s.substr(maxi, maxLen); &#125;&#125;; ###14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1： 输入：strs = [“flower”,”flow”,”flight”]输出：”fl” 123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; string ans &#x3D; strs[0]; for(int j &#x3D; 0; j &lt; strs.size() ; ++j )&#123; int i &#x3D; 0; for(; i &lt;&#x3D; strs[0].length() &amp;&amp; i &lt; ans.length(); ++i)&#123; if(ans[i] !&#x3D; strs[j][i])&#123; break; &#125; &#125; if(ans.length() &#x3D;&#x3D; 0) return &quot;&quot;; ans &#x3D; strs[0].substr(0,i); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211111","date":"2021-11-10T16:00:00.000Z","updated":"2021-11-17T08:48:14.096Z","comments":true,"path":"2021/11/11/20211111/","link":"","permalink":"http://spcablast.club/2021/11/11/20211111/","excerpt":"","text":"###1785. 构成特定和需要添加的最少元素给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 1234567891011121314151617class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long long int sum &#x3D; 0; for(int num:nums)&#123; sum +&#x3D; num; &#125; if(sum &#x3D;&#x3D; goal) return 0; if(abs(sum - goal) &lt; abs(limit))&#123; return 1; &#125; if(abs(sum - goal) % abs(limit) &#x3D;&#x3D; 0 )&#123; return abs(sum - goal) &#x2F; abs(limit); &#125; else return abs(sum - goal) &#x2F; abs(limit) + 1; &#125;&#125;; ###剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left) , maxDepth(root-&gt;right)) +1; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-17T08:48:20.645Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211109","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-17T08:48:25.246Z","comments":true,"path":"2021/11/09/20211109/","link":"","permalink":"http://spcablast.club/2021/11/09/20211109/","excerpt":"","text":"###1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans(2,0); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int temp &#x3D; target - nums[i]; &#x2F;&#x2F;if( temp &lt; 0 ) continue; for(int j &#x3D; i+1; j &lt;nums.size(); ++j)&#123; if(temp &#x3D;&#x3D; nums[j] )&#123; ans[0] &#x3D; i; ans[1] &#x3D; j; return ans; &#125; &#125; &#125; return ans; &#125;&#125;;&#x2F;&#x2F;我就说哈希表好嘛，虽然我不会 ###198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 1234567891011121314151617181920class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1)&#123; return nums[0]; &#125; if(nums.size() &#x3D;&#x3D; 2)&#123; return max(nums[0],nums[1]); &#125; vector&lt;int&gt; ma(nums.size()+1, 0); ma[0] &#x3D; nums[0]; ma[1] &#x3D; max(nums[0], nums[1]); int maxNum &#x3D; 0; for(int i &#x3D; 2; i &lt; nums.size(); i++)&#123; maxNum &#x3D; nums[i]; ma[i] &#x3D; max(ma[i - 1], ma[i -2] + maxNum ); &#125; return ma[nums.size() - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211108","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-17T08:48:31.915Z","comments":true,"path":"2021/11/08/20211108/","link":"","permalink":"http://spcablast.club/2021/11/08/20211108/","excerpt":"","text":"###1105. 填充书架附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; &#x2F;&#x2F;我大受震撼，且我不理解，下次让我做我还不会 &#x2F;&#x2F; vector&lt;int&gt; d(books.size()+1,INT_MAX); &#x2F;&#x2F; d[books.size()] &#x3D; 0; &#x2F;&#x2F; for(int i &#x3D; books.size() - 1; i &gt;&#x3D; 0 ; --i)&#123; &#x2F;&#x2F; int MaxHeight &#x3D; 0; &#x2F;&#x2F; int leftWith &#x3D; shelfWidth; &#x2F;&#x2F; for(int j &#x3D; i; j &lt; books.size() &amp;&amp; leftWith &gt; books[j][0]; ++j)&#123; &#x2F;&#x2F; MaxHeight &#x3D; max(books[j][1], MaxHeight); &#x2F;&#x2F; d[i] &#x3D; min(MaxHeight + d[j+1],d[i]); &#x2F;&#x2F; leftWith -&#x3D; books[j][0]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return d[0]; vector&lt;int&gt; dp(books.size() + 1, INT_MAX); dp[books.size()] &#x3D; 0; for (int i &#x3D; books.size() - 1; i &gt;&#x3D; 0; --i) &#123; int max_book_height &#x3D; 0; int left_width &#x3D; shelfWidth; &#x2F;&#x2F; 把第 j 本书拿到第 i 本书后面 for (int j &#x3D; i; j &lt; books.size() &amp;&amp; left_width &gt;&#x3D; books[j][0]; ++j) &#123; max_book_height &#x3D; max(max_book_height, books[j][1]); dp[i] &#x3D; min(dp[i], max_book_height + dp[j+1]); left_width -&#x3D; books[j][0]; &#125; &#125; return dp[0];&#125;; ###1822. 数组元素积的符号已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 12345678910111213class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int product = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) product *= -1; &#125; return product; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211107","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-17T08:48:36.580Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211106","date":"2021-11-05T16:00:00.000Z","updated":"2021-11-17T08:48:43.077Z","comments":true,"path":"2021/11/06/20211106/","link":"","permalink":"http://spcablast.club/2021/11/06/20211106/","excerpt":"","text":"###82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。示例 1：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates( ListNode* head) &#123; if(!head) return head; ListNode* singleNode = new ListNode(0,head); ListNode* flagHeader = singleNode; while(flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;next)&#123; if(flagHeader-&gt;next-&gt;val == flagHeader-&gt;next-&gt;next-&gt;val)&#123; int temp = flagHeader-&gt;next-&gt;val; while( flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;val == temp )&#123; flagHeader-&gt;next = flagHeader-&gt;next-&gt;next; &#125; &#125; else&#123; flagHeader = flagHeader-&gt;next; &#125; &#125; return singleNode-&gt;next; &#125;&#125;; ###剑指 Offer 39. 数组中出现次数超过一半的数字 链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //来个map? unordered_map&lt;int, int&gt; myMap; int temp = 0, maxNum = 0; for(int num : nums)&#123; ++myMap[num]; if(myMap[num] &gt; maxNum)&#123; temp = num; maxNum = myMap[num]; &#125; &#125; return temp; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"报的错","slug":"报的错","date":"2021-08-28T01:50:14.674Z","updated":"2021-08-28T01:50:14.776Z","comments":true,"path":"2021/08/28/报的错/","link":"","permalink":"http://spcablast.club/2021/08/28/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2021-07-16T09:14:24.409Z","updated":"2021-04-24T12:07:09.991Z","comments":true,"path":"2021/07/16/Markdown_test/","link":"","permalink":"http://spcablast.club/2021/07/16/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-16T09:14:24.358Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2021/07/16/hello-world/","link":"","permalink":"http://spcablast.club/2021/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"}]}