{"meta":{"title":"YP Blog","subtitle":"咸的博客","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"书单","date":"2021-04-24T08:30:14.020Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-24T08:25:31.069Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""}],"posts":[{"title":"20211113","slug":"20211113","date":"2021-11-13T08:00:17.197Z","updated":"2021-11-13T10:48:13.398Z","comments":true,"path":"2021/11/13/20211113/","link":"","permalink":"http://spcablast.club/2021/11/13/20211113/","excerpt":"","text":"layout: posttitle: Dailycodesubtitle: 20211113date: 2021-11-13author: YPheader-img:catalog: truetags: - 算法题—###面试题 10.11. 峰与谷在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。 示例: 输入: [5, 3, 1, 2, 3]输出: [5, 1, 3, 2, 3] 1234567891011121314151617181920212223242526272829class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; vers(nums); int left &#x3D; 0, right &#x3D; nums.size()-1, len &#x3D;nums.size(); sort(vers.begin(),vers.end()); int index &#x3D; 0; while(left &lt; right)&#123; nums[index++] &#x3D; vers[left++]; nums[index++] &#x3D; vers[right--]; &#125; if(nums.size()%2 !&#x3D; 0) nums[index] &#x3D; vers[left]; &#x2F;&#x2F;这个回答和我有缘，想到一块去了 &#x2F;&#x2F; size_t idx &#x3D; 0, len &#x3D; nums.size(); &#x2F;&#x2F; if (len &lt; 3) return; &#x2F;&#x2F; size_t low &#x3D; 0, high &#x3D; len - 1; &#x2F;&#x2F; vector&lt;int&gt; sorted(nums); &#x2F;&#x2F; sort(sorted.begin(), sorted.end()); &#x2F;&#x2F; while (low &lt; high) &#123; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[high--]; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[low++]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if (len % 2 &gt; 0) nums[idx] &#x3D; sorted[low]; &#x2F;&#x2F; 作者：gfu &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;peaks-and-valleys-lcci&#x2F;solution&#x2F; bi-jiao-zhi-guan-de-xiang-fa-xian-pai-xu-by-gfu&#x2F; &#x2F;&#x2F; 来源：力扣（LeetCode） &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; ###13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: int romanToInt(string s) &#123; int lastNum &#x3D; 0, totol &#x3D; 0; for(int i &#x3D; 0; i&lt; s.length();i++)&#123; if(s[i] &#x3D;&#x3D; &#39;I&#39;)&#123; lastNum &#x3D; 1; totol +&#x3D; 1; &#125; else if(s[i] &#x3D;&#x3D; &#39;V&#39;)&#123; if(lastNum &lt; 5)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 5; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 5; totol +&#x3D; 5; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;X&#39;)&#123; if(lastNum &lt; 10)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 10; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 10; totol +&#x3D; 10; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;L&#39;)&#123; if(lastNum &lt; 50)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 50; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 50; totol +&#x3D; 50; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;C&#39;)&#123; if(lastNum &lt; 100)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 100; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 100; totol +&#x3D; 100; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;D&#39;)&#123; if(lastNum &lt; 500)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 500; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 500; totol +&#x3D; 500; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;M&#39;)&#123; if(lastNum &lt; 1000)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 1000; totol +&#x3D;lastNum; &#125; else totol +&#x3D; 1000; &#125; &#125; return totol; &#125;&#125;;","categories":[],"tags":[]},{"title":"Dailycode","slug":"20211112","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-13T10:48:51.071Z","comments":true,"path":"2021/11/12/20211112/","link":"","permalink":"http://spcablast.club/2021/11/12/20211112/","excerpt":"","text":"###5. 最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 Solution &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public: void len(int * result, int i, int j, string s)&#123; if(i!&#x3D;j &amp;&amp; s[i] !&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; i; &#125; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; j; --i; ++j; &#125; return; &#125; string longestPalindrome(string s) &#123; if(s.length() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; int maxLen[2], maxi, maxL; int start &#x3D; 0, end &#x3D; 0; int index1[2],index2[2]; for(int k &#x3D; 0; k &lt; s.length(); ++k)&#123; len(index1, k, k, s); len(index2, k, k+1, s); if(index1[1] - index1[0] &gt; end -start)&#123; start &#x3D; index1[0]; end &#x3D; index1[1]; &#125; if(index2[1] - index2[0] &gt; end -start)&#123; start &#x3D; index2[0]; end &#x3D; index2[1]; &#125; &#125; return s.substr(start, end - start + 1); &#x2F;&#x2F;for(int j &#x3D; k, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; (j+1) &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F;&#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;for(int k &#x3D; 1; k &lt; s.length(); ++k)&#123; &#x2F;&#x2F; for(int j &#x3D; k+1, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; j &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i] &#x3D;&#x3D; s[j])&#123; &#x2F;&#x2F; if(maxLen &lt;&#x3D; 2)&#123; &#x2F;&#x2F; maxLen &#x3D; 2; &#x2F;&#x2F; maxi &#x3D; j; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;return s.substr(maxi, maxLen); &#125;&#125;; ###14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1： 输入：strs = [“flower”,”flow”,”flight”]输出：”fl” 123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; string ans &#x3D; strs[0]; for(int j &#x3D; 0; j &lt; strs.size() ; ++j )&#123; int i &#x3D; 0; for(; i &lt;&#x3D; strs[0].length() &amp;&amp; i &lt; ans.length(); ++i)&#123; if(ans[i] !&#x3D; strs[j][i])&#123; break; &#125; &#125; if(ans.length() &#x3D;&#x3D; 0) return &quot;&quot;; ans &#x3D; strs[0].substr(0,i); &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211111","date":"2021-11-10T16:00:00.000Z","updated":"2021-11-13T10:47:51.165Z","comments":true,"path":"2021/11/11/20211111/","link":"","permalink":"http://spcablast.club/2021/11/11/20211111/","excerpt":"","text":"###1785. 构成特定和需要添加的最少元素给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 1234567891011121314151617class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long long int sum &#x3D; 0; for(int num:nums)&#123; sum +&#x3D; num; &#125; if(sum &#x3D;&#x3D; goal) return 0; if(abs(sum - goal) &lt; abs(limit))&#123; return 1; &#125; if(abs(sum - goal) % abs(limit) &#x3D;&#x3D; 0 )&#123; return abs(sum - goal) &#x2F; abs(limit); &#125; else return abs(sum - goal) &#x2F; abs(limit) + 1; &#125;&#125;; ###剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left) , maxDepth(root-&gt;right)) +1; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-13T10:47:34.458Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211109","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-13T10:47:20.514Z","comments":true,"path":"2021/11/09/20211109/","link":"","permalink":"http://spcablast.club/2021/11/09/20211109/","excerpt":"","text":"###1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans(2,0); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int temp &#x3D; target - nums[i]; &#x2F;&#x2F;if( temp &lt; 0 ) continue; for(int j &#x3D; i+1; j &lt;nums.size(); ++j)&#123; if(temp &#x3D;&#x3D; nums[j] )&#123; ans[0] &#x3D; i; ans[1] &#x3D; j; return ans; &#125; &#125; &#125; return ans; &#125;&#125;;&#x2F;&#x2F;我就说哈希表好嘛，虽然我不会 ###198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 1234567891011121314151617181920class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1)&#123; return nums[0]; &#125; if(nums.size() &#x3D;&#x3D; 2)&#123; return max(nums[0],nums[1]); &#125; vector&lt;int&gt; ma(nums.size()+1, 0); ma[0] &#x3D; nums[0]; ma[1] &#x3D; max(nums[0], nums[1]); int maxNum &#x3D; 0; for(int i &#x3D; 2; i &lt; nums.size(); i++)&#123; maxNum &#x3D; nums[i]; ma[i] &#x3D; max(ma[i - 1], ma[i -2] + maxNum ); &#125; return ma[nums.size() - 1]; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211108","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-13T10:44:28.022Z","comments":true,"path":"2021/11/08/20211108/","link":"","permalink":"http://spcablast.club/2021/11/08/20211108/","excerpt":"","text":"###1105. 填充书架附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; &#x2F;&#x2F;我大受震撼，且我不理解，下次让我做我还不会 &#x2F;&#x2F; vector&lt;int&gt; d(books.size()+1,INT_MAX); &#x2F;&#x2F; d[books.size()] &#x3D; 0; &#x2F;&#x2F; for(int i &#x3D; books.size() - 1; i &gt;&#x3D; 0 ; --i)&#123; &#x2F;&#x2F; int MaxHeight &#x3D; 0; &#x2F;&#x2F; int leftWith &#x3D; shelfWidth; &#x2F;&#x2F; for(int j &#x3D; i; j &lt; books.size() &amp;&amp; leftWith &gt; books[j][0]; ++j)&#123; &#x2F;&#x2F; MaxHeight &#x3D; max(books[j][1], MaxHeight); &#x2F;&#x2F; d[i] &#x3D; min(MaxHeight + d[j+1],d[i]); &#x2F;&#x2F; leftWith -&#x3D; books[j][0]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return d[0]; vector&lt;int&gt; dp(books.size() + 1, INT_MAX); dp[books.size()] &#x3D; 0; for (int i &#x3D; books.size() - 1; i &gt;&#x3D; 0; --i) &#123; int max_book_height &#x3D; 0; int left_width &#x3D; shelfWidth; &#x2F;&#x2F; 把第 j 本书拿到第 i 本书后面 for (int j &#x3D; i; j &lt; books.size() &amp;&amp; left_width &gt;&#x3D; books[j][0]; ++j) &#123; max_book_height &#x3D; max(max_book_height, books[j][1]); dp[i] &#x3D; min(dp[i], max_book_height + dp[j+1]); left_width -&#x3D; books[j][0]; &#125; &#125; return dp[0];&#125;; ###1822. 数组元素积的符号已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 12345678910111213class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int product = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) product *= -1; &#125; return product; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211107","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-13T10:44:34.015Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211106","date":"2021-11-05T16:00:00.000Z","updated":"2021-11-13T10:47:09.248Z","comments":true,"path":"2021/11/06/20211106/","link":"","permalink":"http://spcablast.club/2021/11/06/20211106/","excerpt":"","text":"###82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。示例 1：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates( ListNode* head) &#123; if(!head) return head; ListNode* singleNode = new ListNode(0,head); ListNode* flagHeader = singleNode; while(flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;next)&#123; if(flagHeader-&gt;next-&gt;val == flagHeader-&gt;next-&gt;next-&gt;val)&#123; int temp = flagHeader-&gt;next-&gt;val; while( flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;val == temp )&#123; flagHeader-&gt;next = flagHeader-&gt;next-&gt;next; &#125; &#125; else&#123; flagHeader = flagHeader-&gt;next; &#125; &#125; return singleNode-&gt;next; &#125;&#125;; ###剑指 Offer 39. 数组中出现次数超过一半的数字 链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //来个map? unordered_map&lt;int, int&gt; myMap; int temp = 0, maxNum = 0; for(int num : nums)&#123; ++myMap[num]; if(myMap[num] &gt; maxNum)&#123; temp = num; maxNum = myMap[num]; &#125; &#125; return temp; &#125;&#125;;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"报的错","slug":"报的错","date":"2021-08-28T01:50:14.674Z","updated":"2021-08-28T01:50:14.776Z","comments":true,"path":"2021/08/28/报的错/","link":"","permalink":"http://spcablast.club/2021/08/28/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2021-07-16T09:14:24.409Z","updated":"2021-04-24T12:07:09.991Z","comments":true,"path":"2021/07/16/Markdown_test/","link":"","permalink":"http://spcablast.club/2021/07/16/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-16T09:14:24.358Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2021/07/16/hello-world/","link":"","permalink":"http://spcablast.club/2021/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"}]}