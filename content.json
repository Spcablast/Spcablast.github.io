{"meta":{"title":"YP Blog","subtitle":"咸的博客","description":"Study without thinking is labour lost. Thinking without study is perilous.","author":"YP","url":"http://spcablast.club","root":"/"},"pages":[{"title":"书单","date":"2021-11-15T05:02:33.109Z","updated":"2021-11-15T05:02:33.109Z","comments":true,"path":"books/index.html","permalink":"http://spcablast.club/books/index.html","excerpt":"","text":"douban 豆瓣书单douban: user: *** # 豆瓣用户名 start: 0 # 从哪一条记录开始 count: 100 # 获取豆瓣书单数据条数"},{"title":"友情链接","date":"2021-04-24T08:25:31.069Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://spcablast.club/links/index.html","excerpt":"","text":""},{"title":"reading","date":"2021-11-18T00:51:00.817Z","updated":"2021-11-18T00:51:00.817Z","comments":true,"path":"books/书单.html","permalink":"http://spcablast.club/books/%E4%B9%A6%E5%8D%95.html","excerpt":"","text":"《艺术创造学》 余秋雨 《论道德和自由》叔本华 《六祖坛经》 论充足根据律的四重根 叔本华 裸猿三部曲 生命是什么 薛定谔 《上瘾》 机器学习 周志华 鲁迅全集（太长） 作为意志和表象的世界 叔本华 荣格 红书，认识人性 弗洛伊德 阿德勒 《自卑与超越》 韦启昌译叔本华 心理学之旅 论语 道德形而上学奠基句读 邓晓芒 etc.虽然作者著书的时间不同于当代，但是他们想表达的内容确实在人的范围里，这是他们根据自己的智慧得出来的结论或者经验或者是过程的记录，是他们自己的感受。是，前人的智慧。可以从中学到他们的思考方式，甚至有些东西能直接拿来用 藏书馆：《自私的基因》 《人为什么活着》王小波 《西方哲学史》罗素 《代码之美》 《非暴力沟通》 《浮生六记》 九把刀 古龙 《把时间当朋友》 《相约星期二》 《数学原理》罗素 《源氏物语》《活着本来单纯》《丰子恺文集》 《社会性动物》 《理解人性》阿德勒 《怪诞心理学》 《陈丹青音乐笔记》 《艺术创造学》 《道德情操论》 《逃避自由》 《怪诞行为学》 《直觉泵和其他思考工具》 《生命是什么》薛定谔 《叔本华思想随笔》 《深入理解计算机系统》 《菊与刀》 《皮肤的秘密》 《偶像的黄昏》 《作为意志和表象的世界》 《纯粹理性批判》 《宪法》 《行政法》 《民法》 《中医基础理论》 《自然哲学之数学原理》 《杨戬-人生长恨水长东》 《精神现象学》我觉得一点没看 《叔本华美学随笔》 《茶花女》 《逻辑学上/下》我怎么一点印象没有 《北京折叠》 《康德哲学选讲-邓晓芒》 《象与骑象人》 《中国-传统与变革》 《当下的力量》 《韩瑜文集》 《现代操作系统》 《Linux内核完全注释》 《偶像的黄昏》 《大学，中庸》 《偶像的黄昏》 《中国文化的深层结构》 《态度改变与社会影响》 《自卑与超越》 《裸猿》 《侠客行》 金庸 《大问题 简明哲学导论》 《丧家狗》 《春秋大义》 《1984》 《悟空传》 《动物农场》 《哥伦比亚的倒影》 《变形记》 《洛丽塔》 《周易参同契》 《我所有的朋友都死了？》 《子不语》 《各自的朝圣路》 《资本论》必没看完 《梦的解析》 《雪中悍刀行》 《木心诗选》 《你应该熟读的中国古诗》 《尼采诗集》 《遇见最美的宋词》 《人间失格》 《瓦尔登湖》 《牛虻》没看 《一个陌生女人的来信》 《闲情偶寄》 《杀死一只知更鸟》 《罗生门》 《我与地坛》 《芥川龙之介作品选集》没印象 《人生哲思录》 《荣格自传》 《无人生还》 《人间草木》 《小王子》 《王尔德诗选》 《诗境浅说》 《忏悔录》 《论人生不平等的起源和基础》 《月亮和六便士》 《简爱》 《苦儿流浪记》 《文学回忆录》《木心谈木心》 《苏东坡传》 《感觉的自然史》 下次继续列"},{"title":"404 Not Found：该页无法显示","date":"2021-11-13T12:48:37.864Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://spcablast.club/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-13T12:48:45.850Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"about/index.html","permalink":"http://spcablast.club/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-11-13T12:49:26.061Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://spcablast.club/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-24T08:25:31.071Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://spcablast.club/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-13T12:49:53.171Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://spcablast.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dailycode","slug":"20211214","date":"2021-12-13T16:00:00.000Z","updated":"2021-12-14T15:23:56.029Z","comments":true,"path":"2021/12/14/20211214/","link":"","permalink":"http://spcablast.club/2021/12/14/20211214/","excerpt":"","text":"###931. 下降路径最小和给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。 下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。 示例 1： 输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]输出：13解释：下面是两条和最小的下降路径，用加粗+斜体标注：[[2,1,3], [[2,1,3], [6,5,4], [6,5,4], [7,8,9]] [7,8,9]] 1234567891011121314151617181920212223class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; //下降路径，第一行挑最小，但是第一行每个都作为起点 //best = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1]) int N = matrix.size(); for (int r = N-2; r &gt;= 0; --r) &#123;//从倒数第二行开始 for (int c = 0; c &lt; N; ++c) &#123; int best = matrix[r+1][c]; if (c &gt; 0) best = min(best, matrix[r+1][c-1]); if (c+1 &lt; N) best = min(best, matrix[r+1][c+1]); matrix[r][c] += best; &#125; &#125; int ans = INT_MAX; for (int x: matrix[0]) ans = min(ans, x); return ans; &#125;&#125;; ###933. 最近的请求次数写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：[“RecentCounter”, “ping”, “ping”, “ping”, “ping”][[], [1], [100], [3001], [3002]]输出：[null, 1, 2, 3, 3] 解释：RecentCounter recentCounter = new RecentCounter();recentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1recentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2recentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3recentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3 12345678910111213141516class RecentCounter &#123;private: queue&lt;int&gt; q;//队列存time，是不是可以直接用数组，数组不如vector，vector不如队列，public: RecentCounter() &#123;&#125; int ping(int t) &#123; q.push(t); while (t - q.front() &gt; 3000) q.pop(); //若时间太早，则循环出队 return q.size(); //最后返回队列长度，即最近3000ms的请求次数 &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj-&gt;ping(t); */","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"},{"name":"动态规划","slug":"Dailycode/动态规划","permalink":"http://spcablast.club/categories/Dailycode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211213","date":"2021-12-12T16:00:00.000Z","updated":"2021-12-13T14:09:16.949Z","comments":true,"path":"2021/12/13/20211213/","link":"","permalink":"http://spcablast.club/2021/12/13/20211213/","excerpt":"","text":"###807. 保持城市天际线给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。 城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。 我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。 在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; //这题的意思就是填格子吧，每个格子可以补充到行列最大值里小的那个 //所以需要获取每行和每列的最大值 //遍历两遍行了，第一遍存行加列减一个最大值， //第二遍累加/我只要算每一行每一列的总和，存起来，就不用累加了//没用，别存了 if(grid.size()==0) return 0; int col = 0, row = 0, ans = 0; vector&lt;int&gt; rowmax(grid.size(),0); vector&lt;int&gt; colmax(grid[0].size(),0); row = grid.size(); col = grid[0].size(); for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; rowmax[i] = grid[i][j]&gt;rowmax[i]?grid[i][j]:rowmax[i]; &#125; &#125; for(int i = 0; i&lt;col; ++i)&#123; for(int j = 0; j&lt;row; ++j)&#123; colmax[i] = grid[j][i]&gt;colmax[i]?grid[j][i]:colmax[i]; &#125; &#125; for(int i = 0; i&lt;row; ++i)&#123; for(int j = 0; j&lt;col; ++j)&#123; int maxnum = min(rowmax[i], colmax[j]); if(maxnum - grid[i][j] &gt;=0)&#123; ans +=maxnum - grid[i][j]; &#125; &#125; &#125; return ans; &#125;&#125;; ###剑指 Offer 32 - II. 从上到下打印二叉树 II从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。例如:给定二叉树: [3,9,20,null,null,15,7],返回其层次遍历结果： [ [3], [9,20], [15,7]] 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; //层次遍历，返回条件是啥嘞 vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; points;//队列存每层根节点 points.push(root); while(points.size())&#123; int col=points.size();//当前层有几个节点 vector&lt;int&gt; ans1;//存当前层数据 for(int i=0;i&lt;col;i++)&#123;//根据数量从队列里取相应的节点 TreeNode *temp=points.front(); points.pop(); ans1.push_back(temp-&gt;val); if(temp-&gt;left) points.push(temp-&gt;left); if(temp-&gt;right) points.push(temp-&gt;right); &#125; ans.push_back(ans1); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"},{"name":"二叉树","slug":"Dailycode/二叉树","permalink":"http://spcablast.club/categories/Dailycode/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211212","date":"2021-12-11T16:00:00.000Z","updated":"2021-12-12T12:08:37.754Z","comments":true,"path":"2021/12/12/20211212/","link":"","permalink":"http://spcablast.club/2021/12/12/20211212/","excerpt":"","text":"转换成小写字母给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。 示例 1： 输入：s = “Hello”输出：”hello” 123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(int i&#x3D;0;i&lt;s.size();++i)&#123; s[i] &#x3D; tolower(s[i]); &#125; return s; &#125;&#125;; ###421. 数组中两个数的最大异或值给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。 进阶：你可以在 O(n) 的时间解决这个问题吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; //找异或值最大的俩，就是要1最多，两个数异或等于1，就是同位相等，就着最大值怎么样，拿着最大值和其他的数来 //所以要不要转成2进制 //首先看谁的1111111111，前面的1位置远，然后 //动态规划行吗，存当前最大的值 //1个的时候是自己，2个的时候也是，三个的时候分别用两个数和第三个数异或，然后挑大的，这样又只剩下两个数了，再第四位，好像行 // int left = 0,right = 0, ans=0; // if(nums.size() == 0) return 0; // if(nums.size() == 1) return nums[0]; // if(nums.size() == 2) return nums[0]^nums[1]; // for(int i = 0;i&lt;nums.size();++i)&#123; // if((left ^ nums[i]) &gt; ans)&#123; // right = nums[i]; // ans = left ^ right; // &#125; // else if((right ^ nums[i]) &gt; ans)&#123; // left = nums[i]; // ans = left ^ right; // &#125; // ans = left ^ right; // &#125; // return ans; //那我只能说，康康题解，这题怎么可能On的，啊，翻译翻译，什么叫On int x = 0; for (int k = HIGH_BIT; k &gt;= 0; --k) &#123; unordered_set&lt;int&gt; seen; // 将所有的 pre^k(a_j) 放入哈希表中 for (int num: nums) &#123; // 如果只想保留从最高位开始到第 k 个二进制位为止的部分 // 只需将其右移 k 位 seen.insert(num &gt;&gt; k); &#125; // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分 // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1 int x_next = x * 2 + 1; bool found = false; // 枚举 i for (int num: nums) &#123; if (seen.count(x_next ^ (num &gt;&gt; k))) &#123; found = true; break; &#125; &#125; if (found) &#123; x = x_next; &#125; else &#123; // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0 // 即为 x = x*2 x = x_next - 1; &#125; &#125; return x; &#125;private: // 最高位的二进制位编号为 30 static constexpr int HIGH_BIT = 30;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110_","date":"2021-12-09T16:00:00.000Z","updated":"2021-12-10T12:17:52.091Z","comments":true,"path":"2021/12/10/20211110_/","link":"","permalink":"http://spcablast.club/2021/12/10/20211110_/","excerpt":"","text":"###24. 两两交换链表中的节点给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ // 1 2 3 4 5 6 7 // 2 1 3 4 5 6 7 // 2 1 4 3 6 5 7class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head) return head; if(!head-&gt;next) return head; int cnt = 0; ListNode* pre = head; ListNode* cur = head-&gt;next; ListNode* ini = new ListNode(0); ListNode* temp = ini; temp-&gt;next = head; while(temp-&gt;next &amp;&amp; temp-&gt;next-&gt;next)&#123;//从头开始，只需要把第一个指到第二个的next，第二个指到第一个就行了，然后两个指针都向前两步， pre = temp-&gt;next; cur = temp-&gt;next-&gt;next; temp-&gt;next = cur; pre-&gt;next = cur-&gt;next; cur-&gt;next = pre; temp = pre; &#125; return ini-&gt;next; &#125;&#125;; ###剑指 Offer 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：2 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: //1 //1 2 //1 2 +1 //1 2 // int fib(int n)&#123; // if(n == 0) return 1; // else if(n == 1) return 1; // else // return (fib(n-1) + fib(n-2))%1000000007; // &#125; // int numWays(int n) &#123;//跳3级台阶，等于1级和2级台阶的数量加起来 // if(n == 0) return 1; // if(n ==1) return 1; // return (fib(n))%1000000007; // &#125; int numWays(int n) &#123;//递归44就超时了，迭代1000000000也超时了 if (n &lt;= 1) &#123; return 1; &#125; int a = 1; int b = 2; for (int i = 2; i &lt; n; i++) &#123; int temp = (a + b); a = b; b = temp; b %= 1000000007; &#125; return b; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211209","date":"2021-12-08T16:00:00.000Z","updated":"2021-12-09T13:36:18.523Z","comments":true,"path":"2021/12/09/20211209/","link":"","permalink":"http://spcablast.club/2021/12/09/20211209/","excerpt":"","text":"###766. 托普利茨矩阵给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 12345678910111213141516171819class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size() == 1) return true; if(matrix[0].size() ==1 )return true; //if(matrix.size() == 2) return matrix[0][0] == matrix[1][1]; //用一行存第一行 //和下一行比 //更新第一行 for(int i = 1; i&lt;=matrix.size() -1; ++i)&#123; for(int j = 0; j&lt; matrix[0].size() -1; j++)&#123; if(!(matrix[i-1][j] == matrix[i][j+1]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; ###150. 逆波兰表达式求值根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [“2”,”1”,”+”,”3”,”*”]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: // int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; // //数字入栈，符号运算，弹出结果 // stack&lt;int&gt; stac; // for(int i =0;i&lt;tokens.size();++i)&#123; // string&amp; get = tokens[i]; // //判断数字还是符号 // if(get[0] -'+' != 0 &amp;&amp; get[0]-'-'!=0 &amp;&amp;get[0]-'*'!=0&amp;&amp;get[0]-'/'!=0)&#123; // stac.push(atoi(get[i].c_str())); // &#125; // else&#123; // int num1 = stac.top(); // stac.pop(); // int num2 = stac.top(); // stac.pop(); // switch(get[0])&#123; // case '+': // stac.push(num2 + num1); // break; // case '-': // stac.push(num2 - num1); // break; // case '*': // stac.push(num2 * num1); // break; // case '/': // stac.push(num2 / num1); // break; // &#125; // &#125; // &#125; // return stac.top(); // &#125; int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; stk; int n = tokens.size(); for (int i = 0; i &lt; n; i++) &#123; string&amp; token = tokens[i]; if (isNumber(token)) &#123; stk.push(atoi(token.c_str())); &#125; else &#123; int num2 = stk.top(); stk.pop(); int num1 = stk.top(); stk.pop(); switch (token[0]) &#123; case '+': stk.push(num1 + num2); break; case '-': stk.push(num1 - num2); break; case '*': stk.push(num1 * num2); break; case '/': stk.push(num1 / num2); break; &#125; &#125; &#125; return stk.top(); &#125; bool isNumber(string&amp; token) &#123; return !(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\"); &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211208","date":"2021-12-07T16:00:00.000Z","updated":"2021-12-08T12:17:49.975Z","comments":true,"path":"2021/12/08/20211208/","link":"","permalink":"http://spcablast.club/2021/12/08/20211208/","excerpt":"","text":"###35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 123456789101112131415161718class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() -1, ans = nums.size(); while(left &lt;= right)&#123; if(target == nums[(left+right)/2] )&#123; return (left+right)/2; &#125; else if(target &lt; nums[(left+right)/2])&#123; ans = (left+right)/2; right = (left+right)/2-1; &#125; else if(target &gt; nums[(left+right)/2]) left = (left+right)/2+1; &#125; return ans; &#125;&#125;; ###1509. 三次操作后最大值与最小值的最小差给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。 请你返回三次操作后， nums 中最大值与最小值的差的最小值。 示例 1： 输入：nums = [5,3,2,4]输出：0解释：将数组 [5,3,2,4] 变成 [2,2,2,2].最大值与最小值的差为 2-2 = 0 。 123456789101112131415161718class Solution &#123;public: int minDifference(vector&lt;int&gt;&amp; nums) &#123; //找最大和第二大的， //找最小和第二小的， //最大的减，嘴小的加，看哪个合适 //结果就是，找最大的四个数，最小的四个数，一共能删除三个数，删除3个最大，第四大减去最小，删除2个最大，一个最小 if(nums.size() &lt;= 4)&#123; return 0; &#125; int ret = INT_MAX; sort(nums.begin(),nums.end()); for(int i = 0; i&lt;4; ++i)&#123; ret = min(ret, (nums[nums.size()-i -1] - nums[3-i])); &#125; return ret; &#125; &#125;; 今日吐槽：“时间”这个名词是时间的外显嘛，本没有时间，只有事物状态的变化，是嘛，将事物状态变化的速度来一个量化的单位，就是时间了。衡量单位出现的作用是什么呢？","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211207","date":"2021-12-06T16:00:00.000Z","updated":"2021-12-07T12:17:12.578Z","comments":true,"path":"2021/12/07/20211207/","link":"","permalink":"http://spcablast.club/2021/12/07/20211207/","excerpt":"","text":"###1844. 将所有数字用字符替换给你一个下标从 0 开始的字符串 s ，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。 定义一个函数 shift(c, x) ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。 比方说，shift(‘a’, 5) = ‘f’ 和 shift(‘x’, 0) = ‘x’ 。对于每个 奇数 下标 i ，你需要将数字 s[i] 用 shift(s[i-1], s[i]) 替换。 请你替换所有数字以后，将字符串 s 返回。题目 保证 shift(s[i-1], s[i]) 不会超过 ‘z’ 。 1234567891011class Solution &#123;public: string replaceDigits(string s) &#123; for(int i = 0; i&lt; s.size();++i)&#123; if(i%2==1)&#123; s[i] = (s[i-1] - 'a' + (s[i] - '0'))%32 + 'a'; &#125; &#125; return s; &#125;&#125;; ###剑指 Offer II 026. 重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; //除了用一个指针指到末尾去，然后一边取一个存到新的里边 //奥，还可以从末尾拿一个过来，插到每一个的后边，直到取完，这样就省了新空间 //坏了，每次都得从头过去取吗，不从头过去取难道用一个空间存，、 //是不是可以截断成两个，然后倒插，怎么倒插呢 为了省时间还可以截断成log2 n个部分，存这么点节点，遍历的时间就省了 vector&lt;ListNode *&gt; list; while(head-&gt;next)&#123; list.push_back(head); head = head-&gt;next; &#125; list.push_back(head); int left = 0, right = list.size() - 1; while(left &lt; right)&#123; list[left]-&gt;next = list[right]; left++; if(left == right) break; list[right]-&gt;next = list[left]; right--; &#125; list[left]-&gt;next = nullptr; &#125;&#125;; 今日吐槽：刚刚坐在实验室突然感觉力气逐渐消失，还特别累，逐渐变困，感觉哪里不对，一想，原来是考完试回来忘了吃晚饭，大家注意吃饭","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211105","date":"2021-12-04T16:00:00.000Z","updated":"2021-12-05T12:08:35.984Z","comments":true,"path":"2021/12/05/20211105/","link":"","permalink":"http://spcablast.club/2021/12/05/20211105/","excerpt":"","text":"###139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。 示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 123456789101112131415161718192021class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; //判断首字母有几个匹配的，一个一个比较，没有一个相等就说明可以返回false了 auto wordDictSet = unordered_set &lt;string&gt; (); for (auto word: wordDict) &#123;//把字典里的都存起来 wordDictSet.insert(word); &#125; auto dp = vector &lt;bool&gt; (s.size() + 1);//每一位存0位到当前位是否是能拆 dp[0] = true; for (int i = 1; i &lt;= s.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123;//如果从j开始，到i结束这段能在字典里找到，且到j这段也能拆，那么就说明到i这段能拆 if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; ###627. 变更性别SQL架构Salary 表： +————-+———-+| Column Name | Type |+————-+———-+| id | int || name | varchar || sex | ENUM || salary | int |+————-+———-+id 是这个表的主键。sex 这一列的值是 ENUM 类型，只能从 (‘m’, ‘f’) 中取。本表包含公司雇员的信息。 请你编写一个 SQL 查询来交换所有的 ‘f’ 和 ‘m’ （即，将所有 ‘f’ 变为 ‘m’ ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。 注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。 12345678// Write your MySQL query statement belowUPDATE salarySET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END;//还有数据库的题，神秘，这是什么操作，如果是m设置成f，否则设置成m","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"SQL - 算法题","slug":"SQL-算法题","permalink":"http://spcablast.club/tags/SQL-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20201204","date":"2021-12-03T16:00:00.000Z","updated":"2021-12-04T01:31:29.021Z","comments":true,"path":"2021/12/04/20201204/","link":"","permalink":"http://spcablast.club/2021/12/04/20201204/","excerpt":"","text":"###121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //我只需要将当前值减去过去最小的，比一比，就行了 int cur = 0, min = INT_MAX, max = INT_MIN, index = 0; cur = prices[0]; for(int i = 0; i &lt; prices.size(); ++i)&#123; cur = prices[i]; if(min &gt; prices[i])&#123; min = prices[i]; &#125; if(max &lt; cur - min)&#123; max = cur - min; index = i; &#125; &#125; return max&gt;0?max:0; &#125;&#125;; ###413. 等差数列划分如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4]输出：3解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。示例 2： 输入：nums = [1]输出：0 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; //神秘，我需要判断出来当前是不是等差，如果是，在哪儿停止，下一个开始又计数 //一通操作算出来了有几个 if(nums.size()&lt;3)&#123; return 0; &#125; int pre = INT_MIN, ppre, cur,cnt = 0, t = 0; pre = nums[1] - nums[0]; cur = nums[2] - nums[1]; bool last = false; for(int i =2; i&lt; nums.size();++i)&#123; cur = nums[i] - nums[i-1]; if(pre != cur)&#123;//说明上一个和这一个不相等,不在一个等差数列 t = 0; last = false; &#125; else &#123; t++; last = true; &#125; if((!last) &amp;&amp; (pre == cur))&#123;//如果上一个pre不等于cur但是这一个pre等于cur，说明进入一个等差数列 //cnt++; &#125; pre = cur; cnt += t;//先找到有几个等差数列，再算每个等差数列里面有几个等差数列，好优化 &#125; return cnt; &#125;&#125;; 今日吐槽：早睡早起身体好，食堂的辣白菜可太好吃了，今天又是不想营业的一天，该干活了。动态规划，不对劲，这题不对劲","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211202","date":"2021-12-01T16:00:00.000Z","updated":"2021-12-02T11:53:11.813Z","comments":true,"path":"2021/12/02/20211202/","link":"","permalink":"http://spcablast.club/2021/12/02/20211202/","excerpt":"","text":"###152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 1234567891011121314151617181920212223class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; // //这题是不是跟昨天的一样 // int maxMul = INT_MIN, pre = 1, cur = 0; // for(int num : nums)&#123; // cur = pre*num; // maxMul = max(maxMul,cur); // if(cur = 0) pre = 1; // else pre = cur; // &#125; // return maxMul; //事实告诉我不是，因为还能-2*-2 = 4，小加小等于大 int maxF = nums[0], minF = nums[0], ans = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; int mx = maxF, mn = minF; maxF = max(mx * nums[i], max(nums[i], mn * nums[i])); minF = min(mn * nums[i], min(nums[i], mx * nums[i])); ans = max(maxF, ans); &#125; return ans; &#125;&#125;; ###278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 12345678910111213141516171819// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; long left = 1, right = n; while(left&lt;right)&#123; if(isBadVersion((left+right)/2))&#123; right = (left+right)/2; &#125; else&#123; left = (left+right)/2;//可以加一，因为这个位置已经判断过了 &#125; if(right==left+1) break; &#125; if(isBadVersion(left)) return left; return right; &#125;&#125;; 这波啊，这波是用空间换时间，直接来两个long int，不用跟他讲什么江湖道义，大家并肩子一起上，挺丑的，没有官方题解美观 今日吐槽：昨晚10点半就睡了，今天充满了power，虽然动态规划还是不太会，但是会写框架了呀，问题不大，在学了在学了还深度学习，学个der，令人头秃","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211201","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:23:56.226Z","comments":true,"path":"2021/12/01/20211201/","link":"","permalink":"http://spcablast.club/2021/12/01/20211201/","excerpt":"","text":"###53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2： 输入：nums = [1]输出：1示例 3： 输入：nums = [5,4,-1,7,8]输出：23 12345678910111213141516171819class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; //我知道了，把每一个位置的最大和存在一个数组里，遍历的时候把最大存在max里，最后返回 //优化一下就是把当前最大和上一个最大比较，大的更新，再下一步 //好像不对 //假如只有一个数，返回自身dp[0] = nums[1] //两个数，返回加来大还是本身大dp[1] = max(dp[0],num[1] + dp[0])，如果是dp[0]说明断了，且新来的这个数一定是负数，那么就得更新一下计数方式，下次计算从下一位开始 //三个数,if(更新)dp[2] = max(dp[1],num[2] + dp[1]) 或者 dp[2] = num[2] //也不对，用负数把数组分割一下，有道理，一个区域后边的负数比这个区域的正数负的少，就可以用 //变复杂了 int pre = 0, maxAns = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); maxAns = max(maxAns, pre); &#125; return maxAns; &#125;&#125;; 字典序排数给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]示例 2： 输入：n = 2输出：[1,2] 提示： 1 &lt;= n &lt;= 5 * 104 12345678910111213141516171819class Solution &#123;public: void dfs(int n, vector&lt;int&gt; &amp; ans, int num)&#123; if(num&gt;n) return; ans.push_back(num); for(int j = 0;j &lt;= 9;j++)&#123; dfs(n, ans, num*10+j); &#125; &#125; vector&lt;int&gt; lexicalOrder(int n) &#123; //时间复杂度On，空间复杂度O1，啊这，字典序是什么序的 //1 10 11 ... 19 110 111...119 vector&lt;int&gt; ans; for(int i = 1; i&lt;10; i++)&#123; dfs(n, ans, i); &#125; return ans; &#125;&#125;; 今日吐槽：dfs，不会，动态规划还没学会呢，又给我dfs，但是dfs看起来没有动态规划难的亚子，爬，一递归就乱了，得整整递归","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dfs - 算法题","slug":"dfs-算法题","permalink":"http://spcablast.club/tags/dfs-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"《黑羊》","slug":"黑羊-卡尔维诺","date":"2021-11-30T16:00:00.000Z","updated":"2021-12-01T12:54:55.372Z","comments":true,"path":"2021/12/01/黑羊-卡尔维诺/","link":"","permalink":"http://spcablast.club/2021/12/01/%E9%BB%91%E7%BE%8A-%E5%8D%A1%E5%B0%94%E7%BB%B4%E8%AF%BA/","excerpt":"","text":"黑羊 卡尔维诺 从前有个国家，里面人人是贼。一到傍晚，他们手持万能钥匙和遮光灯笼出门，走到邻居家里行窃。破晓时分，他们提着偷来的东西回到家里，总能发现自己家也失窃了。 他们就这样幸福地居住在一起。没有不幸的人，因为每个人都从别人那里偷东西，别人又再从别人那里偷，依次下去，直到最后一个人去第一个窃贼家行窃。该国贸易也就不可避免地是买方和卖方的双向欺骗。政府是个向臣民行窃的犯罪机构，而臣民也仅对欺骗政府感兴趣。所以日子倒也平稳，没有富人和穷人。 有一天－－到底是怎么回事没人知道－－总之是有个诚实人到了该地定居。到晚上，他没有携袋提灯地出门，却呆在家里抽烟读小说。贼来了，见灯亮着，就没进去。 这样持续了有一段时间。后来他们感到有必要向他挑明一下，纵使他想什么都不做地过日子，可他没理由妨碍别人做事。他天天晚上呆在家里，这就意味着有一户人家第二天没了口粮。 诚实人感到他无力反抗这样的逻辑。从此他也像他们一样，晚上出门，次日早晨回家，但他不行窃。他是诚实的。对此，你是无能为力的。他走到远处的桥上，看河水打桥下流过。每次回家，他都会发现家里失窃了。 不到一星期，诚实人就发现自己已经一文不名了；他家徒四壁，没任何东西可吃。但这不能算不了什么，因为那是他自己的错；不，问题是他的行为使其他人很不安。因为他让别人偷走了他的一切却不从别人那儿偷任何东西；这样总有人在黎明回家时，发现家里没被动过－－那本该是由诚实人进去行窃的。不久以后，那些没有被偷过的人家发现他们比人家就富了，就不想再行窃了。更糟的是，那些跑到诚实人家里去行窃的人，总发现里面空空如也，因此他们就变穷了。 同时，富起来的那些人和诚实人一样，养成了晚上去桥上的习惯，他们也看河水打桥下流过。这样，事态就更混乱了，因为这意味着更多的人在变富，也有更多的人在变穷。 现在，那些富人发现，如果他们天天去桥上，他们很快也会变穷的。他们就想：“我们雇那些穷的去替我们行窃吧。”他们签下合同，敲定了工资和如何分成。自然，他们依然是贼，依然互相欺骗。但形势表明，富人是越来越富，穷人是越来越穷。 有些人富裕得已经根本无须亲自行窃或雇人行窃就可保持富有。但一旦他们停止行窃的话，他们就会变穷，因为穷人会偷他们。因此他们又雇了穷人中的最穷者来帮助他们看守财富，以免遭穷人行窃，这就意味着要建立警察局和监狱。 因此，在那诚实人出现后没几年，人们就不再谈什么偷盗或被偷盗了，而只说穷人和富人；但他们个个都还是贼。唯一诚实的只有开头的那个人，但他不久便死了，饿死的。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"http://spcablast.club/tags/%E7%9F%AD%E7%AF%87%E5%B0%8F%E8%AF%B4/"}],"author":"YP"},{"title":"Dailycode","slug":"20211130","date":"2021-11-29T16:00:00.000Z","updated":"2021-11-30T13:34:56.239Z","comments":true,"path":"2021/11/30/20211130/","link":"","permalink":"http://spcablast.club/2021/11/30/20211130/","excerpt":"","text":"删除并获得点数给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2]输出：6解释：删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int rob(vector&lt;int&gt; nums)&#123; int n = nums.size(); int first = nums[0], secend = max(first, nums[1]); for(int i = 2; i &lt; n; i++ )&#123; int temp = secend; secend = max(first + nums[i], secend); first = temp; &#125; return secend; &#125;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; //找最大，是最大大，还是最大减一 //一个返回自己 //两个返回最大，除非比他小一的乘起来比他大 //那这样就可以开一个哈希表，数字乘以出现次数，是这个数的值，a + c and b //取每个数，来个最大值 //假如取了第一个数，那么当前最大值存一下 //取第二个数，当前最大值存一下，是等于dp[0] + dp[1]还是dp[1]判断一下 //取第三个数，dp[0] + if dp[1] + dp[2] //取第四个数，dp[1] + if dp[2] + dp[3] //好，写 //先排序，再哈希，再dp if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int n = nums.size(), maxNum = 0; for(int i = 0;i &lt; n;++i)&#123; if(nums[i] &gt; maxNum)&#123; maxNum = nums[i]; &#125; &#125; vector&lt;int&gt; numNew(maxNum + 1); for(int num : nums)&#123; numNew[num] += num; &#125; return rob(numNew); &#125;&#125;; 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 示例 1： 输入：s = “()”输出：true 123456789101112131415161718192021222324class Solution &#123;public: bool isValid(string s) &#123; if(s.size() % 2 == 1) return false; //不成对，false stack&lt;char&gt; st; unordered_map&lt;char, char&gt; pairs = &#123; &#123;')','('&#125;, &#123;']','['&#125;, &#123;'&#125;','&#123;'&#125; &#125;; for(char ch : s)&#123; if(pairs.count(ch))&#123; if(st.empty() || st.top() != pairs[ch])&#123;//读到一个右括号，看是不是空，栈顶是不是对应的左括号 return false; &#125; st.pop();//没问题退栈 &#125; else&#123; st.push(ch);//否则压栈 &#125; &#125; return st.empty(); &#125;&#125;; 今日吐槽：歇了一天今天不困了，但是还需要中午补一点，该补一补了 感觉","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211129","date":"2021-11-28T16:00:00.000Z","updated":"2021-11-29T12:32:36.335Z","comments":true,"path":"2021/11/29/20211129/","link":"","permalink":"http://spcablast.club/2021/11/29/20211129/","excerpt":"","text":"剑指 Offer 62. 圆圈中最后剩下的数字0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3输出: 3示例 2： 输入: n = 10, m = 17输出: 2 12345678910111213class Solution &#123;public: int lastRemaining(int n, int m) &#123; //0 1 2 3 4 5 6 7 8 9 //每次往前计数，计到m，cnt--,再数m个，直到cnt==1，评论说这个方法超时了，呵，肤浅，超时，那就不用呗 //f，当前位置，m，每次向前移动位置，i是递归的初始状态 int f = 0; for (int i = 2; i != n + 1; ++i) &#123; f = (m + f) % i; &#125; return f; &#125;&#125;; 跳跃游戏 VII给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处： i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且s[j] == ‘0’.如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。 示例 1： 输入：s = “011010”, minJump = 2, maxJump = 3输出：true解释：第一步，从下标 0 移动到下标 3 。第二步，从下标 3 移动到下标 5 。 1234567891011121314151617181920212223242526class Solution &#123;public: bool canReach(string s, int minJump, int maxJump) &#123; //问题就在于 //每次前进minJump到maxJump距离，在其中找到几个下标为0的位置， //是否可以作为动态规划来解决，从终点往前，数i到j个格子，查里面有没有0，有就存起来 //问题在于我老想着优化的方法，只判断某些点可达不可达，而动态规划每个点都算了可达不可达存起来了 //每次走i步，和每次走j步，有一个区间，如果这个区间有0，说明能到对应的i int n = s.size(); vector&lt;int&gt; f(n), pre(n); f[0] = 1; // 由于我们从 i=minJump 开始动态规划，因此需要将 [0,minJump) 这部分的前缀和预处理出来 for (int i = 0; i &lt; minJump; ++i) &#123; pre[i] = 1; &#125; for (int i = minJump; i &lt; n; ++i) &#123; int left = i - maxJump, right = i - minJump; if (s[i] == '0') &#123; int total = pre[right] - (left &lt;= 0 ? 0 : pre[left - 1]); f[i] = (total != 0); &#125; pre[i] = pre[i - 1] + f[i]; &#125; return f[n - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211128","date":"2021-11-27T16:00:00.000Z","updated":"2021-11-28T14:17:17.108Z","comments":true,"path":"2021/11/28/20211128/","link":"","permalink":"http://spcablast.club/2021/11/28/20211128/","excerpt":"","text":"打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2： 输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// class Solution &#123;// public:// int rob(vector&lt;int&gt;&amp; nums) &#123;// //我应该从哪儿开始偷啊啊，gan// //真就能随便从一个位置开始吗// if(nums.size() == 0) return 0;// if(nums.size() == 1) return nums[0];// if(nums.size() == 2) return max(nums[0],nums[1]);// int ans0 = 0, ans1 = 0;// vector&lt;int&gt; dp[nums.size() + 1],dp2[nums.size() + 1];// //dp[i] = max(dp[i-2] + nums[i], dp[i-1] )// //分两种情况，从0开始和从1开始// dp[0] = nums[0], dp[1] = max(nums[0],nums[1]);// dp2[0] = nums[1], dp2[1] = max(nums[1],nums[2]);// for(int i = 2; i&lt;nums.size() -1; ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// for(int i = 3; i&lt;nums.size(); ++i)&#123;// dp[i] = max(dp[i-2] + nums[i], dp[i-1]);// &#125;// return max(dp[nums.size()],dp2[nums.size()]);// &#125;// &#125;;class Solution &#123;public: int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int first = nums[start], second = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) &#123; int temp = second; second = max(first + nums[i], second); first = temp; &#125; return second; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 1) &#123; return nums[0]; &#125; else if (length == 2) &#123; return max(nums[0], nums[1]); &#125; return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1)); &#125;&#125;; 构造矩形作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 你设计的矩形页面必须等于给定的目标面积。 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。 长度 L 和宽度 W 之间的差距应当尽可能小。你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 输入: 4输出: [2, 2]解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 123456789101112class Solution &#123;public: vector&lt;int&gt; constructRectangle(int area) &#123; int w = 0,h = 0; w= sqrt(area); h = w; while(area % w)&#123; w--; &#125; return &#123;area / w, w&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211127","date":"2021-11-26T16:00:00.000Z","updated":"2021-11-27T15:35:32.455Z","comments":true,"path":"2021/11/27/20211127/","link":"","permalink":"http://spcablast.club/2021/11/27/20211127/","excerpt":"","text":"最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public:int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid)&#123; //好，我现在看什么都想动态规划，gan //假设我在最后一个格子了，那么比较到达左边需要的总数小还是上边的总数小 //感觉就像穷举，没错，就是了 if (!grid.size()) return 0; if (!grid[0].size()) return 0; int col = grid.size(), row = grid[0].size(); vector&lt;int&gt; dp(col * row); dp[0] = grid[0][0]; for (int i = 0; i &lt; col; i++) &#123; for (int j = 0; j &lt; row; j++) &#123; if (i * col + j != 0) &#123; //跳过0，0 if (i == 0) &#123; //第0列 if(j&gt;0) dp[i * row + j] = grid[0][j] + dp[i * row + j -1]; &#125; else if (j == 0) &#123; //第0列 dp[i * row + j] = grid[i][0] + dp[(i-1)*row]; &#125; else &#123; dp[i * row + j] = min(dp[(i - 1) * row + j] + grid[i][j], dp[i * row + j - 1] + grid[i][j]); &#125; &#125; &#125; &#125; return dp[col * row - 1]; &#125; ###7. 整数反转给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; if(x == 0) return 0; int ans = 0,temp = 0; while(x!=0)&#123; temp = x%10; if( ans &lt;= INT_MAX/10 &amp;&amp; ans &gt;= INT_MIN/10) ans = ans*10 + temp; else return 0; x/=10; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211126","date":"2021-11-25T16:00:00.000Z","updated":"2021-11-26T13:56:01.063Z","comments":true,"path":"2021/11/26/20211126/","link":"","permalink":"http://spcablast.club/2021/11/26/20211126/","excerpt":"","text":"###746. 使用最小花费爬楼梯数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 示例 1： 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2： 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; //用动态规划的思想来分析 //首先，如果只有一个台阶，那我就用这个， //如果有两个台阶，选小的那个 //如果有三个台阶，是否到达第三个台阶，判断从2跳过3大还是1到3大 //默认我已经站在某个台阶了，我只要判断是跳一步还是跳两步 // if(cost.size() == 0) return 0; // if(cost.size() == 1) return cost[0]; // int i = 1, r = 0, g = cost[0], b = cost[1], ans = 0, step = -1;//r是-1，g是中间， // while(i &lt; cost.size())&#123; // if(ans + cost[i-1] &gt; ans + cost[i])&#123;//0+cost[0] &gt; 0+cost[1] // i += 2; // ans += cost[i]; // &#125; // else // &#123; // i++; // ans += cost[i-1]; // &#125; // &#125; // return ans; //那我又倒了，再来一遍 int n = cost.size(); vector&lt;int&gt; dp(n + 1);//多了前置一位和后置一位 dp[0] = 0; dp[1] = 0; for(int i = 2;i &lt; n+1;i++)&#123; dp[i] = min(cost[i-1] + dp[i-1], cost[i-2] + dp[i-2]); &#125; return dp[n]; &#125;&#125;; ###722. 删除注释给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 这表示每行源码由\\n分隔。 在 C++ 中有两种注释风格，行内注释和块注释。 字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。 字符串/* 表示一个块注释，它表示直到/的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串//并没有结束块注释，因为注释的结尾与开头相重叠。 第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。 同样，如果字符串/*出现在行或块注释中也会被忽略。 如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。 样例中没有控制字符，单引号或双引号字符。比如，source = “string s = “/* Not a comment. */“;” 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。） 我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。 最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。 从源代码中删除注释后，需要以相同的格式返回源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Solution &#123;public: // vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; // vector&lt;string&gt; ans, empty; // bool del = false; // string current = \"\"; // for(int i = 0; i&lt; source.size();i++)&#123; // //先判断有没有// // if(source[i].size()&gt;=2)&#123;//获得一个 // char former = source[i][0], cur = source[i][1]; // current.push_back(former);//先压一个 // for(int j = 1;j&lt;source[i].size();++j)&#123; // cur = source[i][j]; // former = source[i][j-1]; // if(former == '/'&amp;&amp;cur == '*')&#123;//标志位置1,后边不要 // current.pop_back();//吐出/ // del = true; // &#125; // else if(former == '*' &amp;&amp; cur == '/')&#123;//标志位置0，开始要 // current.pop_back();//吐出/ // del = false; // j++; // &#125; // else if(former == '/' &amp;&amp; cur =='/')&#123;//后边都不要 // break; // &#125; // else &#123; // current.push_back(cur); // if(del)&#123; // current.pop_back(); // &#125; // &#125; // //如果到头了，没有*/那就continue // //if((j == source[i].size()) &amp;&amp; del)&#123; // // continue; // //&#125; // &#125; // if(current.size() &amp;&amp; !del)&#123;//这行正常，或者这行string+ // ，或这行有*/ // ans.push_back(current);//这一行完了， // string().swap(current); // &#125; // &#125; // else&#123; // ans.push_back(source[i]); // //string().swap(current); // &#125; // &#125; // return ans; // &#125; vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123; bool isComment = false; vector&lt;string&gt; res; string curr = \"\"; for (string s : source) &#123; // cout &lt;&lt; s &lt;&lt; endl; int i = 0; if (!isComment) &#123; curr = \"\"; &#125; int n = s.size(); while (i &lt; n) &#123; if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '*') &#123; isComment = true; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '*' &amp;&amp; s[i+1] == '/') &#123; isComment = false; // 继续找下去,这里实际要+2，但是后面会+1 ++i; &#125; else if (!isComment &amp;&amp; i &lt; n-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '/') &#123; break; &#125; else if (!isComment) &#123; curr += s[i]; // cout &lt;&lt; curr&lt;&lt; \" \" &lt;&lt; endl; &#125; ++i; &#125; if (!isComment &amp;&amp; !curr.empty()) &#123; res.push_back(curr); &#125; &#125; return res; &#125;&#125;; 吐槽：！他思路和我一样，代码也和我一样，我就过不去，啊我好菜啊","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211125","date":"2021-11-24T16:00:00.000Z","updated":"2021-11-27T01:27:14.223Z","comments":true,"path":"2021/11/25/20211125/","link":"","permalink":"http://spcablast.club/2021/11/25/20211125/","excerpt":"","text":"###509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1给你 n ，请计算 F(n) 。 12345678910111213141516171819202122232425262728293031class Solution &#123;public://今日吐槽：因为是中午，所以有力气吐槽//人是有限的，精神呀，还是体力呀，精神又包括注意力，记忆力，操控自己做哪件事不做哪件事也需要消耗精神力，体力，只要没睡觉，都在消耗体力//那么既然人是有限的，而一天要完成的活动是有量的，假使这个人的能量恰好或者很难完成所有的活动//这样很容易就能得到一个结论，//先在精神力和体力都充足的时候把一定要完成的事情做完了，在能量消耗过多的时候通过特定的行为恢复一部分能量，比如睡了，吃点//如果还是不能完成所有的活动，那么就一定会放弃一些事情，或者粗略的完成一些事情，否则就到第二天了//以及，我以为的只是我现在以为的 int fib(int n) &#123;//怎么用动态规划的思想做这道题嘞//因为斐波那契数列第三个后，每一个数都是由前两个加起来的到的，所以存在递推关系//关键词：// 边界条件：F(0) = 0, F(1) = 1;这是这个问题的起始点，所有的数都由这两个开始// F(n) = F(n-1) + F(n-2)直到 n == 2// 现在是22点13分，继续// 根据以上的推论，递推公式有了，边界条件有了，就可以写代码了，好了 int i = 2; if(n &lt; 2) return n; //用三个变量存所需的所有变量 long long p = 0, q = 1, r = 2; while(i&lt;=n)&#123; r = p + q; p = q; q = r; i++; &#125; return r; //好了，哪里用了动态规划的思想呢，r = p + q, &#125;&#125;; 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int ans = 0; bool arrive(int step)&#123; if(step &lt; 0 ) return false; if(step == 0) &#123; ans += 1; return true; &#125; else if(arrive(step - 1) &amp;&amp; arrive(step - 2)); return true; &#125; int climbStairs(int n) &#123; //我天下无敌了，好了，大概吧 //走一步，或两步一次，到顶 //那就可以从顶开始减，减一或者减二，直到为0. //那边界条件就是n = 0 //每次执行的操作是减一或者减二，可以来个递归，最后n &lt; 0 返回无法到达，n == 0返回可以到达 //int ans = 0; //arrive(n); //return ans; //那我还是太菜了呀，每次从顶上下来是减一或者减二，说明dp[i] = dp[i-1] + dp[i-2],我站在这个台阶，从前一个台阶上来一种，或者是从前2个台阶上来的第二种，有两个状态可以到达我这个状态，每一个状态都有两个状态可以转移过来，就得到了递推公式，那我上面的递归也没问题吧，为什么超时了呢 int p = 0, q = 0, r = 1; for (int i = 1; i &lt;= n; ++i) &#123; p = q; q = r; r = p + q; &#125; return r; &#125;&#125;; 今日吐槽：又是无力吐槽的一天","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"动态规划 - 算法题","slug":"动态规划-算法题","permalink":"http://spcablast.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211124","date":"2021-11-23T16:00:00.000Z","updated":"2021-11-24T14:07:12.515Z","comments":true,"path":"2021/11/24/20211124/","link":"","permalink":"http://spcablast.club/2021/11/24/20211124/","excerpt":"","text":"祖父节点值为偶数的节点和给你一棵二叉树，请你返回满足以下条件的所有节点的值之和： 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）如果不存在祖父节点值为偶数的节点，那么返回 0 。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;//笑死，祖父节点，难道要判断一个节点有几个孙子节点，那就可以直接深度嘛，我只要遍历到倒数第二层就完事儿了//o，要孙子节点的值加起来啊，我还以为是加爷爷节点的值int ans = 0;public: void dfs(int gp_val, int p_val, TreeNode* node) &#123; if (!node) &#123; return; &#125; if (gp_val % 2 == 0) &#123; ans += node-&gt;val; &#125; dfs(p_val, node-&gt;val, node-&gt;left); dfs(p_val, node-&gt;val, node-&gt;right); &#125; int sumEvenGrandparent(TreeNode* root) &#123; dfs(1, 1, root); return ans; &#125;&#125;; 二进制表示中质数个计算置位给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 12345678910111213class Solution &#123;public: int countPrimeSetBits(int left, int right) &#123; int a[20] = &#123;0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1&#125;; int res = 0; for (int i = left; i &lt;= right; ++i) &#123; res += a[__builtin_popcount(i)];//还有算整数转二进制数的1的个数的函数，怪了 &#125; return res; &#125;&#125;;//[作者](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/cchao-100de-jian-dan-jie-fa-by-ffreturn-pj11/)","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作和 - 算法题","slug":"vector操作和-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C%E5%92%8C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211123","date":"2021-11-22T16:00:00.000Z","updated":"2021-11-23T12:11:49.828Z","comments":true,"path":"2021/11/23/20211123/","link":"","permalink":"http://spcablast.club/2021/11/23/20211123/","excerpt":"","text":"###1389. 按既定顺序创建目标数组给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。重复上一步，直到在 nums 和 index 中都没有要读取的元素。请你返回目标数组。 题目保证数字插入位置总是存在。 1234567891011class Solution &#123;public: vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) &#123; //这题目可太绕了，在新数组index[i]的值的序号处，插入nums[i] vector &lt;int&gt; r; for (unsigned i = 0; i &lt; nums.size(); ++i) &#123; r.insert(r.begin() + index[i], nums[i]); &#125; return r; &#125;&#125;; ###面试题 05.02. 二进制数转字符串二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。 示例1: 输入：0.625 输出：”0.101”示例2: 输入：0.1 输出：”ERROR” 提示：0.1无法被二进制准确表示提示： 32位包括输出中的”0.”这两位。 12345678910111213141516171819class Solution &#123;public: string printBin(double num) &#123; //从2的-1次方开始减，减到2的-32次方，如果中间都大于这个2的多少次放，说明那一次能减，如果有一次减到了0，说明能表示，如果不能，error //那这样就可以从2的-1次方加，能加就加，给个1，不能加给个0，加到2的-32次方，0.1010001 string ans = \"0.\"; while(num != 0)&#123;//怪了，double怎么能判断!=0的 num*=2; if(num&gt;=1)&#123; ans += \"1\"; num -= 1; &#125; else ans+=\"0\"; if(ans.size()&gt;32) return \"ERROR\"; &#125; return ans; &#125;&#125;; 正经吐槽：怎么还能拿double和0 == 的，这合适吗，这一点都不合适，不应该double - 0 &gt; 1.79E+308嘛 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"vector操作和 - 算法题","slug":"vector操作和-算法题","permalink":"http://spcablast.club/tags/vector%E6%93%8D%E4%BD%9C%E5%92%8C-%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211122","date":"2021-11-21T16:00:00.000Z","updated":"2021-11-28T14:20:24.993Z","comments":true,"path":"2021/11/22/20211122/","link":"","permalink":"http://spcablast.club/2021/11/22/20211122/","excerpt":"","text":"384打乱数组给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象int[] reset() 重设数组到它的初始状态并返回int[] shuffle() 返回数组随机打乱后的结果 题（吐）解（槽）：这又是数学题，排列组合和概率问题，实现每一位出现其中的数字的概率都相同，可以这样做，也可以每一位随机一个数，再在整体里删了用过的数 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; m_nums; vector&lt;int&gt; origin; Solution(vector&lt;int&gt;&amp; nums) &#123; //copy(m_nums.begin(),nums.begin(),nums.end()); m_nums = nums; origin = nums; &#125; vector&lt;int&gt; reset() &#123; return origin; &#125; vector&lt;int&gt; shuffle() &#123; int temp = 0, index = 0, len = m_nums.size(); for(int i = 0; i &lt; len; i++)&#123; temp = m_nums[i]; index = i + rand() % (len - i); m_nums[i] = m_nums[index]; m_nums[index] = temp; &#125; return m_nums; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */ ###剑指 Offer 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]示例 2： 输入：arr = [0,1,2,1], k = 1输出：[0] 123456789101112class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; sort(arr.begin(),arr.end()); //if(arr.size() == 0) return null; vector&lt;int&gt; ans; for(int i = 0;i &lt; k; i++)&#123; ans.push_back(arr[i]); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211121","date":"2021-11-20T16:00:00.000Z","updated":"2021-11-21T14:56:01.423Z","comments":true,"path":"2021/11/21/20211121/","link":"","permalink":"http://spcablast.club/2021/11/21/20211121/","excerpt":"","text":"###8. 字符串转换整数 (atoi)请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: //我又倒了，我应该学一下怎么写自动机的，或者是正则表达式 //int myAtoi(string s) &#123; //丢空格 //起始是正负号，或者没有 //有数字转数字，没数字返回0 //大于INT_MAX返回INT_MAX小于INT_MIN返回INT_MIN //为什么我用VS和这里结果不一样 // if(s.size() == 0) return 0; // long flag = 1 ,temp = 0, ans = 0; // for(int i =0; i &lt; s.size(); ++i)&#123; // //先都当负数，有正负号存到flag里 // if(s[i] == ' ')&#123; // &#125; // else&#123; // if(s[i] == '+')&#123; // flag = 1; // &#125; // else if(s[i] == '-')&#123; // flag = 0; // &#125; // else if((s[i] - '0')&gt;=0 &amp;&amp; (s[i] - '0')&lt;=9)&#123; // temp = s[i] - '0'; // ans = ans*10 - temp; // &#125; // else // break; // &#125; // &#125; // ans = flag?-ans:ans; // if(ans &gt; INT_MAX) return INT_MAX; // if(ans &lt; INT_MIN) return INT_MIN; // return ans; // &#125; //考虑到各种情况的题解 //这题目不仅要取出数字，还得判断是不是一个正常意义的数字 int myAtoi(string str) &#123; unsigned long len = str.length(); // 去除前导空格 int index = 0; while (index &lt; len) &#123; if (str[index] != ' ') &#123; break; &#125; index++; &#125; if (index == len) &#123; return 0; &#125; int sign = 1; // 处理第 1 个非空字符为正负符号，这两个判断需要写在一起 if (str[index] == '+') &#123; index++; &#125; else if (str[index] == '-') &#123; sign = -1; index++; &#125; // 根据题目限制，只能使用 int 类型 int res = 0; while (index &lt; len) &#123; char curChar = str[index]; if (curChar &lt; '0' || curChar &gt; '9') &#123; break; &#125; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; (curChar - '0') &gt; INT_MAX % 10)) &#123; return INT_MAX; &#125; if (res &lt; INT_MIN / 10 || (res == INT_MIN / 10 &amp;&amp; (curChar - '0') &gt; -(INT_MIN % 10))) &#123; return INT_MIN; &#125; res = res * 10 + sign * (curChar - '0'); index++; &#125; return res; &#125;&#125;; ###908. 最小差值 I给你一个整数数组 nums，请你给数组中的每个元素 nums[i] 都加上一个任意数字 x （-k &lt;= x &lt;= k），从而得到一个新数组 result 。 返回数组 result 的最大值和最小值之间可能存在的最小差值。 示例 1： 输入：nums = [1], k = 0输出：0解释：result = [1]示例 2： 输入：nums = [0,10], k = 2输出：6解释：result = [2,8]示例 3： 输入：nums = [1,3,6], k = 3输出：0解释：result = [3,3,3] or result = [4,4,4] 提示： 1 &lt;= nums.length &lt;= 100000 &lt;= nums[i] &lt;= 100000 &lt;= k &lt;= 10000 123456789101112class Solution &#123;public: int smallestRangeI(vector&lt;int&gt;&amp; nums, int k) &#123; int min = INT_MAX,max = INT_MIN; for(int num :nums)&#123; if(num &lt; min) min = num; if(num &gt; max) max = num; &#125; int ans = max - min - 2*k; return ans&gt;=0?ans:0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211120","date":"2021-11-19T16:00:00.000Z","updated":"2021-11-20T13:50:15.758Z","comments":true,"path":"2021/11/20/20211120/","link":"","permalink":"http://spcablast.club/2021/11/20/20211120/","excerpt":"","text":"###剑指 Offer 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 12345678910111213141516class Solution &#123;public: int fib(int n) &#123; int i &#x3D; 0, j &#x3D; 1, temp, ans; if(n &#x3D;&#x3D; 0) return 0; if(n &#x3D;&#x3D; 1) return 1; for(int k &#x3D; 1; k&lt;n;k++)&#123; ans &#x3D; i + j; temp &#x3D; k; i &#x3D; j; j &#x3D; ans % (1000000007); &#125; ans &#x3D; ans % (1000000007); return ans; &#125;&#125;; ###29. 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3题（吐）解（槽）：这题也太离谱了，我提交了16次，边界情况这么多,以及我写的方法又死了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: int divide(int dividend, int divisor) &#123; &#x2F;&#x2F;被除数为最小值，除数分别为1和-1 if (dividend &#x3D;&#x3D; INT_MIN) &#123; if (divisor &#x3D;&#x3D; 1) &#123; return INT_MIN; &#125; if (divisor &#x3D;&#x3D; -1) &#123; return INT_MAX; &#125; &#125; if(divisor &#x3D;&#x3D; INT_MIN)&#123; if(dividend &#x3D;&#x3D; INT_MIN)&#123; return 1; &#125; return 0; &#125; if(divisor &#x3D;&#x3D; 0 ) return 0; &#x2F;&#x2F;一定要转成负的，因为如果被除数是INT_MIN不好表示 bool flag &#x3D; false; int m_dividend &#x3D; 0, m_divisor &#x3D; 0, ans &#x3D; 0; if(dividend &gt; 0)&#123; m_dividend &#x3D; -dividend; flag &#x3D; !flag; &#125; else m_dividend &#x3D; dividend; if(divisor &gt; 0)&#123; m_divisor &#x3D; -divisor; flag &#x3D; !flag; &#125; else m_divisor &#x3D; divisor; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 vector&lt;int&gt; listDividend &#x3D; &#123;m_divisor&#125;; while(m_dividend - m_divisor &lt;&#x3D; m_divisor)&#123; m_divisor +&#x3D; m_divisor; listDividend.push_back(m_divisor); &#125; for(int i &#x3D; listDividend.size() -1; i&gt;&#x3D;0 ; i--)&#123; if(listDividend[i] &gt;&#x3D; m_dividend)&#123; ans +&#x3D; 1 &lt;&lt; i; m_dividend -&#x3D; listDividend[i]; &#125; &#125; return flag?-ans:ans; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D;&#x3D; -1)return -dividend; &#x2F;&#x2F; int ans &#x3D; 0, temp &#x3D; abs(divisor), totle &#x3D; 0, m_dividend &#x3D; abs(dividend); &#x2F;&#x2F; while(m_dividend -totle &gt;&#x3D; temp)&#123; &#x2F;&#x2F; totle +&#x3D; temp; &#x2F;&#x2F; ans++; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if((dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0)) &#x2F;&#x2F; return ans; &#x2F;&#x2F; else &#x2F;&#x2F; return -(ans); &#x2F;&#x2F; long m_dividend &#x3D; abs(dividend), m_divisor &#x3D; abs(divisor); &#x2F;&#x2F; if(divisor &#x3D; 1 )return dividend; &#x2F;&#x2F; if(divisor &#x3D; -1)return -dividend; &#x2F;&#x2F; int temp &#x3D; divisor, itera &#x3D; 1; &#x2F;&#x2F; &#x2F;&#x2F;我知道了，我一直把这个数乘2，到某一次乘2会大于等于被除数的时候，说明我到一半了 &#x2F;&#x2F; &#x2F;&#x2F;然后再用被除数减去这个时候的数，再重复之前的操作，直到某一次刚好等于或者被除数已经大于剩下的这个数了 &#x2F;&#x2F; while(m_divisor &lt; m_dividend)&#123; &#x2F;&#x2F; temp &#x3D; m_divisor; &#x2F;&#x2F; itera++; &#x2F;&#x2F; m_divisor +&#x3D; m_divisor; &#x2F;&#x2F; &#125; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211119","date":"2021-11-18T16:00:00.000Z","updated":"2021-11-20T01:02:59.852Z","comments":true,"path":"2021/11/19/20211119/","link":"","permalink":"http://spcablast.club/2021/11/19/20211119/","excerpt":"","text":"50. Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。 示例 1： 输入：x = 2.00000, n = 10输出：1024.00000示例 2： 输入：x = 2.10000, n = 3输出：9.26100示例 3： 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: double powe(long itera, double x)&#123; double ans &#x3D; 1, temp &#x3D; x; while(itera &gt; 0)&#123; if(itera%2 &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;ans &#x3D; x*temp; ans *&#x3D; temp; &#125; temp &#x3D; temp*temp; itera &gt;&gt;&#x3D; 1; &#125; return ans; &#125; double myPow(double x, int n) &#123; &#x2F;&#x2F;暴力方法超时了 &#x2F;&#x2F; double ans &#x3D; 1.00000; &#x2F;&#x2F; long nplus &#x3D; n; &#x2F;&#x2F; if(nplus &#x3D;&#x3D; 0) return 1; &#x2F;&#x2F; if(abs(abs(x) - ans) &lt;&#x3D; 0.000001) return x; &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; abs(nplus); i++)&#123; &#x2F;&#x2F; ans &#x3D; ans*x; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(nplus&lt;0)&#123; &#x2F;&#x2F; ans &#x3D; 1&#x2F;ans; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return ans; if(n &#x3D;&#x3D; 0) return 1.00000; if(abs(x - 1.00000) &lt; 2.22045e-16) return 1.000; long itera &#x3D; n; double ans; ans &#x3D; powe(abs(itera), x); return itera&gt;0?ans:1&#x2F;ans; &#125; &#125;; 598. 范围求和 II 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。 在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。 示例 1: 输入:m = 3, n = 3operations = [[2,2],[3,3]]输出: 4解释:初始状态, M =[[0, 0, 0], [0, 0, 0], [0, 0, 0]] 1234567891011class Solution &#123;public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) &#123; int mina &#x3D; m;int minb &#x3D; n; for(int i&#x3D;0;i&lt;ops.size();i++)&#123; mina &#x3D; mina&gt;ops[i][0]?ops[i][0]:mina; minb &#x3D; minb&gt;ops[i][1]?ops[i][1]:minb; &#125; return mina*minb; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"论意欲的自由","slug":"论道德和自由","date":"2021-11-17T16:00:00.000Z","updated":"2021-12-01T12:55:59.506Z","comments":true,"path":"2021/11/18/论道德和自由/","link":"","permalink":"http://spcablast.club/2021/11/18/%E8%AE%BA%E9%81%93%E5%BE%B7%E5%92%8C%E8%87%AA%E7%94%B1/","excerpt":"","text":"论意欲的自由 起因：挪威皇家科学院提出的问题 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是自由的？ 叔本华回答这个问题写了这篇论文 正文： 第一部分，先对几个关键概念定义 1.1自由 (叔本华认为）我们能想到的是：不存在任何起妨碍的作用的东西。根据妨碍的作用之物将自由分为三类： 身体、物质、上的自由 智力上的自由 道德上的自由。 A 身体、物质上的自由指的是不存在任何种类的物质障碍。比如：人和动物没有受到皮带、绳索、监狱、瘫痪等的阻碍，他们的身体与他们的意愿相符，那动物和人就称为自由的。这是原初的，直接的，最常见的涵义。 自由的哲学概念的涵义： B 智力上的自由。智力是动因传递到意识的媒介，智力的区别导致动因是否能准确，清晰的传递到人的意识之中。 C 道德(不是日常通用的那个道德的涵义)上的自由起始： 在人没有受到物质阻碍的情况下，一个人却可以纯粹受动因的制约而不会随心所欲的行事。（动因包括恐吓，许诺，危险等） 若要接受本文的推理过程，那就得接受以上物质上的智力上的和道德上的自由就包括了自由所有的范畴了，但是是吗 引出问题：受到如此制约的人是自由的吗？人的意愿会受到以上动因的影响，那么意愿本身是自由的吗？ 从物质上对自由的制约因素到精神上对自由的制约因继续推理：如此，自由的定义从仅指能否做出行为，到与意愿发生了关联。 这样，自由的定义: 不存在任何起妨碍的作用的东西， 就变成了: 与自己的意愿相符（如果我可以根据自己的意愿行事，那我就是自由的） 这个定义把问题：“我们的意愿本身是自由的吗”变成了废话 因为把自由的定义代入之后就变成了“我们的意愿本身是自由（与自己的意愿相符）的吗” 显然是的，但是没有告诉我们东西。 所以，问题：意愿的背后是否还有原因，意愿是否依赖于其他，意愿本身是自由的吗？为了解决这个问题，需要改变自由的定义。 得出新的自由的定义：自由：不存在任何必然性。 修改后的定义还是一个否定的定义，是前一个定义的抽象涵义 是吗是吗，不存在妨碍和不存在必然性这真的是一个东西？ 必然性： 某一充足原因（根据）引发出结果。（某样东西就是从某一原因引发的结果，我们就会知道这个结果是必然的。比如，逻辑方面，数学方面，物理方面，三角形的角度相同可以得到三角形的边长相同）也就是说，不存在任何必然性，就是不依赖于任何原因，也就是一个人的意愿在外现时，并不受到原因，或者理由的左右和决定，因为否则的话，一个人的意欲活动就不会是自由的，而是必然的了。 问题变成：能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 那么接下来讨论自身意识和人的意欲（意愿）的定义，通过自身意识来定义人的意欲。 1.2 自身意识 定义：对我们自身的意识。 这个定义是相对于我们对于其他事物的意识而言的。作者把意识分成对自身的意识和对其他事物的意识，分界线由自身的定义决定 人认知其他事物的认知功能的形式分为时间，空间，因果律。我们无法使用这些功能得到对自身的意识，只能用来掌握其他事物的客观知识。 认知官能首先是以直观的方式认识、把握这一现实外在世界；然后，认知官 能就反思、琢磨以此方式所获得的直观认识，并把这些认识加工、整理 成概念。在语词的帮助下对这些概念进行无穷尽的组合，就构成了思维活动。在减去了我们总体意识中这绝大部分的内容以后，所剩下的部分 就是对自身的意识. 问题：一个人是怎么意识到自身的？ 回答：自身意识的对象物是始终就是自己的意欲活动。（通过意欲活动感受到自身） 是不是说我们能感受到的关于自己的内容，都是自己的意欲活动。 意欲活动的外现：一切渴望、奋斗、愿望、希冀、怀念、爱恋、高兴、欢庆 等，还有就是不情愿和抗拒的感情，所有的厌恶、反感、害怕、愤怒、 憎恨、悲哀、痛苦，一句话，所有一切的情感和激情。 这些情感和激情都是我们意欲的骚动，我们的意欲要么得到满足，要么无法得到满足，与我们获得或错失我们的欲望之物、忍受或者去掉我们的厌恶之物有关。这些构成了我们内在感觉的对象。 那么可以说，当一个人完全感觉不到外部的世界之后，再没有情绪，他就感觉不到自己了？没有触觉听觉视觉味觉嗅觉 而这些自身意识或者说内在感觉的对象，和外在世界存在着联系。我们在外在世界的察觉的对象，是诱发上述活动的动因和材料。 这里把自身意识和外在世界联系起来了，联系关系是外在世界诱发自身意识的活动。 2.1意欲和自身意识的关系 当一个人意欲着，他就是意欲着某一对象物。意欲活动是我们自身意识的对象，某一事物进入到我们对其他事物的意识，意欲活动产生了。 >前半句算结论还是算假设呢，或者是即将被证明的假设？ 动因： 上一句的某一事物在与我们认知官能的关系中，被称为动因,也是意欲活动的素材。意欲活动的目标就是对动因产生反应。意欲活动的本质就在这个反应之中。得出结论:没有动因，意欲活动就不会产生 问题：如果这些事物进入到我们对其他事物的意识里，意欲活动是否必然发生？发生的意欲活动一定是一样的吗？也就是，意欲会不会对这些事物有所反应？在完全一样的条件下，意欲能否有彼此相反的反应？也就是说，意欲活动会由动因必然引起吗？ 自由不自由就在这了，如果一个动因对应一个意欲活动，那人就不是自由的了当动因进入意识的时候，意欲是否保留着活动或者不活动的完全自由？ 回顾问题： 能否通过人对自身的意识以显示和证明：人的意欲（意愿）是不存在任何必然性的吗？ 因为人对自身的意识 = 意欲活动，而意欲是由人对外部的意识引起的，对自身的意识不包含人对外部的意识，所以光凭人对自身的意识是不足以的得到问题的答案的。 人的自身的意识关于意欲活动的感受大致是： 我可以做我意欲要做的事。这句话真正的含义是，我们能做出与意欲相符的事。而我们无法意识到意欲的产生，只能感受到意欲产生之后，我们这么做了。无法说明我们的意欲活动的产生是否依赖于外在世界。 自身意识能感受意欲活动和操作身体。*还在酝酿过程中的是愿望，酝酿结束了的叫决定，在做出行为之后，这一行为才向自身意识表明这是决定，因为在付诸行动之前，愿望是能改变的。人们可以有相反的愿望，却只能意欲其中之一，因为到底意欲什么，只能通过做出的行动才让自身已是知道。 自身意识只包含了意欲活动，却不包含决定意欲活动的原因和理由（原因和理由在对其他事物的意识里） 那么问题就变成了： 一个人是否也和世界上的所有其他事物一样，由于自己的构成而从此成为一个明确的存在物，并且就像大自然的所有其他存在物一样，有着自己确定永恒的素质；这些素质随着外在机会的出现而必然作出反应；因此，这些素质从这方面看都带有其不变的特性（性格）；所以，这些素质以及那些可作些微调整的东西，是完全听任外在机会和诱因的限定和左右？抑或人类惟独就是大自然的例外？ 动因在进入人的意识之后，是否通过这个人的性格的处理，输出一个确定的结果，形成一个唯一的确定的意欲活动？他想说的是我可以这样做，也可以完全相反的那么做，但是由于我个人的性格，我最后只会选择一个确定的行为。 一个人的意欲就是他本身，这个人存在的真正内核。人的意欲构成了人的意识的基础。他就是想说人的性格是确定的，不变的，天生的，后天的经验无法改变一个人的性格， 3.1意欲和我们对其他的意识 让我们观察那些受意欲驱使着的意欲生物。把因果律的原因分为三种：原因，刺激，动因3.1.1原因指的是机械的物理的化学的变化3.1.2刺激指的是适当的刺激引起相应的变化//那个时候的科学不太行，这俩都不是很合适3.1.3动因以认知为媒介的因果作用。动物的活动随着动因展开，在动物的自身意识中由动因引起的内在动力叫做意欲。 人的行为动因大多是思想和念头，目前时空形成的的动因不多。所有的动因都是原因，所有的因果都有其必然性。 举个例子：我可以做出我所意欲的事情。如果我意欲（愿意）的话，我可以把我所拥有的一切捐献给穷人，以致自己也成为穷人中的一员——如果我意欲（愿意）的话！但我却无法真有这样的意欲，因为与此相反的动因 对我产生了太强有力的作用。而如果我的性格是另外一种样子，甚至是一个圣人，那我就会有捐献所拥有的一切的意欲。我真要是这样的圣人，那我就不这样意欲也不行。也就是说，我就必然要这样做。所有这些都与自身意识中的表白“我可以做出我所意欲的事情”并行不悖。 *性格首要决定了各种不同的动因在某一个人 身上的作用方式，因为动因所引出的所有结果，其基础根源是性格，正如由最狭窄意义上的原因所引出的结果，其基础根源是普遍自然力，由 刺激所引出的结果，其基础根源是生命力一样。与自然力一样，性格同样是原初的、无法改变的和无法解释的。 每个人的性格不一样； 性格是在经验之后才能了解到的； 性格是持续如一的； 性格是与生俱来的；人由于自己的性格始终不渝的追求自己的目标，性格无法改变，能通过改变他的认知改变他追求这个目标的方法和手段。 有什么用呢，比如我以为明天能早起，我下定决心等会儿去跑步，我以为我到了那个点就会去跑步，而事实上，根据我的性格，也就是意欲，也就是那个使我不同与其他人的那个事物，决定了我等会儿并不会去跑步，而是回去坐着。那这个又有什么用呢，可以根据我的性格，设置一个行为，比如走在路上突然跑起来，我就会跑回去（因为我的性格是万事开头难，开了个头就会想做完，做完了或者受到不可抗力打断才会中断），跑着跑着跑到楼下就算热好身了，甚至还有可能会练一会别的。 结论怎么来的呢，不知道，我在中途绕进去了，建议看原文结论：有了既定的动因和确定的性格，那么必然引出一定的行为结果。所有发生的事情，无论大小，都是必然地发生。 这些结论可以给作者提供平静和安慰，我觉得这样就少了人定胜天的那种感觉，既然胜天都是注定了，那么胜天也就没有失去了应该有的那种感觉。 4.1先行者列举了一些历史上对这个问题发表过意见的伟人。顺便骂了几个人（比如黑格尔）命运引领情愿者，单但拖曳不情愿的人。 –伏尔泰所以，我们可以承认：如果我们真有可能对一个人的思维方式——这通过内在和外在的行为呈现出来——有一深刻的了解，清楚 知道这个人行为后面的每一或大或小的推动力，以及所有能够影响 这个人的思维方式的外在诱因，那我们就像可以确切计算出在何时 日食、月食一样地确切计算出一个人将来的行为。 –康德 这证实了这一已得到人们承认和赞扬的格言：在科学的探索中，我们都要尽可能地精准和诚实，不受干扰地走自己的路；不要 担心自己的探索是否有可能与这一学科以外的事情相抵触，而要尽我们所能真实、完美地把这一探索工作本身进行到底。我经常看到 的情形让我确信：当我们的探索工作完结以后，那在探索进行过程 中，在考虑到其他领域的学说时，有些东西有时候会显得大有疑 问；但只要我把这些疑问置之不理，心无旁骛地专注于自己的探索 直至完成，那原先似乎大有疑问的东西，却出乎预料地与在丝毫没 有顾虑到别人的学说、对那些东西既没有先入为主的偏好也没有偏 恶的情况下，所独自发现的东西完全吻合。只要著作者能够下定决 心，更加诚实地投入工作中去，那他们就会避免犯下许多的错误， 避免无谓浪费那么多的精力。（《实践理性批判》第四版，190 页） –康德 哲学家的武器是事实的理据，而不是权威的言论。（由于我没有跟上他的思路推出来结论，只能放点结论了） *“他是个坏人，是个恶棍，或者“这是个无赖，或者“他是个渺小、下作、虚假的 人，等等。这就是人们的判定；人们的指责总是针对这个人的性格。 做出的行为连带其动因，纯粹只是表明行为人的性格的证据而已；行为只是这个人的性格的外相，而这个人的性格已是永远和无法逆转地确定了下来。所以，亚里士多德说得很对，“我们赞扬做出了某一行为的 人，但那些行为只是显示了做出行为的人的性格而已。就算是行为还没 有做出来，但只要我们相信这个人会做出这样的行为，那我们仍然会赞 扬这个人。因此，引起我们厌恶、鄙视和憎恨的，并不是那瞬间就过 去了的行为，而是做出这些行为的人身上那些永远存在的素质，亦即性格。因此，在所有的语言里，形容道德败坏的词语、标示劣性的绰号都 是对人更甚于对事，因为性格才应该承担罪责，而这罪责只是因为有了 机会才通过做出行为得到证实。结论： 一个人永远只做出他所意欲（愿）的行为，但他做出这样的行为其实是必然的。原因全在于这个人已经就是他所意欲：因为只要这个人是这样的人，那必然就会做出所有这样的事情。如果我们客观（体）考察这个人的行事，亦即从外在考察这些所为，那我们就会确实 无疑地认出：这些行为和大自然每一存在物的发挥是一样的，都是严格 受制于因果法则。从主观（体）上看，每个人都感觉自己总是按照自己 的意欲行事。但这只说明了他的发挥（行为），只是他自身本质的纯粹外现而已。所以，大自然的每一存在物，甚至最低级的一类，都会有这同一样的感觉——如果它们能够感觉的话。//我是我 再贴一段： 因此，大致上而言，所有在当事人当时不知道自己在干什么或者完全没有能力考虑到制止这样做的理由，亦即在没有能力考虑到事情后果 的情况下所犯下的罪行，都可视为在欠缺智力自由的情况下的犯罪。因 此，这种情形的犯罪，犯罪者是不应受到惩罚的。 但如果人们认为：由于没有道德上的自由，因此，一个人做出某种行为是不可避免的，所以，犯下罪行的人不应该受到惩罚，那他们可是 理解错了刑罚的目的。也就是说，他们误以为对罪犯实施惩罚是因为罪 行本身的缘故，是基于道德理由的以牙还牙的报复。虽然康德也教导这 样的观点，但这样的惩罚却是荒谬的、没有任何目的的、绝对是没有任 何理由的。这是因为一个人又有何权利以绝对法官自居去判断他人的道 德，并因为他人的罪过而对其加以折磨！其实，法律——亦即威胁给予 惩罚——目的却是要成为制止人们将来犯罪的相反动因。如果在某些情 形里，法律起不到这样的制约作用，那也得执行法律，因为如果法律得 不到实行，那在将来的所有情形里，法律都将无法再发挥制约的作用。 在罪犯方面，罪犯在这种情况下遭受惩罚是自己的道德品质所致——罪 犯自己的道德品质与那外在环境的动因，再加上误导自己让自己以为可 以侥幸逃脱惩罚的智力，三者结合起来，不可避免地促成了犯罪。在这 种情况下，只有当事人的道德性格并不是这个人自己的作品，并不是认 知的行为，而是他人的作品，那他遭受惩罚才是不公正的。如果一个人 罪恶行为的结果并不是人为的，而是遵循大自然的规则，那行为与其后 果也是一样的关系。例如，如果因放肆纵欲而导致疾病，又或者，如果 一个人在夜间闯入别人的猪圈，试图盗走里面的猪，但却碰上碰巧在这过夜的主人寄宿在这猪圈里的大熊。 既然一切都是确定的，那么对于个人来说，只知道是确定的而不知道确定的内容是什么，那么未来就还是未知的，只不过能更加平静地对待以后会发生的一切事情，和以往发生的一切事情，因为都是注定的，人的性格决定了他知道了一切都是确定的之后会做出的反应。 上面对自身的意识和对外界的意识分的比较怪，可能是为了方便论证。 论文里还有点对道德和良心的论述，因为性格是确定的，所以善恶也确定了，良心是事情发生后对事情的反思。//由于后面跟不上了，只能贴很多原文，建议看原文，100页左右。","categories":[{"name":"书","slug":"书","permalink":"http://spcablast.club/categories/%E4%B9%A6/"}],"tags":[{"name":"叔本华","slug":"叔本华","permalink":"http://spcablast.club/tags/%E5%8F%94%E6%9C%AC%E5%8D%8E/"},{"name":"自由","slug":"自由","permalink":"http://spcablast.club/tags/%E8%87%AA%E7%94%B1/"},{"name":"意欲","slug":"意欲","permalink":"http://spcablast.club/tags/%E6%84%8F%E6%AC%B2/"},{"name":"推理","slug":"推理","permalink":"http://spcablast.club/tags/%E6%8E%A8%E7%90%86/"}],"author":"YP"},{"title":"Dailycode","slug":"20211118","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:55:18.810Z","comments":true,"path":"2021/11/18/20211118/","link":"","permalink":"http://spcablast.club/2021/11/18/20211118/","excerpt":"","text":"###48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 题（吐）解（槽）：今天无力吐槽，干活 123456789101112131415161718192021class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#x2F;&#x2F;外圈到内圈轮流换位置 &#x2F;&#x2F;圈数等于n&#x2F;2 &#x2F;&#x2F;1 1 &#x2F;&#x2F; &#x2F;&#x2F;3 4 &#x2F;&#x2F;转起来（0+1，0）（0+1，n-1）(n-1,n-1-1)(0,n-1-1) int n &#x3D; matrix.size(); for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123; for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; ++j) &#123; int temp &#x3D; matrix[i][j]; matrix[i][j] &#x3D; matrix[n - j - 1][i]; matrix[n - j - 1][i] &#x3D; matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] &#x3D; matrix[j][n - i - 1]; matrix[j][n - i - 1] &#x3D; temp; &#125; &#125; &#125;&#125;; ###771. 宝石与石头 给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 字母区分大小写，因此 “a” 和 “A” 是不同类型的石头。 示例 1： 输入：jewels = “aA”, stones = “aAAbbbb”输出：3示例 2： 输入：jewels = “z”, stones = “ZZ”输出：0 123456789101112131415class Solution &#123;public: int numJewelsInStones(string jewels, string stones) &#123; int ans &#x3D; 0; for(int i &#x3D; 0;i&lt;jewels.size();i++)&#123; int cur &#x3D; jewels[i] - &#39;0&#39;; for(int j &#x3D; 0; j&lt;stones.size();j++)&#123; if(stones[j] - &#39;0&#39; &#x3D;&#x3D; cur)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"ffmpeg操作","slug":"ffmpeg操作","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-18T11:57:41.824Z","comments":true,"path":"2021/11/18/ffmpeg操作/","link":"","permalink":"http://spcablast.club/2021/11/18/ffmpeg%E6%93%8D%E4%BD%9C/","excerpt":"","text":"ffmpeg.exe -i aa.mp4 -y -f image2 -ss 8 -t 0.01 -s 800x600 test.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpgffmpeg -i test.mp4 -r 30 -t 4 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 image-%3d.jpgffmpeg -i test.mp4 -r 30 -ss 00:00:20 -vframes 10 image-%3d.jpgffmpeg -i test.mp4 -r 30 image-%3d.jpg -i file name-r frame/s-f ..F… set commands file-ss time_off set the start time offset-t duration record or transcode “duration” seconds of audio/video","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"-ffmpeg命令行操作","slug":"ffmpeg命令行操作","permalink":"http://spcablast.club/tags/ffmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"}],"author":"YP"},{"title":"VSCode","slug":"VScode的配置","date":"2021-11-17T16:00:00.000Z","updated":"2021-11-20T00:47:46.999Z","comments":true,"path":"2021/11/18/VScode的配置/","link":"","permalink":"http://spcablast.club/2021/11/18/VScode%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"最近要 机器 学习了，down个VSCode用用 pip install flake8装了个flake8,获得了语法提示 pip install yapf装个yapf，Alt+Shift+F可以自动化格式代码 setting.json设置一下 123456&#123; \"workbench.colorTheme\": \"Default Dark+\", \"python.defaultInterpreterPath\": \"C:\\\\Program Files\\\\Python39\\\\python.exe\", \"python.linting.flake8Enabled\": true, \"python.formatting.provider\": \"yapf\"&#125;","categories":[{"name":"VSCode","slug":"VSCode","permalink":"http://spcablast.club/categories/VSCode/"}],"tags":[],"author":"YP"},{"title":"Dailycode","slug":"20211117","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-17T13:42:26.191Z","comments":true,"path":"2021/11/17/20211117/","link":"","permalink":"http://spcablast.club/2021/11/17/20211117/","excerpt":"","text":"###1552. 两球之间的磁力在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 题解：干啊，思路有了，写出来还差一点 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool legal(int m, vector&lt;int&gt;&amp; position, int k)&#123; int pre &#x3D; position[0], count &#x3D; 1; for(int i &#x3D; 0;i &lt; position.size();++i)&#123; if(position[i] - pre &gt;&#x3D; m)&#123; pre &#x3D; position[i]; count++; &#125; &#125; if(count &gt;&#x3D; k) return true; else return false; &#125; int maxDistance(vector&lt;int&gt;&amp; position, int m) &#123; &#x2F;&#x2F;又是数学题，gan啊 &#x2F;&#x2F;阅读理解：数轴上n点，position[i], 激活m个点，找到使得m个点中每两个点的距离都尽可能的大的位置 &#x2F;&#x2F;既然这样，首尾两个球肯定是要用的，然后求中间的值，看最接近的是哪个，这样就有两段，分别取中值，找最接近的，比较四段长度 &#x2F;&#x2F;那我岂不是可以排序，然后求出所有的间隔，由大到小，不行 &#x2F;&#x2F;好像懂了，太顶了，直接找答案，答案就在0到最大值减去最小值，然后对这个值进行二分查找，存在m个长度的段大于等于这个值就对了，多于m个说明这个值可以加，小于m说明这个值得减 sort(position.begin(),position.end()); int l &#x3D; position.size(); int dis &#x3D; position[l -1] - position[0]; int left &#x3D; 1, right &#x3D; dis, prelen &#x3D; 0, ans &#x3D; -1; while(left &lt;&#x3D; right)&#123; int mid &#x3D; (right + left) &#x2F;2; if(legal(mid, position, m))&#123;&#x2F;&#x2F;如果有m个大于等于len，说明m小了 ans &#x3D; mid; left &#x3D; mid + 1; &#125; else&#123; right &#x3D; mid - 1; &#125; &#125; return ans; &#125;&#125;; ###169. 多数元素给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：[3,2,3]输出：3示例 2： 输入：[2,2,1,1,1,2,2]输出：2 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 题解： 123456789101112131415161718192021222324252627class Solution &#123;public: &#x2F;&#x2F;这题我见过，用哈希map吧，map好像还行，不如哈希 &#x2F;&#x2F;进阶挺难的 int majorityElement(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F; unordered_map&lt;int, int&gt; counts; &#x2F;&#x2F; int majority &#x3D; 0, cnt &#x3D; 0; &#x2F;&#x2F; for (int num: nums) &#123; &#x2F;&#x2F; ++counts[num]; &#x2F;&#x2F; if (counts[num] &gt; cnt) &#123; &#x2F;&#x2F; majority &#x3D; num; &#x2F;&#x2F; cnt &#x3D; counts[num]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return majority; unordered_map&lt;int,int&gt; map; int ans &#x3D; 0, count &#x3D; 0; for(int num:nums)&#123; ++map[num]; if(map[num] &gt; count)&#123; ans &#x3D; num; count &#x3D; map[num]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211116","date":"2021-11-15T16:00:00.000Z","updated":"2021-11-17T04:57:58.142Z","comments":true,"path":"2021/11/16/20211116/","link":"","permalink":"http://spcablast.club/2021/11/16/20211116/","excerpt":"","text":"###67. 二进制求和给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = “11”, b = “1”输出: “100”示例 2: 输入: a = “1010”, b = “1011”输出: “10101” 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。1 &lt;= a.length, b.length &lt;= 10^4字符串如果不是 “0” ，就都不含前导零。 题解分四种情况不如官方题解直接分两种情况，优化代码，不可能优化的，字符串的操作还得多学 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string addBinary(string a, string b) &#123; &#x2F;&#x2F;先把字符串倒过来，用两个数存长度， &#x2F;&#x2F;a &#x3D; a.reverse(); &#x2F;&#x2F;b &#x3D; b.reverse(); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); string ans; int acc &#x3D; 0; char tempa, tempb; int la &#x3D; a.size(), lb &#x3D; b.size(); for(int i &#x3D; 0; (i &lt; la || i &lt; lb); i++)&#123; if(i&lt;la) tempa &#x3D; a[i]; else tempa &#x3D; &#39;0&#39;; if(i&lt;lb) tempb &#x3D; b[i]; else tempb &#x3D; &#39;0&#39;; if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 3) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 2) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 1; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 1) &#123; ans.push_back(&#39;1&#39;); acc &#x3D; 0; &#125; else if(tempa - &#39;0&#39; + tempb - &#39;0&#39; + acc &#x3D;&#x3D; 0) &#123; ans.push_back(&#39;0&#39;); acc &#x3D; 0; &#125; &#125; if(acc &#x3D;&#x3D; 1)&#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(),ans.end()); return ans; &#125;&#125;; 看看人家 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; string ans; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int n &#x3D; max(a.size(), b.size()), carry &#x3D; 0; for (size_t i &#x3D; 0; i &lt; n; ++i) &#123; carry +&#x3D; i &lt; a.size() ? (a.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; carry +&#x3D; i &lt; b.size() ? (b.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0; ans.push_back((carry % 2) ? &#39;1&#39; : &#39;0&#39;); carry &#x2F;&#x3D; 2; &#125; if (carry) &#123; ans.push_back(&#39;1&#39;); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;;作者：LeetCode-Solution链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-binary&#x2F;solution&#x2F;er-jin-zhi-qiu-he-by-leetcode-solution&#x2F;来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ###299. 猜数字游戏链接你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为 “Cows”, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数字和朋友猜测的数字都可能含有重复数字。 示例 1: 输入: secret = “1807”, guess = “7810”输出: “1A3B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1807” |“7810”示例 2: 输入: secret = “1123”, guess = “0111”输出: “1A1B”解释: 数字和位置都对（公牛）用 ‘|’ 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。“1123” “1123” | or |“0111” “0111”注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。 题解（吐槽）：中等题的难度也是有区别的，这个算简单吧，而且阅读理解可能是大问题，阅读理解对了之后就是怎么把已知信息用算法表现出来了，欸，思想，就是思想。优化，是不可能优化的，就是从这里跳下去，我也不会优 12345678910111213141516171819class Solution &#123;public: string getHint(string secret, string guess) &#123; &#x2F;&#x2F;简单的方法应该是遍历一遍，把公牛数字找出来，不如排序，或者用map，0到9分别有几个，对应数量相减，再减去公牛数字就是奶牛数字个数，直接用数组就行了 int cow &#x3D; 0, bull &#x3D; 0; int counts[10] &#x3D; &#123;0&#125;,countg[10] &#x3D; &#123;0&#125;; for(int i &#x3D; 0;i &lt; secret.size();++i)&#123; if(secret[i] &#x3D;&#x3D; guess[i]) bull++; else&#123; counts[secret[i] - &#39;0&#39;]++; countg[guess[i] - &#39;0&#39;]++; &#125; &#125; for(int i &#x3D; 0;i&lt;10;i++)&#123; cow +&#x3D; min(countg[i],counts[i]); &#125; return to_string(bull) + &#39;A&#39; + to_string(cow)+&#39;B&#39;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211115","date":"2021-11-14T16:00:00.000Z","updated":"2021-11-17T08:47:50.068Z","comments":true,"path":"2021/11/15/20211115/","link":"","permalink":"http://spcablast.club/2021/11/15/20211115/","excerpt":"","text":"###264. 丑数 II给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10输出：12解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 123456789&#x2F;&#x2F;没人比我更懂暴力算法.jpgint all[] &#x3D; &#123;1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72,75,80,81,90,96,100,108,120,125,128,135,144,150,160,162,180,192,200,216,225,240,243,250,256,270,288,300,320,324,360,375,384,400,405,432,450,480,486,500,512,540,576,600,625,640,648,675,720,729,750,768,800,810,864,900,960,972,1000,1024,1080,1125,1152,1200,1215,1250,1280,1296,1350,1440,1458,1500,1536,1600,1620,1728,1800,1875,1920,1944,2000,2025,2048,2160,2187,2250,2304,2400,2430,2500,2560,2592,2700,2880,2916,3000,3072,3125,3200,3240,3375,3456,3600,3645,3750,3840,3888,4000,4050,4096,4320,4374,4500,4608,4800,4860,5000,5120,5184,5400,5625,5760,5832,6000,6075,6144,6250,6400,6480,6561,6750,6912,7200,7290,7500,7680,7776,8000,8100,8192,8640,8748,9000,9216,9375,9600,9720,10000,10125,10240,10368,10800,10935,11250,11520,11664,12000,12150,12288,12500,12800,12960,13122,13500,13824,14400,14580,15000,15360,15552,15625,16000,16200,16384,16875,17280,17496,18000,18225,18432,18750,19200,19440,19683,20000,20250,20480,20736,21600,21870,22500,23040,23328,24000,24300,24576,25000,25600,25920,26244,27000,27648,28125,28800,29160,30000,30375,30720,31104,31250,32000,32400,32768,32805,33750,34560,34992,36000,36450,36864,37500,38400,38880,39366,40000,40500,40960,41472,43200,43740,45000,46080,46656,46875,48000,48600,49152,50000,50625,51200,51840,52488,54000,54675,55296,56250,57600,58320,59049,60000,60750,61440,62208,62500,64000,64800,65536,65610,67500,69120,69984,72000,72900,73728,75000,76800,77760,78125,78732,80000,81000,81920,82944,84375,86400,87480,90000,91125,92160,93312,93750,96000,97200,98304,98415,100000,101250,102400,103680,104976,108000,109350,110592,112500,115200,116640,118098,120000,121500,122880,124416,125000,128000,129600,131072,131220,135000,138240,139968,140625,144000,145800,147456,150000,151875,153600,155520,156250,157464,160000,162000,163840,164025,165888,168750,172800,174960,177147,180000,182250,184320,186624,187500,192000,194400,196608,196830,200000,202500,204800,207360,209952,216000,218700,221184,225000,230400,233280,234375,236196,240000,243000,245760,248832,250000,253125,256000,259200,262144,262440,270000,273375,276480,279936,281250,288000,291600,294912,295245,300000,303750,307200,311040,312500,314928,320000,324000,327680,328050,331776,337500,345600,349920,354294,360000,364500,368640,373248,375000,384000,388800,390625,393216,393660,400000,405000,409600,414720,419904,421875,432000,437400,442368,450000,455625,460800,466560,468750,472392,480000,486000,491520,492075,497664,500000,506250,512000,518400,524288,524880,531441,540000,546750,552960,559872,562500,576000,583200,589824,590490,600000,607500,614400,622080,625000,629856,640000,648000,655360,656100,663552,675000,691200,699840,703125,708588,720000,729000,737280,746496,750000,759375,768000,777600,781250,786432,787320,800000,810000,819200,820125,829440,839808,843750,864000,874800,884736,885735,900000,911250,921600,933120,937500,944784,960000,972000,983040,984150,995328,1000000,1012500,1024000,1036800,1048576,1049760,1062882,1080000,1093500,1105920,1119744,1125000,1152000,1166400,1171875,1179648,1180980,1200000,1215000,1228800,1244160,1250000,1259712,1265625,1280000,1296000,1310720,1312200,1327104,1350000,1366875,1382400,1399680,1406250,1417176,1440000,1458000,1474560,1476225,1492992,1500000,1518750,1536000,1555200,1562500,1572864,1574640,1594323,1600000,1620000,1638400,1640250,1658880,1679616,1687500,1728000,1749600,1769472,1771470,1800000,1822500,1843200,1866240,1875000,1889568,1920000,1944000,1953125,1966080,1968300,1990656,2000000,2025000,2048000,2073600,2097152,2099520,2109375,2125764,2160000,2187000,2211840,2239488,2250000,2278125,2304000,2332800,2343750,2359296,2361960,2400000,2430000,2457600,2460375,2488320,2500000,2519424,2531250,2560000,2592000,2621440,2624400,2654208,2657205,2700000,2733750,2764800,2799360,2812500,2834352,2880000,2916000,2949120,2952450,2985984,3000000,3037500,3072000,3110400,3125000,3145728,3149280,3188646,3200000,3240000,3276800,3280500,3317760,3359232,3375000,3456000,3499200,3515625,3538944,3542940,3600000,3645000,3686400,3732480,3750000,3779136,3796875,3840000,3888000,3906250,3932160,3936600,3981312,4000000,4050000,4096000,4100625,4147200,4194304,4199040,4218750,4251528,4320000,4374000,4423680,4428675,4478976,4500000,4556250,4608000,4665600,4687500,4718592,4723920,4782969,4800000,4860000,4915200,4920750,4976640,5000000,5038848,5062500,5120000,5184000,5242880,5248800,5308416,5314410,5400000,5467500,5529600,5598720,5625000,5668704,5760000,5832000,5859375,5898240,5904900,5971968,6000000,6075000,6144000,6220800,6250000,6291456,6298560,6328125,6377292,6400000,6480000,6553600,6561000,6635520,6718464,6750000,6834375,6912000,6998400,7031250,7077888,7085880,7200000,7290000,7372800,7381125,7464960,7500000,7558272,7593750,7680000,7776000,7812500,7864320,7873200,7962624,7971615,8000000,8100000,8192000,8201250,8294400,8388608,8398080,8437500,8503056,8640000,8748000,8847360,8857350,8957952,9000000,9112500,9216000,9331200,9375000,9437184,9447840,9565938,9600000,9720000,9765625,9830400,9841500,9953280,10000000,10077696,10125000,10240000,10368000,10485760,10497600,10546875,10616832,10628820,10800000,10935000,11059200,11197440,11250000,11337408,11390625,11520000,11664000,11718750,11796480,11809800,11943936,12000000,12150000,12288000,12301875,12441600,12500000,12582912,12597120,12656250,12754584,12800000,12960000,13107200,13122000,13271040,13286025,13436928,13500000,13668750,13824000,13996800,14062500,14155776,14171760,14348907,14400000,14580000,14745600,14762250,14929920,15000000,15116544,15187500,15360000,15552000,15625000,15728640,15746400,15925248,15943230,16000000,16200000,16384000,16402500,16588800,16777216,16796160,16875000,17006112,17280000,17496000,17578125,17694720,17714700,17915904,18000000,18225000,18432000,18662400,18750000,18874368,18895680,18984375,19131876,19200000,19440000,19531250,19660800,19683000,19906560,20000000,20155392,20250000,20480000,20503125,20736000,20971520,20995200,21093750,21233664,21257640,21600000,21870000,22118400,22143375,22394880,22500000,22674816,22781250,23040000,23328000,23437500,23592960,23619600,23887872,23914845,24000000,24300000,24576000,24603750,24883200,25000000,25165824,25194240,25312500,25509168,25600000,25920000,26214400,26244000,26542080,26572050,26873856,27000000,27337500,27648000,27993600,28125000,28311552,28343520,28697814,28800000,29160000,29296875,29491200,29524500,29859840,30000000,30233088,30375000,30720000,31104000,31250000,31457280,31492800,31640625,31850496,31886460,32000000,32400000,32768000,32805000,33177600,33554432,33592320,33750000,34012224,34171875,34560000,34992000,35156250,35389440,35429400,35831808,36000000,36450000,36864000,36905625,37324800,37500000,37748736,37791360,37968750,38263752,38400000,38880000,39062500,39321600,39366000,39813120,39858075,40000000,40310784,40500000,40960000,41006250,41472000,41943040,41990400,42187500,42467328,42515280,43046721,43200000,43740000,44236800,44286750,44789760,45000000,45349632,45562500,46080000,46656000,46875000,47185920,47239200,47775744,47829690,48000000,48600000,48828125,49152000,49207500,49766400,50000000,50331648,50388480,50625000,51018336,51200000,51840000,52428800,52488000,52734375,53084160,53144100,53747712,54000000,54675000,55296000,55987200,56250000,56623104,56687040,56953125,57395628,57600000,58320000,58593750,58982400,59049000,59719680,60000000,60466176,60750000,61440000,61509375,62208000,62500000,62914560,62985600,63281250,63700992,63772920,64000000,64800000,65536000,65610000,66355200,66430125,67108864,67184640,67500000,68024448,68343750,69120000,69984000,70312500,70778880,70858800,71663616,71744535,72000000,72900000,73728000,73811250,74649600,75000000,75497472,75582720,75937500,76527504,76800000,77760000,78125000,78643200,78732000,79626240,79716150,80000000,80621568,81000000,81920000,82012500,82944000,83886080,83980800,84375000,84934656,85030560,86093442,86400000,87480000,87890625,88473600,88573500,89579520,90000000,90699264,91125000,92160000,93312000,93750000,94371840,94478400,94921875,95551488,95659380,96000000,97200000,97656250,98304000,98415000,99532800,100000000,100663296,100776960,101250000,102036672,102400000,102515625,103680000,104857600,104976000,105468750,106168320,106288200,107495424,108000000,109350000,110592000,110716875,111974400,112500000,113246208,113374080,113906250,114791256,115200000,116640000,117187500,117964800,118098000,119439360,119574225,120000000,120932352,121500000,122880000,123018750,124416000,125000000,125829120,125971200,126562500,127401984,127545840,128000000,129140163,129600000,131072000,131220000,132710400,132860250,134217728,134369280,135000000,136048896,136687500,138240000,139968000,140625000,141557760,141717600,143327232,143489070,144000000,145800000,146484375,147456000,147622500,149299200,150000000,150994944,151165440,151875000,153055008,153600000,155520000,156250000,157286400,157464000,158203125,159252480,159432300,160000000,161243136,162000000,163840000,164025000,165888000,167772160,167961600,168750000,169869312,170061120,170859375,172186884,172800000,174960000,175781250,176947200,177147000,179159040,180000000,181398528,182250000,184320000,184528125,186624000,187500000,188743680,188956800,189843750,191102976,191318760,192000000,194400000,195312500,196608000,196830000,199065600,199290375,200000000,201326592,201553920,202500000,204073344,204800000,205031250,207360000,209715200,209952000,210937500,212336640,212576400,214990848,215233605,216000000,218700000,221184000,221433750,223948800,225000000,226492416,226748160,227812500,229582512,230400000,233280000,234375000,235929600,236196000,238878720,239148450,240000000,241864704,243000000,244140625,245760000,246037500,248832000,250000000,251658240,251942400,253125000,254803968,255091680,256000000,258280326,259200000,262144000,262440000,263671875,265420800,265720500,268435456,268738560,270000000,272097792,273375000,276480000,279936000,281250000,283115520,283435200,284765625,286654464,286978140,288000000,291600000,292968750,294912000,295245000,298598400,300000000,301989888,302330880,303750000,306110016,307200000,307546875,311040000,312500000,314572800,314928000,316406250,318504960,318864600,320000000,322486272,324000000,327680000,328050000,331776000,332150625,335544320,335923200,337500000,339738624,340122240,341718750,344373768,345600000,349920000,351562500,353894400,354294000,358318080,358722675,360000000,362797056,364500000,368640000,369056250,373248000,375000000,377487360,377913600,379687500,382205952,382637520,384000000,387420489,388800000,390625000,393216000,393660000,398131200,398580750,400000000,402653184,403107840,405000000,408146688,409600000,410062500,414720000,419430400,419904000,421875000,424673280,425152800,429981696,430467210,432000000,437400000,439453125,442368000,442867500,447897600,450000000,452984832,453496320,455625000,459165024,460800000,466560000,468750000,471859200,472392000,474609375,477757440,478296900,480000000,483729408,486000000,488281250,491520000,492075000,497664000,500000000,503316480,503884800,506250000,509607936,510183360,512000000,512578125,516560652,518400000,524288000,524880000,527343750,530841600,531441000,536870912,537477120,540000000,544195584,546750000,552960000,553584375,559872000,562500000,566231040,566870400,569531250,573308928,573956280,576000000,583200000,585937500,589824000,590490000,597196800,597871125,600000000,603979776,604661760,607500000,612220032,614400000,615093750,622080000,625000000,629145600,629856000,632812500,637009920,637729200,640000000,644972544,645700815,648000000,655360000,656100000,663552000,664301250,671088640,671846400,675000000,679477248,680244480,683437500,688747536,691200000,699840000,703125000,707788800,708588000,716636160,717445350,720000000,725594112,729000000,732421875,737280000,738112500,746496000,750000000,754974720,755827200,759375000,764411904,765275040,768000000,774840978,777600000,781250000,786432000,787320000,791015625,796262400,797161500,800000000,805306368,806215680,810000000,816293376,819200000,820125000,829440000,838860800,839808000,843750000,849346560,850305600,854296875,859963392,860934420,864000000,874800000,878906250,884736000,885735000,895795200,900000000,905969664,906992640,911250000,918330048,921600000,922640625,933120000,937500000,943718400,944784000,949218750,955514880,956593800,960000000,967458816,972000000,976562500,983040000,984150000,995328000,996451875,1000000000,1006632960,1007769600,1012500000,1019215872,1020366720,1024000000,1025156250,1033121304,1036800000,1048576000,1049760000,1054687500,1061683200,1062882000,1073741824,1074954240,1076168025,1080000000,1088391168,1093500000,1105920000,1107168750,1119744000,1125000000,1132462080,1133740800,1139062500,1146617856,1147912560,1152000000,1162261467,1166400000,1171875000,1179648000,1180980000,1194393600,1195742250,1200000000,1207959552,1209323520,1215000000,1220703125,1224440064,1228800000,1230187500,1244160000,1250000000,1258291200,1259712000,1265625000,1274019840,1275458400,1280000000,1289945088,1291401630,1296000000,1310720000,1312200000,1318359375,1327104000,1328602500,1342177280,1343692800,1350000000,1358954496,1360488960,1366875000,1377495072,1382400000,1399680000,1406250000,1415577600,1417176000,1423828125,1433272320,1434890700,1440000000,1451188224,1458000000,1464843750,1474560000,1476225000,1492992000,1500000000,1509949440,1511654400,1518750000,1528823808,1530550080,1536000000,1537734375,1549681956,1555200000,1562500000,1572864000,1574640000,1582031250,1592524800,1594323000,1600000000,1610612736,1612431360,1620000000,1632586752,1638400000,1640250000,1658880000,1660753125,1677721600,1679616000,1687500000,1698693120,1700611200,1708593750,1719926784,1721868840,1728000000,1749600000,1757812500,1769472000,1771470000,1791590400,1793613375,1800000000,1811939328,1813985280,1822500000,1836660096,1843200000,1845281250,1866240000,1875000000,1887436800,1889568000,1898437500,1911029760,1913187600,1920000000,1934917632,1937102445,1944000000,1953125000,1966080000,1968300000,1990656000,1992903750,2000000000,2013265920,2015539200,2025000000,2038431744,2040733440,2048000000,2050312500,2066242608,2073600000,2097152000,2099520000,2109375000,2123366400&#125;;class Solution &#123;public: int nthUglyNumber(int n) &#123; return all[n-1]; &#125;&#125;; #######正常解法 12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] &#x3D; 1; int p2 &#x3D; 1, p3 &#x3D; 1, p5 &#x3D; 1; for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; int num2 &#x3D; dp[p2] * 2, num3 &#x3D; dp[p3] * 3, num5 &#x3D; dp[p5] * 5; dp[i] &#x3D; min(min(num2, num3), num5);&#x2F;&#x2F;取个最小的保证顺序 if (dp[i] &#x3D;&#x3D; num2) &#123;&#x2F;&#x2F;pi++的意思是这个数乘了2还是最小的，其他的数乘了3，5应该加到下一个了 p2++; &#125; if (dp[i] &#x3D;&#x3D; num3) &#123; p3++; &#125; if (dp[i] &#x3D;&#x3D; num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 那我只能说，我不理解，到底该谁乘2，谁乘3，谁乘5，乘几次啊 ###剑指 Offer II 069. 山峰数组的顶部符合下列属性的数组 arr 称为 山峰数组（山脉数组） ： arr.length &gt;= 3存在 i（0 &lt; i &lt; arr.length - 1）使得：arr[0] &lt; arr[1] &lt; … arr[i-1] &lt; arr[i]arr[i] &gt; arr[i+1] &gt; … &gt; arr[arr.length - 1]给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。 示例 1： 输入：arr = [0,1,0]输出：1示例 2： 输入：arr = [1,3,5,4,2]输出：2 1234567891011class Solution &#123;public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) &#123; int max &#x3D; arr[0]; for(int i&#x3D;1;i&lt;arr.size();++i)&#123; if(arr[i] &lt; max) return i - 1; max &#x3D; arr[i]; &#125; return 0; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211114","date":"2021-11-13T16:00:00.000Z","updated":"2021-11-17T08:47:58.276Z","comments":true,"path":"2021/11/14/20211114/","link":"","permalink":"http://spcablast.club/2021/11/14/20211114/","excerpt":"","text":"###455. 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 1234567891011121314151617181920class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; int totol &#x3D; 0; sort(g.begin(),g.end());&#x2F;&#x2F;默认由小到大排序 sort(s.begin(),s.end()); int j &#x3D; 0; for(int i &#x3D; 0; i&lt; g.size();++i)&#123; while(j &lt; s.size())&#123; if(s[j] &gt;&#x3D; g[i]) &#123; totol++; j++; break; &#125; else j++; &#125; &#125; return totol; &#125;&#125;; ###剑指 Offer 56 - I. 数组中数字出现的次数一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]示例 2： 输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; &#x2F;&#x2F;我只能说，NB，这方法，顶 int ret &#x3D; 0; for (int n : nums) ret ^&#x3D; n; int div &#x3D; 1; while ((div &amp; ret) &#x3D;&#x3D; 0) div &lt;&lt;&#x3D; 1; int a &#x3D; 0, b &#x3D; 0; for (int n : nums) if (div &amp; n) a ^&#x3D; n; else b ^&#x3D; n; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211113","date":"2021-11-12T16:00:00.000Z","updated":"2021-11-17T08:48:03.461Z","comments":true,"path":"2021/11/13/20211113/","link":"","permalink":"http://spcablast.club/2021/11/13/20211113/","excerpt":"","text":"###面试题 10.11. 峰与谷在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。 示例: 输入: [5, 3, 1, 2, 3]输出: [5, 1, 3, 2, 3] 1234567891011121314151617181920212223242526272829class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; vers(nums); int left &#x3D; 0, right &#x3D; nums.size()-1, len &#x3D;nums.size(); sort(vers.begin(),vers.end()); int index &#x3D; 0; while(left &lt; right)&#123; nums[index++] &#x3D; vers[left++]; nums[index++] &#x3D; vers[right--]; &#125; if(nums.size()%2 !&#x3D; 0) nums[index] &#x3D; vers[left]; &#x2F;&#x2F;这个回答和我有缘，想到一块去了 &#x2F;&#x2F; size_t idx &#x3D; 0, len &#x3D; nums.size(); &#x2F;&#x2F; if (len &lt; 3) return; &#x2F;&#x2F; size_t low &#x3D; 0, high &#x3D; len - 1; &#x2F;&#x2F; vector&lt;int&gt; sorted(nums); &#x2F;&#x2F; sort(sorted.begin(), sorted.end()); &#x2F;&#x2F; while (low &lt; high) &#123; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[high--]; &#x2F;&#x2F; nums[idx++] &#x3D; sorted[low++]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if (len % 2 &gt; 0) nums[idx] &#x3D; sorted[low]; &#x2F;&#x2F; 作者：gfu &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;peaks-and-valleys-lcci&#x2F;solution&#x2F; bi-jiao-zhi-guan-de-xiang-fa-xian-pai-xu-by-gfu&#x2F; &#x2F;&#x2F; 来源：力扣（LeetCode） &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 &#125;&#125;; ###13. 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: int romanToInt(string s) &#123; int lastNum &#x3D; 0, totol &#x3D; 0; for(int i &#x3D; 0; i&lt; s.length();i++)&#123; if(s[i] &#x3D;&#x3D; &#39;I&#39;)&#123; lastNum &#x3D; 1; totol +&#x3D; 1; &#125; else if(s[i] &#x3D;&#x3D; &#39;V&#39;)&#123; if(lastNum &lt; 5)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 5; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 5; totol +&#x3D; 5; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;X&#39;)&#123; if(lastNum &lt; 10)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 10; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 10; totol +&#x3D; 10; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;L&#39;)&#123; if(lastNum &lt; 50)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 50; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 50; totol +&#x3D; 50; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;C&#39;)&#123; if(lastNum &lt; 100)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 100; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 100; totol +&#x3D; 100; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;D&#39;)&#123; if(lastNum &lt; 500)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 500; totol +&#x3D;lastNum; &#125; else &#123; lastNum &#x3D; 500; totol +&#x3D; 500; &#125; &#125; else if(s[i] &#x3D;&#x3D; &#39;M&#39;)&#123; if(lastNum &lt; 1000)&#123; totol -&#x3D; 2*lastNum; lastNum &#x3D; 1000; totol +&#x3D;lastNum; &#125; else totol +&#x3D; 1000; &#125; &#125; return totol; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211112","date":"2021-11-11T16:00:00.000Z","updated":"2021-11-17T08:48:08.786Z","comments":true,"path":"2021/11/12/20211112/","link":"","permalink":"http://spcablast.club/2021/11/12/20211112/","excerpt":"","text":"###5. 最长回文子串给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = “babad”输出：”bab”解释：”aba” 同样是符合题意的答案。 Solution &#123;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public: void len(int * result, int i, int j, string s)&#123; if(i!&#x3D;j &amp;&amp; s[i] !&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; i; &#125; while(i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123; result[0] &#x3D; i; result[1] &#x3D; j; --i; ++j; &#125; return; &#125; string longestPalindrome(string s) &#123; if(s.length() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; int maxLen[2], maxi, maxL; int start &#x3D; 0, end &#x3D; 0; int index1[2],index2[2]; for(int k &#x3D; 0; k &lt; s.length(); ++k)&#123; len(index1, k, k, s); len(index2, k, k+1, s); if(index1[1] - index1[0] &gt; end -start)&#123; start &#x3D; index1[0]; end &#x3D; index1[1]; &#125; if(index2[1] - index2[0] &gt; end -start)&#123; start &#x3D; index2[0]; end &#x3D; index2[1]; &#125; &#125; return s.substr(start, end - start + 1); &#x2F;&#x2F;for(int j &#x3D; k, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; (j+1) &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F;&#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;for(int k &#x3D; 1; k &lt; s.length(); ++k)&#123; &#x2F;&#x2F; for(int j &#x3D; k+1, i &#x3D; k; (i -1) &gt;&#x3D;0 &amp;&amp; j &lt; s.length(); ++j ,--i)&#123; &#x2F;&#x2F; if(s[i] &#x3D;&#x3D; s[j])&#123; &#x2F;&#x2F; if(maxLen &lt;&#x3D; 2)&#123; &#x2F;&#x2F; maxLen &#x3D; 2; &#x2F;&#x2F; maxi &#x3D; j; &#x2F;&#x2F; &#125; &#x2F;&#x2F; if(s[i-1] &#x3D;&#x3D; s[j+1])&#123; &#x2F;&#x2F; if(j - i + 2 &gt; maxLen)&#123; &#x2F;&#x2F; maxLen &#x3D; j-i+3; &#x2F;&#x2F; maxi &#x3D; i-1; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F; else break; &#x2F;&#x2F; &#125; &#x2F;&#x2F;&#125; &#x2F;&#x2F;return s.substr(maxi, maxLen); &#125;&#125;; ###14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1： 输入：strs = [“flower”,”flow”,”flight”]输出：”fl” 123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() &#x3D;&#x3D; 0 )&#123; return &quot;&quot;; &#125; string ans &#x3D; strs[0]; for(int j &#x3D; 0; j &lt; strs.size() ; ++j )&#123; int i &#x3D; 0; for(; i &lt;&#x3D; strs[0].length() &amp;&amp; i &lt; ans.length(); ++i)&#123; if(ans[i] !&#x3D; strs[j][i])&#123; break; &#125; &#125; if(ans.length() &#x3D;&#x3D; 0) return &quot;&quot;; ans &#x3D; strs[0].substr(0,i); &#125; return ans; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211111","date":"2021-11-10T16:00:00.000Z","updated":"2021-11-17T08:48:14.096Z","comments":true,"path":"2021/11/11/20211111/","link":"","permalink":"http://spcablast.club/2021/11/11/20211111/","excerpt":"","text":"###1785. 构成特定和需要添加的最少元素给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 1234567891011121314151617class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long long int sum &#x3D; 0; for(int num:nums)&#123; sum +&#x3D; num; &#125; if(sum &#x3D;&#x3D; goal) return 0; if(abs(sum - goal) &lt; abs(limit))&#123; return 1; &#125; if(abs(sum - goal) % abs(limit) &#x3D;&#x3D; 0 )&#123; return abs(sum - goal) &#x2F; abs(limit); &#125; else return abs(sum - goal) &#x2F; abs(limit) + 1; &#125;&#125;; ###剑指 Offer 55 - I. 二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / 9 20 / 15 7返回它的最大深度 3 。 12345678910111213141516&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left) , maxDepth(root-&gt;right)) +1; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211110","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-17T08:48:20.645Z","comments":true,"path":"2021/11/10/20211110/","link":"","permalink":"http://spcablast.club/2021/11/10/20211110/","excerpt":"","text":"###1267. 统计参与通信的服务器链接 这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]输出：4解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;int&gt; rows(grid.size(),0); vector&lt;int&gt; cols(grid[0].size(),0); vector&lt;int&gt; iso; int totleIso &#x3D; 0, totle &#x3D; 0; for(int i &#x3D; 0;i &lt; grid.size(); ++i)&#123; for(int j &#x3D; 0; j &lt; grid[0].size(); j++)&#123; rows[i] +&#x3D;grid[i][j];&#x2F;&#x2F;行的和 cols[j] +&#x3D;grid[i][j];&#x2F;&#x2F;列的和 &#125; if(rows[i] &#x3D;&#x3D; 1)&#123; iso.push_back(i); &#125; totle +&#x3D; rows[i]; &#125; for(int k &#x3D; 0; k &lt; iso.size();++k)&#123; int temp &#x3D; iso[k]; &#x2F;&#x2F;iso[k]是只有一个服务器的行 for(int l &#x3D; 0; l &lt; cols.size(); ++l)&#123; if(grid[temp][l] &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;找到列数了 if(cols[l] &#x3D;&#x3D; 1)&#123; totleIso++; &#125; &#125; &#125; &#125; return totle - totleIso; &#125;&#125;; ###剑指 Offer 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 123456789101112131415161718192021222324&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode * point &#x3D; head; int len &#x3D; 0; while(point-&gt;next)&#123; point &#x3D; point-&gt;next; len++; &#125; point &#x3D; head; for(int i &#x3D; 0; len - i &gt;&#x3D; k; i++)&#123; point &#x3D; point-&gt;next; &#125; return point; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211109","date":"2021-11-08T16:00:00.000Z","updated":"2021-11-17T08:48:25.246Z","comments":true,"path":"2021/11/09/20211109/","link":"","permalink":"http://spcablast.club/2021/11/09/20211109/","excerpt":"","text":"###1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans(2,0); for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123; int temp &#x3D; target - nums[i]; &#x2F;&#x2F;if( temp &lt; 0 ) continue; for(int j &#x3D; i+1; j &lt;nums.size(); ++j)&#123; if(temp &#x3D;&#x3D; nums[j] )&#123; ans[0] &#x3D; i; ans[1] &#x3D; j; return ans; &#125; &#125; &#125; return ans; &#125;&#125;;&#x2F;&#x2F;我就说哈希表好嘛，虽然我不会 ###198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 1234567891011121314151617181920class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &#x3D;&#x3D; 1)&#123; return nums[0]; &#125; if(nums.size() &#x3D;&#x3D; 2)&#123; return max(nums[0],nums[1]); &#125; vector&lt;int&gt; ma(nums.size()+1, 0); ma[0] &#x3D; nums[0]; ma[1] &#x3D; max(nums[0], nums[1]); int maxNum &#x3D; 0; for(int i &#x3D; 2; i &lt; nums.size(); i++)&#123; maxNum &#x3D; nums[i]; ma[i] &#x3D; max(ma[i - 1], ma[i -2] + maxNum ); &#125; return ma[nums.size() - 1]; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211108","date":"2021-11-07T16:00:00.000Z","updated":"2021-11-17T08:48:31.915Z","comments":true,"path":"2021/11/08/20211108/","link":"","permalink":"http://spcablast.club/2021/11/08/20211108/","excerpt":"","text":"###1105. 填充书架附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelfWidth) &#123; &#x2F;&#x2F;我大受震撼，且我不理解，下次让我做我还不会 &#x2F;&#x2F; vector&lt;int&gt; d(books.size()+1,INT_MAX); &#x2F;&#x2F; d[books.size()] &#x3D; 0; &#x2F;&#x2F; for(int i &#x3D; books.size() - 1; i &gt;&#x3D; 0 ; --i)&#123; &#x2F;&#x2F; int MaxHeight &#x3D; 0; &#x2F;&#x2F; int leftWith &#x3D; shelfWidth; &#x2F;&#x2F; for(int j &#x3D; i; j &lt; books.size() &amp;&amp; leftWith &gt; books[j][0]; ++j)&#123; &#x2F;&#x2F; MaxHeight &#x3D; max(books[j][1], MaxHeight); &#x2F;&#x2F; d[i] &#x3D; min(MaxHeight + d[j+1],d[i]); &#x2F;&#x2F; leftWith -&#x3D; books[j][0]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return d[0]; vector&lt;int&gt; dp(books.size() + 1, INT_MAX); dp[books.size()] &#x3D; 0; for (int i &#x3D; books.size() - 1; i &gt;&#x3D; 0; --i) &#123; int max_book_height &#x3D; 0; int left_width &#x3D; shelfWidth; &#x2F;&#x2F; 把第 j 本书拿到第 i 本书后面 for (int j &#x3D; i; j &lt; books.size() &amp;&amp; left_width &gt;&#x3D; books[j][0]; ++j) &#123; max_book_height &#x3D; max(max_book_height, books[j][1]); dp[i] &#x3D; min(dp[i], max_book_height + dp[j+1]); left_width -&#x3D; books[j][0]; &#125; &#125; return dp[0];&#125;; ###1822. 数组元素积的符号已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 12345678910111213class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int product = 1; for(int num : nums)&#123; if(num == 0) return 0; if(num &lt; 0) product *= -1; &#125; return product; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211107","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-17T08:48:36.580Z","comments":true,"path":"2021/11/07/20211107/","link":"","permalink":"http://spcablast.club/2021/11/07/20211107/","excerpt":"","text":"###面试题 04.05. 合法二叉搜索树实现一个函数，检查一棵二叉树是否为二叉搜索树。示例 1:输入: 2 / 1 3输出: true 1234567891011121314151617181920212223242526272829303132333435&#x2F;** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:&#x2F;&#x2F;递归失败 &#x2F;&#x2F;bool myIsValidBST(TreeNode* root,TreeNode* min, TreeNode* max )&#123; &#x2F;&#x2F; if(!root) return true; &#x2F;&#x2F; if(min !&#x3D; nullptr &amp;&amp; root-&gt;val &lt;&#x3D; min-&gt;val) return false; &#x2F;&#x2F; if(max !&#x3D; nullptr &amp;&amp; root-&gt;val &gt;&#x3D; max-&gt;val) return false; &#x2F;&#x2F; return (myIsValidBST(root-&gt;left, min, root) &amp;&amp; myIsValidBST(root-&gt;right, root , max)); &#x2F;&#x2F;&#125; &#x2F;&#x2F;bool isValidBST(TreeNode* root) &#123; &#x2F;&#x2F; return myIsValidBST(root, root-&gt;left, root-&gt;right); &#x2F;&#x2F;&#125;&#x2F;&#x2F;正确递归bool helper(TreeNode* root, long long lower, long long upper) &#123; if (root &#x3D;&#x3D; nullptr) &#123; return true; &#125; if (root -&gt; val &lt;&#x3D; lower || root -&gt; val &gt;&#x3D; upper) &#123; return false; &#125; return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return helper(root, LONG_MIN, LONG_MAX); &#125;&#125;; ###面试题 02.06. 回文链表编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:bool isPalindrome(ListNode* head) &#123;&#x2F;&#x2F;来个入栈是不是就解决了,失败了又，不能直接入栈判断当前和下一个是否相等就消去&#x2F;&#x2F; if(!head) return true;&#x2F;&#x2F; stack&lt;int&gt; list;&#x2F;&#x2F; ListNode* cur &#x3D; head;&#x2F;&#x2F;while(cur)&#123;&#x2F;&#x2F; curNum &#x3D; cur-&gt;val;&#x2F;&#x2F; list.push(cur-&gt;val);&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; if(cur)&#123;&#x2F;&#x2F; if(list.top() &#x3D;&#x3D; cur-&gt;val)&#123;&#x2F;&#x2F; list.pop();&#x2F;&#x2F; cur &#x3D; cur-&gt;next;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; return list.top() &#x3D;&#x3D; temp; vector&lt;int&gt; vals;while (head !&#x3D; nullptr) &#123; vals.emplace_back(head-&gt;val); head &#x3D; head-&gt;next;&#125;for (int i &#x3D; 0, j &#x3D; (int)vals.size() - 1; i &lt; j; ++i, --j) &#123; if (vals[i] !&#x3D; vals[j]) &#123; return false; &#125;&#125; return true;&#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"Dailycode","slug":"20211106","date":"2021-11-05T16:00:00.000Z","updated":"2021-11-17T08:48:43.077Z","comments":true,"path":"2021/11/06/20211106/","link":"","permalink":"http://spcablast.club/2021/11/06/20211106/","excerpt":"","text":"###82. 删除排序链表中的重复元素 II存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。示例 1：输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates( ListNode* head) &#123; if(!head) return head; ListNode* singleNode = new ListNode(0,head); ListNode* flagHeader = singleNode; while(flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;next)&#123; if(flagHeader-&gt;next-&gt;val == flagHeader-&gt;next-&gt;next-&gt;val)&#123; int temp = flagHeader-&gt;next-&gt;val; while( flagHeader-&gt;next &amp;&amp; flagHeader-&gt;next-&gt;val == temp )&#123; flagHeader-&gt;next = flagHeader-&gt;next-&gt;next; &#125; &#125; else&#123; flagHeader = flagHeader-&gt;next; &#125; &#125; return singleNode-&gt;next; &#125;&#125;; ###剑指 Offer 39. 数组中出现次数超过一半的数字 链接 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //来个map? unordered_map&lt;int, int&gt; myMap; int temp = 0, maxNum = 0; for(int num : nums)&#123; ++myMap[num]; if(myMap[num] &gt; maxNum)&#123; temp = num; maxNum = myMap[num]; &#125; &#125; return temp; &#125;&#125;;","categories":[{"name":"Dailycode","slug":"Dailycode","permalink":"http://spcablast.club/categories/Dailycode/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://spcablast.club/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"author":"YP"},{"title":"报的错","slug":"报的错","date":"2021-08-28T01:50:14.674Z","updated":"2021-08-28T01:50:14.776Z","comments":true,"path":"2021/08/28/报的错/","link":"","permalink":"http://spcablast.club/2021/08/28/%E6%8A%A5%E7%9A%84%E9%94%99/","excerpt":"","text":"###dll 64位的程序放了32为位的dll，在运行的时候就会报0xc0000007b的错###用#define pi,#define eps这种语句会导致和opencv里的pi,eps冲突，使得opencv编译不成功。","categories":[],"tags":[]},{"title":"Markdown_test","slug":"Markdown_test","date":"2021-07-16T09:14:24.409Z","updated":"2021-04-24T12:07:09.991Z","comments":true,"path":"2021/07/16/Markdown_test/","link":"","permalink":"http://spcablast.club/2021/07/16/Markdown_test/","excerpt":"","text":"##写点啥呢 熟悉一下Markdown语法 于2021年4月24日晚19点54分 过沙溪急，烟溪冷，月溪明 这里是spca的博客测试文章的链接 ###标题下面一定会有文字框吗是这样吗并不是的，似乎只有一级标题下才有 ###再试一次 加了缩进的话就有文字框了，一个Tab ![name] (图片路径即可插入图片) 我是粗体的金戈铁马，气吞万里如虎 我是斜体的小桥流水人家，夕阳西下 看着表格的格式这辈子都不想用的 整段代码 #include&lt;stdlib.h&gt;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-16T09:14:24.358Z","updated":"2020-01-10T13:09:23.526Z","comments":true,"path":"2021/07/16/hello-world/","link":"","permalink":"http://spcablast.club/2021/07/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"test","slug":"新建文本文档","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-29T00:40:08.601Z","comments":true,"path":"2021/04/24/新建文本文档/","link":"","permalink":"http://spcablast.club/2021/04/24/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","excerpt":"","text":"test","categories":[],"tags":[],"author":"YP"},{"title":"2020-1-7 NASM安装和使用","slug":"NASM安装使用","date":"2020-01-07T16:00:00.000Z","updated":"2020-01-14T02:19:07.189Z","comments":true,"path":"2020/01/08/NASM安装使用/","link":"","permalink":"http://spcablast.club/2020/01/08/NASM%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"下载和安装在官网下载相应的安装包，我是win8（64位），我下载的是nasm-2.14.03rc2-installer-x64.exe，下载下来直接双击一路安装就好了。 问题在于安装完了怎么检测他装好了以及使用。安装好了的NASM文件夹里面有一个NASM.exe，这不是害人吗，我点了那么多次，每次都黑窗口闪退，丢人，查了才知道要打开cmd到安装目录下直接使用，查看是否安装成功直接 一些NASM命令 查看版本号 1&#96;nasm -v&#96; 把文件boot.asm汇编成二进制文件boot.bin 1nasm boot.asm -o boot.bin 反汇编二进制文件 1ndisasmw -o 0x7c00 boot.bin &gt;&gt; disboot.asm 把文件boot.asm汇编成二进制文件boot.com使可以在dos下运行，调试起来容易一些以及先把第一行的org 07c00h改成org 0100h 1nasm boot.asm -o boot.com .com文件用Turbo Debugger调试用我的64位计算机运行报了个错，书上说在虚拟PCDOS上运行，待试验，报错如下 暂时到这儿，待续","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://spcablast.club/tags/%E6%B1%87%E7%BC%96/"},{"name":"操作系统","slug":"操作系统","permalink":"http://spcablast.club/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"YP"},{"title":"2021-4-29 ORB-SLAM2源码","slug":"SLAM初始化点云位姿流程","date":"2020-01-07T16:00:00.000Z","updated":"2021-04-29T00:42:14.200Z","comments":true,"path":"2020/01/08/SLAM初始化点云位姿流程/","link":"","permalink":"http://spcablast.club/2020/01/08/SLAM%E5%88%9D%E5%A7%8B%E5%8C%96%E7%82%B9%E4%BA%91%E4%BD%8D%E5%A7%BF%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Initializer.cc Initializer::Initializer()构建初始化器，","categories":[],"tags":[{"name":"ORBSLAM2","slug":"ORBSLAM2","permalink":"http://spcablast.club/tags/ORBSLAM2/"},{"name":"SLAM","slug":"SLAM","permalink":"http://spcablast.club/tags/SLAM/"},{"name":"c++","slug":"c","permalink":"http://spcablast.club/tags/c/"}],"author":"YP"}]}